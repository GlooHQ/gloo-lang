# BAML Ruby Client

> **⚠️ IMPORTANT NOTE**
>
> This document was initially generated by an AI assistant and should be taken with a grain of salt. While it provides a good starting point, some information might be inaccurate or outdated. We encourage contributors to manually update this document and remove this note once the content has been verified and corrected by the team.
>
> If you find any inaccuracies or have improvements to suggest, please feel free to submit a PR updating this guide.

Native Ruby bindings for BAML, providing type-safe LLM function calls with Sorbet type checking.

## Features

- Native Ruby bindings via FFI
- Sorbet type checking
- Fiber-based async support
- Streaming responses
- Error handling with type safety
- RBS type definitions

## Installation

```bash
# Using bundler
bundle add baml-rb

# Using gem
gem install baml-rb

# Development installation
bundle install
bundle exec rake compile
```

## Usage

### Basic Example
```ruby
require 'baml'

# @param text [String]
# @return [UserInfo]
def extract_user_info(text)
  # Call BAML function with type safety
  result = Baml.extract_user_info(text)
  raise TypeError unless result.is_a?(UserInfo)
  result
end
```

### Streaming Example
```ruby
def stream_response(text)
  Baml.streaming_function.stream(text) do |chunk|
    puts "Received chunk: #{chunk}"
  end
end
```

### Error Handling
```ruby
begin
  result = Baml.my_function(text)
rescue Baml::ProviderError => e
  puts "Provider error: #{e.message}"
rescue Baml::ValidationError => e
  puts "Validation error: #{e.errors}"
rescue Baml::Error => e
  puts "BAML error: #{e}"
end
```

## Development

### Prerequisites
- Ruby 3.0+
- Rust toolchain
- Bundler
- Rake

### Setup
```bash
# Install dependencies
bundle install

# Build native extension
bundle exec rake compile

# Run tests
bundle exec rake test
```

### Project Structure
```
language_client_ruby/
├── ext/
│   ├── lib.rs         # FFI bindings
│   ├── types.rs       # Type conversions
│   └── async.rs       # Fiber support
├── lib/
│   ├── baml.rb        # Ruby wrapper
│   ├── types.rb       # Type definitions
│   └── version.rb     # Version info
├── sig/               # RBS type definitions
└── test/             # Test suite
```

## Adding Features

### 1. New Type Definition

1. Add Ruby class:
```ruby
module Baml
  class NewType
    extend T::Sig

    sig { returns(String) }
    attr_reader :field

    sig { params(field: String).void }
    def initialize(field)
      @field = field
    end
  end
end
```

2. Add RBS type:
```rbs
module Baml
  class NewType
    attr_reader field: String
    def initialize: (field: String) -> void
  end
end
```

3. Add Rust binding:
```rust
#[derive(Debug)]
pub struct NewType {
    pub field: String,
}

impl From<NewType> for Value {
    fn from(t: NewType) -> Self {
        let hash = Hash::new();
        hash.store(
            Symbol::new("field"),
            t.field.into(),
        );
        hash.into()
    }
}
```

### 2. New Function

1. Add function binding:
```rust
#[no_mangle]
pub extern "C" fn baml_my_function(
    input: Value,
) -> Value {
    // Implementation
}
```

2. Add Ruby wrapper:
```ruby
module Baml
  extend T::Sig

  sig { params(input: String).returns(NewType) }
  def self.my_function(input)
    result = Native.baml_my_function(input)
    NewType.from_native(result)
  end
end
```

## Testing

### Unit Tests
```ruby
require 'test_helper'

class TestBaml < Minitest::Test
  def test_function
    result = Baml.test_function('input')
    assert_equal 'expected', result.field
  end
end
```

### Integration Tests
```ruby
class TestProvider < Minitest::Test
  def test_provider_integration
    result = Baml.provider_test('input')
    assert result.valid?
  end
end
```

## Error Handling

```ruby
module Baml
  class Error < StandardError; end

  class ProviderError < Error
    attr_reader :status_code

    def initialize(message, status_code)
      super(message)
      @status_code = status_code
    end
  end

  class ValidationError < Error
    attr_reader :errors

    def initialize(errors)
      super('Validation failed')
      @errors = errors
    end
  end
end
```

## Performance

### Fiber Support
```ruby
def process_many(inputs)
  fibers = inputs.map do |input|
    Fiber.new do
      Baml.function(input)
    end
  end
  fibers.map(&:resume)
end
```

### Streaming
```ruby
def stream_with_buffer(text, buffer_size = 1000)
  buffer = []
  Baml.streaming_function.stream(text) do |chunk|
    buffer << chunk
    if buffer.size >= buffer_size
      yield buffer
      buffer = []
    end
  end
  yield buffer unless buffer.empty?
end
```

## Type Safety

### Sorbet Types
```ruby
module Baml
  class UserProfile
    extend T::Sig

    sig { returns(String) }
    attr_reader :name

    sig { returns(Integer) }
    attr_reader :age

    sig { returns(String) }
    attr_reader :email

    sig { returns(T::Hash[Symbol, T.any(String, T::Boolean)]) }
    attr_reader :preferences

    sig do
      params(
        name: String,
        age: Integer,
        email: String,
        preferences: T::Hash[Symbol, T.any(String, T::Boolean)]
      ).void
    end
    def initialize(name:, age:, email:, preferences: {})
      @name = name
      @age = age
      @email = email
      @preferences = preferences
    end
  end
end
```

### RBS Types
```rbs
module Baml
  class UserProfile
    attr_reader name: String
    attr_reader age: Integer
    attr_reader email: String
    attr_reader preferences: Hash[Symbol, String | bool]

    def initialize: (
      name: String,
      age: Integer,
      email: String,
      ?preferences: Hash[Symbol, String | bool]
    ) -> void
  end
end
```

## Best Practices

1. **Error Handling**
   - Use custom error classes
   - Provide detailed error info
   - Handle all error cases

2. **Type Safety**
   - Use Sorbet signatures
   - Add RBS definitions
   - Enable type checking

3. **Async Usage**
   - Use Fibers for concurrency
   - Handle thread safety
   - Manage resources

4. **Testing**
   - Write unit tests
   - Add integration tests
   - Test error cases

## Contributing

1. Read [Contributing Guide](../../CONTRIBUTING.md)
2. Follow Ruby client guidelines
3. Add tests for new features
4. Update documentation
5. Submit PR for review
# BAML Python Client

> **⚠️ IMPORTANT NOTE**
>
> This document was initially generated by an AI assistant and should be taken with a grain of salt. While it provides a good starting point, some information might be inaccurate or outdated. We encourage contributors to manually update this document and remove this note once the content has been verified and corrected by the team.
>
> If you find any inaccuracies or have improvements to suggest, please feel free to submit a PR updating this guide.

Native Python bindings for BAML, providing type-safe LLM function calls with full Python type hints and runtime type checking.

## Features

- Native Python bindings via PyO3
- Full Python type hints
- Async support with asyncio
- Streaming responses
- Error handling with type safety
- Python 3.8+ support

## Installation

```bash
# Using pip
pip install baml-py

# Using poetry
poetry add baml-py

# Development installation
pip install -e .
pip install -r requirements-dev.txt
```

## Usage

### Basic Example
```python
from baml import Baml
from typing import TypedDict

class UserInfo(TypedDict):
    name: str
    age: int
    email: str

async def extract_user_info(text: str) -> UserInfo:
    # Call BAML function with type safety
    result = await Baml.extract_user_info(text)
    return result
```

### Streaming Example
```python
async def stream_response(text: str):
    async for chunk in Baml.streaming_function(text):
        print(f"Received chunk: {chunk}")
```

### Error Handling
```python
try:
    result = await Baml.my_function(text)
except Baml.ProviderError as e:
    print(f"Provider error: {e.message}, status: {e.status_code}")
except Baml.ValidationError as e:
    print(f"Validation error: {e.errors}")
except Baml.Error as e:
    print(f"BAML error: {e}")
```

## Development

### Prerequisites
- Python 3.8+
- Rust toolchain
- pip or poetry
- maturin

### Setup
```bash
# Install dependencies
pip install -r requirements-dev.txt

# Build native module
maturin develop

# Run tests
pytest
```

### Project Structure
```
language_client_python/
├── src/
│   ├── lib.rs         # PyO3 bindings
│   ├── types.rs       # Type conversions
│   └── async.rs       # Asyncio support
├── baml/
│   ├── __init__.py    # Python wrapper
│   ├── types.py       # Type definitions
│   └── client.py      # Client implementation
├── tests/            # Test suite
└── pyproject.toml    # Build configuration
```

## Adding Features

### 1. New Type Definition

1. Add Python type:
```python
from typing import TypedDict, Optional, List

class NewType(TypedDict):
    field: str
    optional_field: Optional[int]
    array_field: List[str]
```

2. Add Rust binding:
```rust
#[derive(Debug)]
pub struct NewType {
    pub field: String,
    pub optional_field: Option<i32>,
    pub array_field: Vec<String>,
}

impl IntoPy<PyObject> for NewType {
    fn into_py(self, py: Python) -> PyObject {
        let dict = PyDict::new(py);
        dict.set_item("field", self.field).unwrap();
        dict.set_item("optional_field", self.optional_field).unwrap();
        dict.set_item("array_field", self.array_field).unwrap();
        dict.into()
    }
}
```

### 2. New Function

1. Add function binding:
```rust
#[pyfunction]
pub fn baml_my_function(
    py: Python,
    input: String,
) -> PyResult<PyObject> {
    // Implementation
}
```

2. Add Python wrapper:
```python
from typing import TypeVar, Generic

T = TypeVar('T')

class Baml:
    @staticmethod
    async def my_function(input: str) -> NewType:
        result = await _native.baml_my_function(input)
        return result
```

## Testing

### Unit Tests
```python
import pytest
from baml import Baml

def test_function():
    result = Baml.test_function("input")
    assert result["field"] == "expected"
```

### Integration Tests
```python
@pytest.mark.asyncio
async def test_provider_integration():
    result = await Baml.provider_test("input")
    assert result["valid"] is True
```

## Error Handling

```python
class BamlError(Exception):
    """Base class for BAML errors."""
    pass

class ProviderError(BamlError):
    """Error from LLM provider."""
    def __init__(self, message: str, status_code: int):
        super().__init__(message)
        self.status_code = status_code

class ValidationError(BamlError):
    """Error from validation."""
    def __init__(self, errors: List[str]):
        super().__init__("Validation failed")
        self.errors = errors
```

## Performance

### Async/Await
```python
async def process_batch(inputs: List[str]) -> List[T]:
    tasks = [
        Baml.function(input)
        for input in inputs
    ]
    return await asyncio.gather(*tasks)
```

### Streaming
```python
async def stream_with_buffer(
    text: str,
    buffer_size: int = 1000
) -> None:
    buffer: List[str] = []
    async for chunk in Baml.streaming_function(text):
        buffer.append(chunk)
        if len(buffer) >= buffer_size:
            await process_buffer(buffer)
            buffer.clear()

    if buffer:
        await process_buffer(buffer)
```

## Type Safety

### Type Definitions
```python
from typing import TypedDict, Optional, Dict, Union, Literal

class UserProfile(TypedDict):
    name: str
    age: int
    email: str
    preferences: Dict[str, Union[str, bool]]

class UserResponse(TypedDict):
    profile: UserProfile
    status: Literal["active", "inactive"]
    last_login: Optional[datetime]

class BamlOptions(TypedDict, total=False):
    timeout: Optional[int]
    retries: Optional[int]
    headers: Optional[Dict[str, str]]
```

### Runtime Type Checking
```python
from typing import runtime_checkable, Protocol

@runtime_checkable
class HasField(Protocol):
    field: str

def process_type(obj: HasField) -> str:
    return obj.field.upper()
```

## Best Practices

1. **Error Handling**
   - Use custom error classes
   - Provide detailed error info
   - Handle all error cases

2. **Type Safety**
   - Use type hints
   - Enable runtime checking
   - Document type constraints

3. **Async Usage**
   - Use asyncio
   - Handle task cancellation
   - Manage concurrency

4. **Testing**
   - Write unit tests
   - Add integration tests
   - Test error cases

## Contributing

1. Read [Contributing Guide](../../CONTRIBUTING.md)
2. Follow Python client guidelines
3. Add tests for new features
4. Update documentation
5. Submit PR for review

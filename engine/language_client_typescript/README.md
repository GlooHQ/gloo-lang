# BAML TypeScript Client

> **⚠️ IMPORTANT NOTE**
>
> This document was initially generated by an AI assistant and should be taken with a grain of salt. While it provides a good starting point, some information might be inaccurate or outdated. We encourage contributors to manually update this document and remove this note once the content has been verified and corrected by the team.
>
> If you find any inaccuracies or have improvements to suggest, please feel free to submit a PR updating this guide.

Native TypeScript bindings for BAML, providing type-safe LLM function calls with full TypeScript type checking.

## Features

- Native Node.js bindings via N-API
- Full TypeScript type definitions
- Promise-based async support
- Streaming responses
- Error handling with type safety
- ESM and CommonJS support

## Installation

```bash
# Using npm
npm install @baml/client

# Using yarn
yarn add @baml/client

# Using pnpm
pnpm add @baml/client

# Development installation
npm install
npm run build
```

## Usage

### Basic Example
```typescript
import { Baml } from '@baml/client';

interface UserInfo {
  name: string;
  age: number;
  email: string;
}

async function extractUserInfo(text: string): Promise<UserInfo> {
  // Call BAML function with type safety
  const result = await Baml.extractUserInfo(text);
  return result;
}
```

### Streaming Example
```typescript
async function streamResponse(text: string) {
  const stream = await Baml.streamingFunction(text);

  for await (const chunk of stream) {
    console.log('Received chunk:', chunk);
  }
}
```

### Error Handling
```typescript
try {
  const result = await Baml.myFunction(text);
} catch (error) {
  if (error instanceof Baml.ProviderError) {
    console.error('Provider error:', error.message, error.statusCode);
  } else if (error instanceof Baml.ValidationError) {
    console.error('Validation error:', error.errors);
  } else if (error instanceof Baml.Error) {
    console.error('BAML error:', error);
  }
}
```

## Development

### Prerequisites
- Node.js 16+
- Rust toolchain
- npm or yarn
- node-gyp

### Setup
```bash
# Install dependencies
npm install

# Build native module
npm run build

# Run tests
npm test
```

### Project Structure
```
language_client_typescript/
├── src/
│   ├── lib.rs         # N-API bindings
│   ├── types.rs       # Type conversions
│   └── async.rs       # Promise support
├── lib/
│   ├── index.ts       # TypeScript wrapper
│   ├── types.ts       # Type definitions
│   └── client.ts      # Client implementation
├── test/             # Test suite
└── binding.gyp       # Build configuration
```

## Adding Features

### 1. New Type Definition

1. Add TypeScript interface:
```typescript
export interface NewType {
  field: string;
  optionalField?: number;
  arrayField: string[];
}
```

2. Add Rust binding:
```rust
#[derive(Debug)]
pub struct NewType {
    pub field: String,
    pub optional_field: Option<i32>,
    pub array_field: Vec<String>,
}

impl TryFrom<JsValue> for NewType {
    type Error = napi::Error;

    fn try_from(value: JsValue) -> Result<Self, Self::Error> {
        // Implementation
    }
}
```

### 2. New Function

1. Add function binding:
```rust
#[napi]
pub async fn baml_my_function(
    env: Env,
    input: String,
) -> Result<JsObject> {
    // Implementation
}
```

2. Add TypeScript wrapper:
```typescript
export class Baml {
  static async myFunction(input: string): Promise<NewType> {
    const result = await native.bamlMyFunction(input);
    return result as NewType;
  }
}
```

## Testing

### Unit Tests
```typescript
import { expect } from 'chai';
import { Baml } from '../lib';

describe('Baml', () => {
  it('should process function call', async () => {
    const result = await Baml.testFunction('input');
    expect(result.field).to.equal('expected');
  });
});
```

### Integration Tests
```typescript
describe('Provider Integration', () => {
  it('should handle provider calls', async () => {
    const result = await Baml.providerTest('input');
    expect(result.valid).to.be.true;
  });
});
```

## Error Handling

```typescript
export class BamlError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'BamlError';
  }
}

export class ProviderError extends BamlError {
  constructor(
    message: string,
    public statusCode: number
  ) {
    super(message);
    this.name = 'ProviderError';
  }
}

export class ValidationError extends BamlError {
  constructor(public errors: string[]) {
    super('Validation failed');
    this.name = 'ValidationError';
  }
}
```

## Performance

### Async/Await
```typescript
async function processBatch(inputs: string[]) {
  const promises = inputs.map(input =>
    Baml.function(input)
  );
  return Promise.all(promises);
}
```

### Streaming
```typescript
async function streamWithBuffer(
  text: string,
  bufferSize = 1000
): Promise<void> {
  const stream = await Baml.streamingFunction(text);
  const buffer: string[] = [];

  for await (const chunk of stream) {
    buffer.push(chunk);
    if (buffer.length >= bufferSize) {
      await processBuffer(buffer);
      buffer.length = 0;
    }
  }

  if (buffer.length > 0) {
    await processBuffer(buffer);
  }
}
```

## Type Safety

### Type Definitions
```typescript
export interface UserProfile {
  name: string;
  age: number;
  email: string;
  preferences: {
    [key: string]: string | boolean;
  };
}

export type UserResponse = {
  profile: UserProfile;
  status: 'active' | 'inactive';
  lastLogin?: Date;
};

export interface BamlOptions {
  timeout?: number;
  retries?: number;
  headers?: Record<string, string>;
}
```

## Best Practices

1. **Error Handling**
   - Use custom error classes
   - Provide detailed error info
   - Handle all error cases

2. **Type Safety**
   - Use strict TypeScript
   - Enable all type checks
   - Document type constraints

3. **Async Usage**
   - Use async/await
   - Handle Promise rejections
   - Manage concurrency

4. **Testing**
   - Write unit tests
   - Add integration tests
   - Test error cases

## Contributing

1. Read [Contributing Guide](../../CONTRIBUTING.md)
2. Follow TypeScript client guidelines
3. Add tests for new features
4. Update documentation
5. Submit PR for review

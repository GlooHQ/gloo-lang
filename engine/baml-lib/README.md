# BAML Library

> **⚠️ IMPORTANT NOTE**
>
> This document was initially generated by an AI assistant and should be taken with a grain of salt. While it provides a good starting point, some information might be inaccurate or outdated. We encourage contributors to manually update this document and remove this note once the content has been verified and corrected by the team.
>
> If you find any inaccuracies or have improvements to suggest, please feel free to submit a PR updating this guide.

The BAML Library is the core library for parsing, analyzing, and transforming BAML source code. It provides the foundation for the BAML compiler and language services.

## Features

- BAML parser and lexer
- Type system
- AST manipulation
- Code analysis
- Semantic validation
- Error diagnostics
- Language services

## Architecture

### Components

```
baml-lib/
├── src/
│   ├── parser/           # BAML parser implementation
│   │   ├── lexer.rs      # Lexical analysis
│   │   ├── grammar.rs    # Grammar definition
│   │   └── ast.rs        # Abstract Syntax Tree
│   ├── types/            # Type system
│   │   ├── checker.rs    # Type checking
│   │   ├── inference.rs  # Type inference
│   │   └── validation.rs # Type validation
│   ├── analysis/         # Code analysis
│   │   ├── semantics.rs  # Semantic analysis
│   │   └── linting.rs    # Linting rules
│   └── services/         # Language services
├── tests/                # Test suite
└── examples/             # Example usage
```

### Core Concepts

1. **Parser**
   - Lexical analysis
   - Syntax parsing
   - AST construction

2. **Type System**
   - Type checking
   - Type inference
   - Validation rules

3. **Analysis**
   - Semantic analysis
   - Code validation
   - Error reporting

## Usage

### Basic Example

```rust
use baml_lib::{Parser, TypeChecker, Analyzer};

fn main() -> Result<(), Box<dyn Error>> {
    // Parse BAML source
    let source = r#"
        class User {
            name: string;
            age: int;
        }
    "#;

    let ast = Parser::new().parse(source)?;

    // Type check
    let checker = TypeChecker::new();
    checker.check(&ast)?;

    // Analyze
    let analyzer = Analyzer::new();
    let diagnostics = analyzer.analyze(&ast)?;

    println!("Diagnostics: {:?}", diagnostics);
    Ok(())
}
```

### AST Manipulation

```rust
use baml_lib::ast::{Node, Visitor};

struct MyVisitor;

impl Visitor for MyVisitor {
    fn visit_class(&mut self, class: &mut Class) {
        // Manipulate class node
        println!("Visiting class: {}", class.name);

        // Visit children
        for field in &mut class.fields {
            self.visit_field(field);
        }
    }
}

let mut visitor = MyVisitor;
ast.accept(&mut visitor);
```

## Development

### Prerequisites

- Rust toolchain
- LLVM development libraries
- Testing utilities

### Setup

```bash
# Install dependencies
cargo build

# Run tests
cargo test

# Run examples
cargo run --example parser
```

## Adding Features

### 1. New Syntax Feature

1. Update grammar:
```rust
// src/parser/grammar.rs

pub enum Node {
    // Add new node type
    NewFeature(NewFeatureNode),
}

pub struct NewFeatureNode {
    pub keyword: Token,
    pub name: Identifier,
    pub body: Block,
}
```

2. Add parser implementation:
```rust
// src/parser/parser.rs

impl Parser {
    fn parse_new_feature(&mut self) -> Result<NewFeatureNode> {
        self.expect(TokenKind::NewFeature)?;
        let name = self.parse_identifier()?;
        let body = self.parse_block()?;

        Ok(NewFeatureNode {
            keyword: self.previous(),
            name,
            body,
        })
    }
}
```

### 2. New Type Feature

1. Add type definition:
```rust
// src/types/types.rs

#[derive(Debug, Clone)]
pub enum Type {
    NewType(NewTypeInfo),
}

pub struct NewTypeInfo {
    pub name: String,
    pub constraints: Vec<Constraint>,
}
```

2. Implement type checking:
```rust
// src/types/checker.rs

impl TypeChecker {
    fn check_new_type(&mut self, node: &NewTypeNode) -> Result<Type> {
        let constraints = self.check_constraints(&node.constraints)?;
        Ok(Type::NewType(NewTypeInfo {
            name: node.name.to_string(),
            constraints,
        }))
    }
}
```

## Testing

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parser() {
        let source = r#"
            class Test {
                field: string;
            }
        "#;

        let ast = Parser::new().parse(source).unwrap();
        assert_eq!(ast.classes.len(), 1);
    }
}
```

### Integration Tests

```rust
#[test]
fn test_full_pipeline() {
    let source = read_test_file("test.baml");
    let ast = Parser::new().parse(&source).unwrap();
    let checker = TypeChecker::new();
    checker.check(&ast).unwrap();
    let analyzer = Analyzer::new();
    let diagnostics = analyzer.analyze(&ast).unwrap();
    assert!(diagnostics.is_empty());
}
```

## Error Handling

```rust
#[derive(Debug, Error)]
pub enum LibError {
    #[error("Parse error: {0}")]
    Parse(String),

    #[error("Type error: {0}")]
    Type(String),

    #[error("Analysis error: {0}")]
    Analysis(String),
}

impl Diagnostic for LibError {
    fn message(&self) -> String {
        match self {
            LibError::Parse(msg) => format!("Parse error: {}", msg),
            LibError::Type(msg) => format!("Type error: {}", msg),
            LibError::Analysis(msg) => format!("Analysis error: {}", msg),
        }
    }
}
```

## Language Services

### Code Completion

```rust
use baml_lib::services::completion::{CompletionProvider, Suggestion};

impl CompletionProvider {
    pub fn get_suggestions(
        &self,
        source: &str,
        position: Position,
    ) -> Vec<Suggestion> {
        let ast = self.parser.parse(source).unwrap();
        let node = ast.node_at(position);
        self.suggest_completions(node)
    }
}
```

### Diagnostics

```rust
use baml_lib::services::diagnostics::{DiagnosticProvider, Diagnostic};

impl DiagnosticProvider {
    pub fn get_diagnostics(&self, source: &str) -> Vec<Diagnostic> {
        let ast = self.parser.parse(source).unwrap();
        let mut diagnostics = Vec::new();

        // Collect syntax errors
        diagnostics.extend(ast.errors());

        // Collect type errors
        let checker = TypeChecker::new();
        if let Err(e) = checker.check(&ast) {
            diagnostics.push(e.into());
        }

        diagnostics
    }
}
```

## Best Practices

1. **Parser Design**
   - Handle all edge cases
   - Provide clear errors
   - Support recovery

2. **Type System**
   - Strict type checking
   - Clear validation rules
   - Helpful error messages

3. **Analysis**
   - Efficient algorithms
   - Useful diagnostics
   - Performance optimization

4. **Testing**
   - Unit test coverage
   - Integration tests
   - Benchmark tests

## Contributing

1. Read [Contributing Guide](../../CONTRIBUTING.md)
2. Follow library guidelines
3. Add tests for new features
4. Update documentation
5. Submit PR for review
# BAML Template System

> **⚠️ IMPORTANT NOTE**
>
> This document was initially generated by an AI assistant and should be taken with a grain of salt. While it provides a good starting point, some information might be inaccurate or outdated. We encourage contributors to manually update this document and remove this note once the content has been verified and corrected by the team.
>
> If you find any inaccuracies or have improvements to suggest, please feel free to submit a PR updating this guide.

The template system manages prompt templates with variable interpolation, filters, and macros. It uses a Jinja-like syntax for powerful and flexible prompt engineering.

## Core Components

### Template Parser
```rust
pub struct TemplateParser {
    pub variables: HashSet<String>,    // Template variables
    pub filters: HashSet<String>,      // Custom filters
    pub macros: HashMap<String, Macro>, // Reusable snippets
}
```

### Context Management
```rust
pub struct Context {
    pub variables: HashMap<String, Value>,
    pub filters: HashMap<String, Box<dyn Filter>>,
    pub macros: HashMap<String, Macro>,
    pub env: Environment,
}
```

## Features

### Variable Interpolation
```baml
function ExtractInfo(name: string, age: int) -> PersonInfo {
  prompt #"
    Extract information about {{ name }}, who is {{ age }} years old.
    {{ ctx.output_format }}
  "#
}
```

### Control Flow
```baml
function GenerateResponse(items: string[]) -> string {
  prompt #"
    {% for item in items %}
    - {{ item }}
    {% endfor %}

    {% if items | length > 3 %}
    That's quite a list!
    {% endif %}
  "#
}
```

### Custom Filters
```baml
function FormatText(text: string) -> string {
  prompt #"
    {{ text | lowercase | trim }}

    {% if text | word_count > 100 %}
    That's a long text!
    {% endif %}
  "#
}
```

### Macros
```baml
function ComplexPrompt() -> string {
  prompt #"
    {% macro format_header(title) %}
    ===== {{ title | uppercase }} =====
    {% endmacro %}

    {{ format_header("Introduction") }}
    Content goes here...
  "#
}
```

## Development

### Adding a New Filter

1. Define the filter function:
```rust
pub struct CustomFilter;

impl Filter for CustomFilter {
    fn apply(&self, value: &Value, args: &[Value]) -> Result<Value> {
        // Filter implementation
    }
}
```

2. Register the filter:
```rust
impl Context {
    pub fn register_filter(&mut self, name: &str, filter: Box<dyn Filter>) {
        self.filters.insert(name.to_string(), filter);
    }
}
```

### Adding a New Macro

1. Define the macro:
```rust
pub struct Macro {
    pub name: String,
    pub params: Vec<String>,
    pub body: Template,
}
```

2. Register the macro:
```rust
impl Context {
    pub fn register_macro(&mut self, macro_def: Macro) {
        self.macros.insert(macro_def.name.clone(), macro_def);
    }
}
```

## Testing

```bash
# Run all template tests
cargo test -p prompt-parser

# Run specific test suites
cargo test -p prompt-parser parser
cargo test -p prompt-parser filters
```

## Examples

### Basic Template
```baml
function Greet(name: string) -> string {
  prompt #"
    Hello, {{ name }}!
    The current time is {{ ctx.now | date_format("%Y-%m-%d") }}.
  "#
}
```

### Complex Logic
```baml
function AnalyzeData(data: Map<string, float>) -> Analysis {
  prompt #"
    {% for key, value in data.items() %}
      {% if value > 100 %}
        {{ key }} is significantly high at {{ value }}.
      {% elif value < 0 %}
        {{ key }} is negative at {{ value }}.
      {% else %}
        {{ key }} is within normal range at {{ value }}.
      {% endif %}
    {% endfor %}

    {{ ctx.output_format }}
  "#
}
```

### Environment Variables
```baml
function SecurePrompt() -> string {
  prompt #"
    Using API key: {{ env.API_KEY | mask }}
    Environment: {{ env.ENV_NAME | default("development") }}
  "#
}
```

### Error Handling
```rust
impl Template {
    pub fn render(&self, context: &Context) -> Result<String> {
        match self.evaluate(context) {
            Ok(result) => Ok(result),
            Err(e) => {
                // Add source location information
                let diagnostic = Diagnostic::new(Level::Error)
                    .with_message(format!("Template error: {}", e))
                    .with_span(self.span);
                Err(diagnostic.into())
            }
        }
    }
}
```

## Best Practices

1. **Variable Naming**
   - Use descriptive names
   - Follow snake_case convention
   - Prefix temporary variables with underscore

2. **Error Messages**
   - Include line numbers
   - Provide context about the error
   - Suggest possible fixes

3. **Performance**
   - Cache compiled templates
   - Minimize string allocations
   - Use lazy evaluation when possible

4. **Security**
   - Sanitize user input
   - Use environment variables for sensitive data
   - Implement proper escaping
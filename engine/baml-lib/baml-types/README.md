# BAML Type System

> **⚠️ IMPORTANT NOTE**
>
> This document was initially generated by an AI assistant and should be taken with a grain of salt. While it provides a good starting point, some information might be inaccurate or outdated. We encourage contributors to manually update this document and remove this note once the content has been verified and corrected by the team.
>
> If you find any inaccuracies or have improvements to suggest, please feel free to submit a PR updating this guide.

The type system is responsible for ensuring that LLM outputs match your expected types and schemas. It provides rich type checking, validation, and runtime value representation.

## Type Hierarchy

```rust
pub enum FieldType {
    Primitive(TypeValue),      // string, int, float, bool
    Enum(String),             // Named enums with variants
    Class(String),            // Structured data types
    List(Box<FieldType>),     // Arrays
    Map(Box<FieldType>, Box<FieldType>), // Key-value maps
    Union(Vec<FieldType>),    // Type alternatives
    Optional(Box<FieldType>), // Nullable types
}
```

## Runtime Values

```rust
pub enum BamlValue {
    String(String),
    Int(i64),
    Float(f64),
    Bool(bool),
    Map(BamlMap<String, BamlValue>),  // Structured data
    List(Vec<BamlValue>),             // Arrays
    Media(BamlMedia),                 // Images/Audio
    Enum(String, String),             // Enum variants
    Class(String, BamlMap<String, BamlValue>), // Class instances
    Null,
}
```

## Media Types

```rust
pub struct BamlMedia {
    pub media_type: BamlMediaType,    // Image or Audio
    pub mime_type: Option<String>,    // e.g., "image/png"
    pub content: BamlMediaContent,    // File, URL, or Base64
}
```

## Development

### Adding a New Type

1. Add variant to `FieldType` enum in `field_type/mod.rs`
2. Implement type checking and validation:
   ```rust
   impl FieldType {
       pub fn validate(&self, value: &BamlValue) -> Result<()> {
           match (self, value) {
               // Type-specific validation rules
           }
       }
   }
   ```
3. Add runtime value support in `BamlValue`
4. Update serialization/deserialization
5. Add test cases in `tests/`

### Testing

```bash
# Run all type system tests
cd ./engine

cargo test -p baml-types

# Run specific test suite
cargo test -p baml-types field_type
cargo test -p baml-types baml_value
```

## Error Handling

Rich error reporting with source locations:

```rust
use baml_diagnostics::{Diagnostic, Level};

fn report_error(span: Span, message: &str) {
    let diagnostic = Diagnostic::new(Level::Error)
        .with_message(message)
        .with_span(span)
        .with_code("E001");
    // Report error with source context
}
```

## Examples

### Basic Types
```baml
class User {
    name string
    age int
    isActive bool
    score float
}
```

### Enums
```baml
enum Sentiment {
    POSITIVE
    NEGATIVE
    NEUTRAL
}
```

### Complex Types
```baml
class Document {
    title string
    metadata Map<string, string>
    tags string[]
    sentiment Sentiment
    author User | null
}
```

## Integration with Language Clients

The type system automatically generates appropriate type definitions for each supported language:

### Python (Pydantic)
```python
class User(BaseModel):
    name: str
    age: int
    is_active: bool
    score: float
```

### TypeScript
```typescript
interface User {
    name: string;
    age: number;
    isActive: boolean;
    score: number;
}
```

### Ruby (Sorbet)
```ruby
class User < T::Struct
  const :name, String
  const :age, Integer
  const :is_active, T::Boolean
  const :score, Float
end
```
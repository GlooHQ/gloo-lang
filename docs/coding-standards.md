# BAML Coding Standards

> **⚠️ IMPORTANT NOTE**
>
> This document was initially generated by an AI assistant and should be taken with a grain of salt. While it provides a good starting point, some information might be inaccurate or outdated. We encourage contributors to manually update this document and remove this note once the content has been verified and corrected by the team.
>
> If you find any inaccuracies or have improvements to suggest, please feel free to submit a PR updating this guide.

This document outlines the coding standards and best practices for the BAML project across all languages and components.

## Table of Contents

1. [General Guidelines](#general-guidelines)
2. [Rust Standards](#rust-standards)
3. [TypeScript Standards](#typescript-standards)
4. [Python Standards](#python-standards)
5. [Ruby Standards](#ruby-standards)
6. [BAML Language Standards](#baml-language-standards)
7. [Documentation Standards](#documentation-standards)
8. [Testing Standards](#testing-standards)

## General Guidelines

### Code Organization

1. **File Structure**
   - One primary concern per file
   - Logical grouping of related files
   - Clear separation of public/private interfaces

2. **Naming Conventions**
   - Clear, descriptive names
   - Consistent casing per language
   - Avoid abbreviations unless common

3. **Comments**
   - Explain why, not what
   - Keep comments up to date
   - Document public interfaces

### Version Control

1. **Commit Messages**
   ```
   <type>(<scope>): <subject>

   <body>

   <footer>
   ```
   - Types: feat, fix, docs, style, refactor, test, chore
   - Scope: component affected (e.g., parser, runtime)
   - Subject: concise description
   - Body: detailed explanation
   - Footer: breaking changes, issue references

2. **Branch Naming**
   ```
   <type>/<description>
   ```
   - feature/add-new-provider
   - fix/type-inference-bug
   - docs/update-readme

3. **Pull Requests**
   - Clear title and description
   - Link related issues
   - Include test coverage
   - Update documentation

## Rust Standards

### Code Style

1. **Formatting**
   ```rust
   // Use rustfmt with project settings
   cargo fmt

   // Run clippy
   cargo clippy
   ```

2. **Naming**
   ```rust
   // Types are PascalCase
   pub struct UserProfile {
       // Fields are snake_case
       first_name: String,
       last_name: String,
   }

   // Functions are snake_case
   pub fn process_user(user: &UserProfile) -> Result<(), Error> {
       // Local variables are snake_case
       let full_name = format!("{} {}", user.first_name, user.last_name);
   }
   ```

3. **Error Handling**
   ```rust
   // Use custom error types
   #[derive(Debug, Error)]
   pub enum BamlError {
       #[error("Parser error: {0}")]
       Parser(String),

       #[error("Runtime error: {0}")]
       Runtime(String),
   }

   // Return Result for fallible operations
   fn parse_file(path: &Path) -> Result<Ast, BamlError> {
       // Use ? operator for error propagation
       let content = fs::read_to_string(path)
           .map_err(|e| BamlError::Parser(e.to_string()))?;
       // ...
   }
   ```

### Project Structure

```rust
// Organize modules hierarchically
pub mod parser {
    pub mod lexer;
    pub mod ast;
    pub mod error;
}

// Use feature flags for optional functionality
#[cfg(feature = "debug")]
pub mod debug {
    // Debug-only code
}
```

## TypeScript Standards

### Code Style

1. **Formatting**
   ```typescript
   // Use prettier with project settings
   npm run format

   // Run ESLint
   npm run lint
   ```

2. **Type Safety**
   ```typescript
   // Use explicit types
   interface UserProfile {
     name: string;
     age: number;
     email: string;
   }

   // Avoid any
   function processUser(user: UserProfile): void {
     // Type-safe code
   }
   ```

3. **Async Code**
   ```typescript
   // Use async/await
   async function fetchUser(id: string): Promise<User> {
     try {
       const response = await api.get(`/users/${id}`);
       return response.data;
     } catch (error) {
       throw new ApiError('Failed to fetch user', error);
     }
   }
   ```

## Python Standards

### Code Style

1. **Formatting**
   ```python
   # Use black for formatting
   black .

   # Use isort for imports
   isort .
   ```

2. **Type Hints**
   ```python
   from typing import Optional, List, Dict

   class UserProfile:
       def __init__(self, name: str, age: int) -> None:
           self.name = name
           self.age = age

       def process(self) -> Optional[Dict[str, str]]:
           # Type-safe code
           pass
   ```

3. **Documentation**
   ```python
   def process_user(user: UserProfile) -> None:
       """
       Process user profile and update database.

       Args:
           user: UserProfile object containing user data

       Raises:
           ValueError: If user profile is invalid
           DatabaseError: If database update fails
       """
       pass
   ```

## Ruby Standards

### Code Style

1. **Formatting**
   ```ruby
   # Use RuboCop with project settings
   bundle exec rubocop

   # Use Sorbet for type checking
   bundle exec srb tc
   ```

2. **Type Safety**
   ```ruby
   # Use Sorbet type signatures
   class UserProfile
     extend T::Sig

     sig { params(name: String, age: Integer).void }
     def initialize(name, age)
       @name = name
       @age = age
     end

     sig { returns(String) }
     def full_name
       @name
     end
   end
   ```

3. **Error Handling**
   ```ruby
   begin
     result = process_user(user)
   rescue ValidationError => e
     logger.error("Validation failed: #{e.message}")
     raise
   rescue StandardError => e
     logger.error("Unexpected error: #{e.message}")
     raise
   end
   ```

## BAML Language Standards

### File Organization

1. **Structure**
   ```baml
   // Group related types
   class User {
     name: string;
     email: string;
   }

   class UserProfile {
     user: User;
     preferences: Preferences;
   }

   // Group related functions
   function ExtractUserInfo {
     // ...
   }
   ```

2. **Naming**
   ```baml
   // Classes are PascalCase
   class OrderDetails {
     // Properties are camelCase
     orderId: string;
     totalAmount: float;
   }

   // Functions are PascalCase
   function ProcessOrder {
     // ...
   }
   ```

### Documentation

```baml
// Use clear comments for complex logic
function ExtractOrderInfo {
  // This function extracts order information from
  // unstructured text using pattern matching
  input: string;
  output: OrderDetails;
}
```

## Documentation Standards

1. **README Files**
   - Clear project description
   - Setup instructions
   - Usage examples
   - Contributing guidelines

2. **Code Documentation**
   - Document public interfaces
   - Explain complex algorithms
   - Include usage examples
   - Note performance implications

3. **API Documentation**
   - Clear parameter descriptions
   - Return value documentation
   - Error scenarios
   - Usage examples

## Testing Standards

1. **Unit Tests**
   - Test one thing at a time
   - Clear test names
   - Arrange-Act-Assert pattern
   - Mock external dependencies

2. **Integration Tests**
   - Test real integrations
   - Cover error scenarios
   - Test performance
   - Clean up resources

3. **Test Coverage**
   - Aim for high coverage
   - Focus on critical paths
   - Include edge cases
   - Test error handling

## Best Practices

1. **Code Quality**
   - Run linters before commit
   - Address all warnings
   - Follow language idioms
   - Keep functions focused

2. **Performance**
   - Profile before optimizing
   - Use appropriate data structures
   - Handle resources properly
   - Consider memory usage

3. **Security**
   - Validate all inputs
   - Handle secrets properly
   - Follow security guidelines
   - Regular dependency updates

4. **Maintainability**
   - Keep code simple
   - Write clear documentation
   - Follow SOLID principles
   - Regular refactoring
/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use client'

import { useState } from 'react';
import type { BamlStream } from '@boundaryml/baml';
interface AaaSamOutputFormatHookResult {
    data: Recipe | null
    partialData: Recipe | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        recipe: string
    }) => Promise<Recipe | undefined>
}

export function useAaaSamOutputFormatAction(): AaaSamOutputFormatHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Recipe | null>(null)
    const [data, setData] = useState<Recipe | null>(null)

    const mutate = async (params: {
        recipe: string
    }): Promise<Recipe | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AaaSamOutputFormat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AliasThatPointsToRecursiveTypeHookResult {
    data: LinkedListAliasNode | null
    partialData: LinkedListAliasNode | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        list: LinkedListAliasNode
    }) => Promise<LinkedListAliasNode | undefined>
}

export function useAliasThatPointsToRecursiveTypeAction(): AliasThatPointsToRecursiveTypeHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<LinkedListAliasNode | null>(null)
    const [data, setData] = useState<LinkedListAliasNode | null>(null)

    const mutate = async (params: {
        list: LinkedListAliasNode
    }): Promise<LinkedListAliasNode | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AliasThatPointsToRecursiveType', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AliasWithMultipleAttrsHookResult {
    data: Checked<number,"gt_ten"> | null
    partialData: Checked<number,"gt_ten"> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        money: Checked<number,"gt_ten">
    }) => Promise<Checked<number,"gt_ten"> | undefined>
}

export function useAliasWithMultipleAttrsAction(): AliasWithMultipleAttrsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Checked<number,"gt_ten"> | null>(null)
    const [data, setData] = useState<Checked<number,"gt_ten"> | null>(null)

    const mutate = async (params: {
        money: Checked<number,"gt_ten">
    }): Promise<Checked<number,"gt_ten"> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AliasWithMultipleAttrs', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AliasedInputClassHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: InputClass
    }) => Promise<string | undefined>
}

export function useAliasedInputClassAction(): AliasedInputClassHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: InputClass
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AliasedInputClass', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AliasedInputClass2HookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: InputClass
    }) => Promise<string | undefined>
}

export function useAliasedInputClass2Action(): AliasedInputClass2HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: InputClass
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AliasedInputClass2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AliasedInputClassNestedHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: InputClassNested
    }) => Promise<string | undefined>
}

export function useAliasedInputClassNestedAction(): AliasedInputClassNestedHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: InputClassNested
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AliasedInputClassNested', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AliasedInputEnumHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: AliasedEnum
    }) => Promise<string | undefined>
}

export function useAliasedInputEnumAction(): AliasedInputEnumHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: AliasedEnum
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AliasedInputEnum', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AliasedInputListHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: AliasedEnum[]
    }) => Promise<string | undefined>
}

export function useAliasedInputListAction(): AliasedInputListHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: AliasedEnum[]
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AliasedInputList', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AllowedOptionalsHookResult {
    data: OptionalListAndMap | null
    partialData: OptionalListAndMap | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        optionals: OptionalListAndMap
    }) => Promise<OptionalListAndMap | undefined>
}

export function useAllowedOptionalsAction(): AllowedOptionalsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<OptionalListAndMap | null>(null)
    const [data, setData] = useState<OptionalListAndMap | null>(null)

    const mutate = async (params: {
        optionals: OptionalListAndMap
    }): Promise<OptionalListAndMap | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AllowedOptionals', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface AudioInputHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        aud: Audio
    }) => Promise<string | undefined>
}

export function useAudioInputAction(): AudioInputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        aud: Audio
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/AudioInput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface BuildLinkedListHookResult {
    data: LinkedList | null
    partialData: LinkedList | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: number[]
    }) => Promise<LinkedList | undefined>
}

export function useBuildLinkedListAction(): BuildLinkedListHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<LinkedList | null>(null)
    const [data, setData] = useState<LinkedList | null>(null)

    const mutate = async (params: {
        input: number[]
    }): Promise<LinkedList | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/BuildLinkedList', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface BuildTreeHookResult {
    data: Tree | null
    partialData: Tree | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: BinaryNode
    }) => Promise<Tree | undefined>
}

export function useBuildTreeAction(): BuildTreeHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Tree | null>(null)
    const [data, setData] = useState<Tree | null>(null)

    const mutate = async (params: {
        input: BinaryNode
    }): Promise<Tree | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/BuildTree', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ClassThatPointsToRecursiveClassThroughAliasHookResult {
    data: ClassToRecAlias | null
    partialData: ClassToRecAlias | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        cls: ClassToRecAlias
    }) => Promise<ClassToRecAlias | undefined>
}

export function useClassThatPointsToRecursiveClassThroughAliasAction(): ClassThatPointsToRecursiveClassThroughAliasHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<ClassToRecAlias | null>(null)
    const [data, setData] = useState<ClassToRecAlias | null>(null)

    const mutate = async (params: {
        cls: ClassToRecAlias
    }): Promise<ClassToRecAlias | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ClassThatPointsToRecursiveClassThroughAlias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ClassifyDynEnumTwoHookResult {
    data: (string | DynEnumTwo) | null
    partialData: (string | DynEnumTwo) | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<(string | DynEnumTwo) | undefined>
}

export function useClassifyDynEnumTwoAction(): ClassifyDynEnumTwoHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<(string | DynEnumTwo) | null>(null)
    const [data, setData] = useState<(string | DynEnumTwo) | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<(string | DynEnumTwo) | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ClassifyDynEnumTwo', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ClassifyMessageHookResult {
    data: Category | null
    partialData: Category | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<Category | undefined>
}

export function useClassifyMessageAction(): ClassifyMessageHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Category | null>(null)
    const [data, setData] = useState<Category | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<Category | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ClassifyMessage', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ClassifyMessage2HookResult {
    data: Category | null
    partialData: Category | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<Category | undefined>
}

export function useClassifyMessage2Action(): ClassifyMessage2HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Category | null>(null)
    const [data, setData] = useState<Category | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<Category | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ClassifyMessage2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ClassifyMessage3HookResult {
    data: Category | null
    partialData: Category | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<Category | undefined>
}

export function useClassifyMessage3Action(): ClassifyMessage3HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Category | null>(null)
    const [data, setData] = useState<Category | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<Category | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ClassifyMessage3', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface CompletionHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        prefix: string,
        suffix: string,
        language: string
    }) => Promise<string | undefined>
}

export function useCompletionAction(): CompletionHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        prefix: string,
        suffix: string,
        language: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/Completion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface CustomTaskHookResult {
    data: BookOrder | FlightConfirmation | GroceryReceipt | null
    partialData: BookOrder | FlightConfirmation | GroceryReceipt | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<BookOrder | FlightConfirmation | GroceryReceipt | undefined>
}

export function useCustomTaskAction(): CustomTaskHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<BookOrder | FlightConfirmation | GroceryReceipt | null>(null)
    const [data, setData] = useState<BookOrder | FlightConfirmation | GroceryReceipt | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<BookOrder | FlightConfirmation | GroceryReceipt | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/CustomTask', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DescribeImageHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        img: Image
    }) => Promise<string | undefined>
}

export function useDescribeImageAction(): DescribeImageHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        img: Image
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DescribeImage', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DescribeImage2HookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        classWithImage: ClassWithImage,
        img2: Image
    }) => Promise<string | undefined>
}

export function useDescribeImage2Action(): DescribeImage2HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        classWithImage: ClassWithImage,
        img2: Image
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DescribeImage2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DescribeImage3HookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        classWithImage: ClassWithImage,
        img2: Image
    }) => Promise<string | undefined>
}

export function useDescribeImage3Action(): DescribeImage3HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        classWithImage: ClassWithImage,
        img2: Image
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DescribeImage3', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DescribeImage4HookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        classWithImage: ClassWithImage,
        img2: Image
    }) => Promise<string | undefined>
}

export function useDescribeImage4Action(): DescribeImage4HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        classWithImage: ClassWithImage,
        img2: Image
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DescribeImage4', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DifferentiateUnionsHookResult {
    data: OriginalA | OriginalB | null
    partialData: OriginalA | OriginalB | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<OriginalA | OriginalB | undefined>
}

export function useDifferentiateUnionsAction(): DifferentiateUnionsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<OriginalA | OriginalB | null>(null)
    const [data, setData] = useState<OriginalA | OriginalB | null>(null)

    const mutate = async (params: {
    }): Promise<OriginalA | OriginalB | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DifferentiateUnions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DummyOutputFunctionHookResult {
    data: DummyOutput | null
    partialData: DummyOutput | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<DummyOutput | undefined>
}

export function useDummyOutputFunctionAction(): DummyOutputFunctionHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<DummyOutput | null>(null)
    const [data, setData] = useState<DummyOutput | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<DummyOutput | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DummyOutputFunction', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DynamicFuncHookResult {
    data: DynamicClassTwo | null
    partialData: DynamicClassTwo | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: DynamicClassOne
    }) => Promise<DynamicClassTwo | undefined>
}

export function useDynamicFuncAction(): DynamicFuncHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<DynamicClassTwo | null>(null)
    const [data, setData] = useState<DynamicClassTwo | null>(null)

    const mutate = async (params: {
        input: DynamicClassOne
    }): Promise<DynamicClassTwo | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DynamicFunc', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DynamicInputOutputHookResult {
    data: DynInputOutput | null
    partialData: DynInputOutput | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: DynInputOutput
    }) => Promise<DynInputOutput | undefined>
}

export function useDynamicInputOutputAction(): DynamicInputOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<DynInputOutput | null>(null)
    const [data, setData] = useState<DynInputOutput | null>(null)

    const mutate = async (params: {
        input: DynInputOutput
    }): Promise<DynInputOutput | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DynamicInputOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface DynamicListInputOutputHookResult {
    data: DynInputOutput[] | null
    partialData: DynInputOutput[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: DynInputOutput[]
    }) => Promise<DynInputOutput[] | undefined>
}

export function useDynamicListInputOutputAction(): DynamicListInputOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<DynInputOutput[] | null>(null)
    const [data, setData] = useState<DynInputOutput[] | null>(null)

    const mutate = async (params: {
        input: DynInputOutput[]
    }): Promise<DynInputOutput[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/DynamicListInputOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExpectFailureHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<string | undefined>
}

export function useExpectFailureAction(): ExpectFailureHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExpectFailure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExtractContactInfoHookResult {
    data: ContactInfo | null
    partialData: ContactInfo | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        document: string
    }) => Promise<ContactInfo | undefined>
}

export function useExtractContactInfoAction(): ExtractContactInfoHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<ContactInfo | null>(null)
    const [data, setData] = useState<ContactInfo | null>(null)

    const mutate = async (params: {
        document: string
    }): Promise<ContactInfo | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExtractContactInfo', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExtractHobbyHookResult {
    data: (string | Hobby)[] | null
    partialData: (string | Hobby)[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        text: string
    }) => Promise<(string | Hobby)[] | undefined>
}

export function useExtractHobbyAction(): ExtractHobbyHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<(string | Hobby)[] | null>(null)
    const [data, setData] = useState<(string | Hobby)[] | null>(null)

    const mutate = async (params: {
        text: string
    }): Promise<(string | Hobby)[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExtractHobby', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExtractNamesHookResult {
    data: string[] | null
    partialData: string[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string[] | undefined>
}

export function useExtractNamesAction(): ExtractNamesHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string[] | null>(null)
    const [data, setData] = useState<string[] | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExtractNames', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExtractPeopleHookResult {
    data: Person[] | null
    partialData: Person[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        text: string
    }) => Promise<Person[] | undefined>
}

export function useExtractPeopleAction(): ExtractPeopleHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Person[] | null>(null)
    const [data, setData] = useState<Person[] | null>(null)

    const mutate = async (params: {
        text: string
    }): Promise<Person[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExtractPeople', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExtractReceiptInfoHookResult {
    data: ReceiptInfo | null
    partialData: ReceiptInfo | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        email: string,
        reason: "curiosity" | "personal_finance"
    }) => Promise<ReceiptInfo | undefined>
}

export function useExtractReceiptInfoAction(): ExtractReceiptInfoHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<ReceiptInfo | null>(null)
    const [data, setData] = useState<ReceiptInfo | null>(null)

    const mutate = async (params: {
        email: string,
        reason: "curiosity" | "personal_finance"
    }): Promise<ReceiptInfo | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExtractReceiptInfo', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExtractResumeHookResult {
    data: Resume | null
    partialData: Resume | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        resume: string,
        img?: Image | null
    }) => Promise<Resume | undefined>
}

export function useExtractResumeAction(): ExtractResumeHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Resume | null>(null)
    const [data, setData] = useState<Resume | null>(null)

    const mutate = async (params: {
        resume: string,
        img?: Image | null
    }): Promise<Resume | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExtractResume', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ExtractResume2HookResult {
    data: Resume | null
    partialData: Resume | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        resume: string
    }) => Promise<Resume | undefined>
}

export function useExtractResume2Action(): ExtractResume2HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Resume | null>(null)
    const [data, setData] = useState<Resume | null>(null)

    const mutate = async (params: {
        resume: string
    }): Promise<Resume | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ExtractResume2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnClassOptionalOutputHookResult {
    data: ClassOptionalOutput | null | null
    partialData: ClassOptionalOutput | null | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<ClassOptionalOutput | null | undefined>
}

export function useFnClassOptionalOutputAction(): FnClassOptionalOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<ClassOptionalOutput | null | null>(null)
    const [data, setData] = useState<ClassOptionalOutput | null | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<ClassOptionalOutput | null | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnClassOptionalOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnClassOptionalOutput2HookResult {
    data: ClassOptionalOutput2 | null | null
    partialData: ClassOptionalOutput2 | null | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<ClassOptionalOutput2 | null | undefined>
}

export function useFnClassOptionalOutput2Action(): FnClassOptionalOutput2HookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<ClassOptionalOutput2 | null | null>(null)
    const [data, setData] = useState<ClassOptionalOutput2 | null | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<ClassOptionalOutput2 | null | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnClassOptionalOutput2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnEnumListOutputHookResult {
    data: EnumOutput[] | null
    partialData: EnumOutput[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<EnumOutput[] | undefined>
}

export function useFnEnumListOutputAction(): FnEnumListOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<EnumOutput[] | null>(null)
    const [data, setData] = useState<EnumOutput[] | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<EnumOutput[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnEnumListOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnEnumOutputHookResult {
    data: EnumOutput | null
    partialData: EnumOutput | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<EnumOutput | undefined>
}

export function useFnEnumOutputAction(): FnEnumOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<EnumOutput | null>(null)
    const [data, setData] = useState<EnumOutput | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<EnumOutput | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnEnumOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnLiteralClassInputOutputHookResult {
    data: LiteralClassHello | null
    partialData: LiteralClassHello | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: LiteralClassHello
    }) => Promise<LiteralClassHello | undefined>
}

export function useFnLiteralClassInputOutputAction(): FnLiteralClassInputOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<LiteralClassHello | null>(null)
    const [data, setData] = useState<LiteralClassHello | null>(null)

    const mutate = async (params: {
        input: LiteralClassHello
    }): Promise<LiteralClassHello | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnLiteralClassInputOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnLiteralUnionClassInputOutputHookResult {
    data: LiteralClassOne | LiteralClassTwo | null
    partialData: LiteralClassOne | LiteralClassTwo | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: LiteralClassOne | LiteralClassTwo
    }) => Promise<LiteralClassOne | LiteralClassTwo | undefined>
}

export function useFnLiteralUnionClassInputOutputAction(): FnLiteralUnionClassInputOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<LiteralClassOne | LiteralClassTwo | null>(null)
    const [data, setData] = useState<LiteralClassOne | LiteralClassTwo | null>(null)

    const mutate = async (params: {
        input: LiteralClassOne | LiteralClassTwo
    }): Promise<LiteralClassOne | LiteralClassTwo | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnLiteralUnionClassInputOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnNamedArgsSingleStringOptionalHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myString?: string | null
    }) => Promise<string | undefined>
}

export function useFnNamedArgsSingleStringOptionalAction(): FnNamedArgsSingleStringOptionalHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myString?: string | null
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnNamedArgsSingleStringOptional', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputBoolHookResult {
    data: boolean | null
    partialData: boolean | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<boolean | undefined>
}

export function useFnOutputBoolAction(): FnOutputBoolHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<boolean | null>(null)
    const [data, setData] = useState<boolean | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<boolean | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputBool', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputClassHookResult {
    data: TestOutputClass | null
    partialData: TestOutputClass | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<TestOutputClass | undefined>
}

export function useFnOutputClassAction(): FnOutputClassHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<TestOutputClass | null>(null)
    const [data, setData] = useState<TestOutputClass | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<TestOutputClass | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputClass', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputClassListHookResult {
    data: TestOutputClass[] | null
    partialData: TestOutputClass[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<TestOutputClass[] | undefined>
}

export function useFnOutputClassListAction(): FnOutputClassListHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<TestOutputClass[] | null>(null)
    const [data, setData] = useState<TestOutputClass[] | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<TestOutputClass[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputClassList', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputClassNestedHookResult {
    data: TestClassNested | null
    partialData: TestClassNested | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<TestClassNested | undefined>
}

export function useFnOutputClassNestedAction(): FnOutputClassNestedHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<TestClassNested | null>(null)
    const [data, setData] = useState<TestClassNested | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<TestClassNested | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputClassNested', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputClassWithEnumHookResult {
    data: TestClassWithEnum | null
    partialData: TestClassWithEnum | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<TestClassWithEnum | undefined>
}

export function useFnOutputClassWithEnumAction(): FnOutputClassWithEnumHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<TestClassWithEnum | null>(null)
    const [data, setData] = useState<TestClassWithEnum | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<TestClassWithEnum | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputClassWithEnum', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputIntHookResult {
    data: number | null
    partialData: number | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<number | undefined>
}

export function useFnOutputIntAction(): FnOutputIntHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | null>(null)
    const [data, setData] = useState<number | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<number | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputInt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputLiteralBoolHookResult {
    data: false | null
    partialData: false | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<false | undefined>
}

export function useFnOutputLiteralBoolAction(): FnOutputLiteralBoolHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<false | null>(null)
    const [data, setData] = useState<false | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<false | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputLiteralBool', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputLiteralIntHookResult {
    data: 5 | null
    partialData: 5 | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<5 | undefined>
}

export function useFnOutputLiteralIntAction(): FnOutputLiteralIntHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<5 | null>(null)
    const [data, setData] = useState<5 | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<5 | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputLiteralInt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputLiteralStringHookResult {
    data: "example output" | null
    partialData: "example output" | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<"example output" | undefined>
}

export function useFnOutputLiteralStringAction(): FnOutputLiteralStringHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<"example output" | null>(null)
    const [data, setData] = useState<"example output" | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<"example output" | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputLiteralString', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnOutputStringListHookResult {
    data: string[] | null
    partialData: string[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string[] | undefined>
}

export function useFnOutputStringListAction(): FnOutputStringListHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string[] | null>(null)
    const [data, setData] = useState<string[] | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnOutputStringList', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnTestAliasedEnumOutputHookResult {
    data: TestEnum | null
    partialData: TestEnum | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<TestEnum | undefined>
}

export function useFnTestAliasedEnumOutputAction(): FnTestAliasedEnumOutputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<TestEnum | null>(null)
    const [data, setData] = useState<TestEnum | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<TestEnum | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnTestAliasedEnumOutput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnTestClassAliasHookResult {
    data: TestClassAlias | null
    partialData: TestClassAlias | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<TestClassAlias | undefined>
}

export function useFnTestClassAliasAction(): FnTestClassAliasHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<TestClassAlias | null>(null)
    const [data, setData] = useState<TestClassAlias | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<TestClassAlias | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnTestClassAlias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface FnTestNamedArgsSingleEnumHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myArg: NamedArgsSingleEnum
    }) => Promise<string | undefined>
}

export function useFnTestNamedArgsSingleEnumAction(): FnTestNamedArgsSingleEnumHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myArg: NamedArgsSingleEnum
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/FnTestNamedArgsSingleEnum', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface GetDataTypeHookResult {
    data: RaysData | null
    partialData: RaysData | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        text: string
    }) => Promise<RaysData | undefined>
}

export function useGetDataTypeAction(): GetDataTypeHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<RaysData | null>(null)
    const [data, setData] = useState<RaysData | null>(null)

    const mutate = async (params: {
        text: string
    }): Promise<RaysData | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/GetDataType', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface GetOrderInfoHookResult {
    data: OrderInfo | null
    partialData: OrderInfo | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        email: Email
    }) => Promise<OrderInfo | undefined>
}

export function useGetOrderInfoAction(): GetOrderInfoHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<OrderInfo | null>(null)
    const [data, setData] = useState<OrderInfo | null>(null)

    const mutate = async (params: {
        email: Email
    }): Promise<OrderInfo | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/GetOrderInfo', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface GetQueryHookResult {
    data: SearchParams | null
    partialData: SearchParams | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        query: string
    }) => Promise<SearchParams | undefined>
}

export function useGetQueryAction(): GetQueryHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<SearchParams | null>(null)
    const [data, setData] = useState<SearchParams | null>(null)

    const mutate = async (params: {
        query: string
    }): Promise<SearchParams | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/GetQuery', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface InOutEnumMapKeyHookResult {
    data: Partial<Record<MapKey, string>> | null
    partialData: Partial<Record<MapKey, string>> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        i1: Partial<Record<MapKey, string>>,
        i2: Partial<Record<MapKey, string>>
    }) => Promise<Partial<Record<MapKey, string>> | undefined>
}

export function useInOutEnumMapKeyAction(): InOutEnumMapKeyHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Partial<Record<MapKey, string>> | null>(null)
    const [data, setData] = useState<Partial<Record<MapKey, string>> | null>(null)

    const mutate = async (params: {
        i1: Partial<Record<MapKey, string>>,
        i2: Partial<Record<MapKey, string>>
    }): Promise<Partial<Record<MapKey, string>> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/InOutEnumMapKey', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface InOutLiteralStringUnionMapKeyHookResult {
    data: Partial<Record<"one" | "two" | "three" | "four", string>> | null
    partialData: Partial<Record<"one" | "two" | "three" | "four", string>> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        i1: Partial<Record<"one" | "two" | "three" | "four", string>>,
        i2: Partial<Record<"one" | "two" | "three" | "four", string>>
    }) => Promise<Partial<Record<"one" | "two" | "three" | "four", string>> | undefined>
}

export function useInOutLiteralStringUnionMapKeyAction(): InOutLiteralStringUnionMapKeyHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Partial<Record<"one" | "two" | "three" | "four", string>> | null>(null)
    const [data, setData] = useState<Partial<Record<"one" | "two" | "three" | "four", string>> | null>(null)

    const mutate = async (params: {
        i1: Partial<Record<"one" | "two" | "three" | "four", string>>,
        i2: Partial<Record<"one" | "two" | "three" | "four", string>>
    }): Promise<Partial<Record<"one" | "two" | "three" | "four", string>> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/InOutLiteralStringUnionMapKey', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface InOutSingleLiteralStringMapKeyHookResult {
    data: Partial<Record<"key", string>> | null
    partialData: Partial<Record<"key", string>> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        m: Partial<Record<"key", string>>
    }) => Promise<Partial<Record<"key", string>> | undefined>
}

export function useInOutSingleLiteralStringMapKeyAction(): InOutSingleLiteralStringMapKeyHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Partial<Record<"key", string>> | null>(null)
    const [data, setData] = useState<Partial<Record<"key", string>> | null>(null)

    const mutate = async (params: {
        m: Partial<Record<"key", string>>
    }): Promise<Partial<Record<"key", string>> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/InOutSingleLiteralStringMapKey', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface JsonTypeAliasCycleHookResult {
    data: JsonValue | null
    partialData: JsonValue | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: JsonValue
    }) => Promise<JsonValue | undefined>
}

export function useJsonTypeAliasCycleAction(): JsonTypeAliasCycleHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<JsonValue | null>(null)
    const [data, setData] = useState<JsonValue | null>(null)

    const mutate = async (params: {
        input: JsonValue
    }): Promise<JsonValue | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/JsonTypeAliasCycle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface LiteralUnionsTestHookResult {
    data: 1 | true | "string output" | null
    partialData: 1 | true | "string output" | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<1 | true | "string output" | undefined>
}

export function useLiteralUnionsTestAction(): LiteralUnionsTestHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<1 | true | "string output" | null>(null)
    const [data, setData] = useState<1 | true | "string output" | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<1 | true | "string output" | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/LiteralUnionsTest', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface MakeBlockConstraintHookResult {
    data: Checked<BlockConstraint,"cross_field"> | null
    partialData: Checked<BlockConstraint,"cross_field"> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<Checked<BlockConstraint,"cross_field"> | undefined>
}

export function useMakeBlockConstraintAction(): MakeBlockConstraintHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Checked<BlockConstraint,"cross_field"> | null>(null)
    const [data, setData] = useState<Checked<BlockConstraint,"cross_field"> | null>(null)

    const mutate = async (params: {
    }): Promise<Checked<BlockConstraint,"cross_field"> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/MakeBlockConstraint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface MakeNestedBlockConstraintHookResult {
    data: NestedBlockConstraint | null
    partialData: NestedBlockConstraint | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<NestedBlockConstraint | undefined>
}

export function useMakeNestedBlockConstraintAction(): MakeNestedBlockConstraintHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<NestedBlockConstraint | null>(null)
    const [data, setData] = useState<NestedBlockConstraint | null>(null)

    const mutate = async (params: {
    }): Promise<NestedBlockConstraint | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/MakeNestedBlockConstraint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface MapAliasHookResult {
    data: Record<string, string[]> | null
    partialData: Record<string, string[]> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        m: Record<string, string[]>
    }) => Promise<Record<string, string[]> | undefined>
}

export function useMapAliasAction(): MapAliasHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Record<string, string[]> | null>(null)
    const [data, setData] = useState<Record<string, string[]> | null>(null)

    const mutate = async (params: {
        m: Record<string, string[]>
    }): Promise<Record<string, string[]> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/MapAlias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface MergeAliasAttributesHookResult {
    data: MergeAttrs | null
    partialData: MergeAttrs | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        money: number
    }) => Promise<MergeAttrs | undefined>
}

export function useMergeAliasAttributesAction(): MergeAliasAttributesHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<MergeAttrs | null>(null)
    const [data, setData] = useState<MergeAttrs | null>(null)

    const mutate = async (params: {
        money: number
    }): Promise<MergeAttrs | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/MergeAliasAttributes', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface MyFuncHookResult {
    data: DynamicOutput | null
    partialData: DynamicOutput | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<DynamicOutput | undefined>
}

export function useMyFuncAction(): MyFuncHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<DynamicOutput | null>(null)
    const [data, setData] = useState<DynamicOutput | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<DynamicOutput | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/MyFunc', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface NestedAliasHookResult {
    data: number | string | boolean | number | string[] | Record<string, string[]> | null
    partialData: number | string | boolean | number | string[] | Record<string, string[]> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        c: number | string | boolean | number | string[] | Record<string, string[]>
    }) => Promise<number | string | boolean | number | string[] | Record<string, string[]> | undefined>
}

export function useNestedAliasAction(): NestedAliasHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | string | boolean | number | string[] | Record<string, string[]> | null>(null)
    const [data, setData] = useState<number | string | boolean | number | string[] | Record<string, string[]> | null>(null)

    const mutate = async (params: {
        c: number | string | boolean | number | string[] | Record<string, string[]>
    }): Promise<number | string | boolean | number | string[] | Record<string, string[]> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/NestedAlias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface OptionalTest_FunctionHookResult {
    data: (OptionalTest_ReturnType | null)[] | null
    partialData: (OptionalTest_ReturnType | null)[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<(OptionalTest_ReturnType | null)[] | undefined>
}

export function useOptionalTest_FunctionAction(): OptionalTest_FunctionHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<(OptionalTest_ReturnType | null)[] | null>(null)
    const [data, setData] = useState<(OptionalTest_ReturnType | null)[] | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<(OptionalTest_ReturnType | null)[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/OptionalTest_Function', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PredictAgeHookResult {
    data: FooAny | null
    partialData: FooAny | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        name: string
    }) => Promise<FooAny | undefined>
}

export function usePredictAgeAction(): PredictAgeHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<FooAny | null>(null)
    const [data, setData] = useState<FooAny | null>(null)

    const mutate = async (params: {
        name: string
    }): Promise<FooAny | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PredictAge', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PredictAgeBareHookResult {
    data: Checked<number,"too_big"> | null
    partialData: Checked<number,"too_big"> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        inp: string
    }) => Promise<Checked<number,"too_big"> | undefined>
}

export function usePredictAgeBareAction(): PredictAgeBareHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Checked<number,"too_big"> | null>(null)
    const [data, setData] = useState<Checked<number,"too_big"> | null>(null)

    const mutate = async (params: {
        inp: string
    }): Promise<Checked<number,"too_big"> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PredictAgeBare', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PrimitiveAliasHookResult {
    data: number | string | boolean | number | null
    partialData: number | string | boolean | number | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        p: number | string | boolean | number
    }) => Promise<number | string | boolean | number | undefined>
}

export function usePrimitiveAliasAction(): PrimitiveAliasHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | string | boolean | number | null>(null)
    const [data, setData] = useState<number | string | boolean | number | null>(null)

    const mutate = async (params: {
        p: number | string | boolean | number
    }): Promise<number | string | boolean | number | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PrimitiveAlias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PromptTestClaudeHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function usePromptTestClaudeAction(): PromptTestClaudeHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PromptTestClaude', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PromptTestClaudeChatHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function usePromptTestClaudeChatAction(): PromptTestClaudeChatHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PromptTestClaudeChat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PromptTestClaudeChatNoSystemHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function usePromptTestClaudeChatNoSystemAction(): PromptTestClaudeChatNoSystemHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PromptTestClaudeChatNoSystem', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PromptTestOpenAIHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function usePromptTestOpenAIAction(): PromptTestOpenAIHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PromptTestOpenAI', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PromptTestOpenAIChatHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function usePromptTestOpenAIChatAction(): PromptTestOpenAIChatHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PromptTestOpenAIChat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PromptTestOpenAIChatNoSystemHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function usePromptTestOpenAIChatNoSystemAction(): PromptTestOpenAIChatNoSystemHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PromptTestOpenAIChatNoSystem', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface PromptTestStreamingHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function usePromptTestStreamingAction(): PromptTestStreamingHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/PromptTestStreaming', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface RecursiveAliasCycleHookResult {
    data: RecAliasOne | null
    partialData: RecAliasOne | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: RecAliasOne
    }) => Promise<RecAliasOne | undefined>
}

export function useRecursiveAliasCycleAction(): RecursiveAliasCycleHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<RecAliasOne | null>(null)
    const [data, setData] = useState<RecAliasOne | null>(null)

    const mutate = async (params: {
        input: RecAliasOne
    }): Promise<RecAliasOne | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/RecursiveAliasCycle', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface RecursiveClassWithAliasIndirectionHookResult {
    data: NodeWithAliasIndirection | null
    partialData: NodeWithAliasIndirection | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        cls: NodeWithAliasIndirection
    }) => Promise<NodeWithAliasIndirection | undefined>
}

export function useRecursiveClassWithAliasIndirectionAction(): RecursiveClassWithAliasIndirectionHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<NodeWithAliasIndirection | null>(null)
    const [data, setData] = useState<NodeWithAliasIndirection | null>(null)

    const mutate = async (params: {
        cls: NodeWithAliasIndirection
    }): Promise<NodeWithAliasIndirection | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/RecursiveClassWithAliasIndirection', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ReturnAliasWithMergedAttributesHookResult {
    data: Checked<number,"gt_ten"> | null
    partialData: Checked<number,"gt_ten"> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        money: Checked<number,"gt_ten">
    }) => Promise<Checked<number,"gt_ten"> | undefined>
}

export function useReturnAliasWithMergedAttributesAction(): ReturnAliasWithMergedAttributesHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Checked<number,"gt_ten"> | null>(null)
    const [data, setData] = useState<Checked<number,"gt_ten"> | null>(null)

    const mutate = async (params: {
        money: Checked<number,"gt_ten">
    }): Promise<Checked<number,"gt_ten"> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ReturnAliasWithMergedAttributes', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ReturnFailingAssertHookResult {
    data: number | null
    partialData: number | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        inp: number
    }) => Promise<number | undefined>
}

export function useReturnFailingAssertAction(): ReturnFailingAssertHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | null>(null)
    const [data, setData] = useState<number | null>(null)

    const mutate = async (params: {
        inp: number
    }): Promise<number | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ReturnFailingAssert', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface ReturnMalformedConstraintsHookResult {
    data: MalformedConstraints | null
    partialData: MalformedConstraints | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        a: number
    }) => Promise<MalformedConstraints | undefined>
}

export function useReturnMalformedConstraintsAction(): ReturnMalformedConstraintsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<MalformedConstraints | null>(null)
    const [data, setData] = useState<MalformedConstraints | null>(null)

    const mutate = async (params: {
        a: number
    }): Promise<MalformedConstraints | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/ReturnMalformedConstraints', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface SchemaDescriptionsHookResult {
    data: Schema | null
    partialData: Schema | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<Schema | undefined>
}

export function useSchemaDescriptionsAction(): SchemaDescriptionsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Schema | null>(null)
    const [data, setData] = useState<Schema | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<Schema | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/SchemaDescriptions', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface SimpleRecursiveListAliasHookResult {
    data: RecursiveListAlias | null
    partialData: RecursiveListAlias | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: RecursiveListAlias
    }) => Promise<RecursiveListAlias | undefined>
}

export function useSimpleRecursiveListAliasAction(): SimpleRecursiveListAliasHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<RecursiveListAlias | null>(null)
    const [data, setData] = useState<RecursiveListAlias | null>(null)

    const mutate = async (params: {
        input: RecursiveListAlias
    }): Promise<RecursiveListAlias | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/SimpleRecursiveListAlias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface SimpleRecursiveMapAliasHookResult {
    data: RecursiveMapAlias | null
    partialData: RecursiveMapAlias | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: RecursiveMapAlias
    }) => Promise<RecursiveMapAlias | undefined>
}

export function useSimpleRecursiveMapAliasAction(): SimpleRecursiveMapAliasHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<RecursiveMapAlias | null>(null)
    const [data, setData] = useState<RecursiveMapAlias | null>(null)

    const mutate = async (params: {
        input: RecursiveMapAlias
    }): Promise<RecursiveMapAlias | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/SimpleRecursiveMapAlias', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface StreamBigNumbersHookResult {
    data: BigNumbers | null
    partialData: BigNumbers | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        digits: number
    }) => Promise<BigNumbers | undefined>
}

export function useStreamBigNumbersAction(): StreamBigNumbersHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<BigNumbers | null>(null)
    const [data, setData] = useState<BigNumbers | null>(null)

    const mutate = async (params: {
        digits: number
    }): Promise<BigNumbers | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/StreamBigNumbers', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface StreamFailingAssertionHookResult {
    data: TwoStoriesOneTitle | null
    partialData: TwoStoriesOneTitle | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        theme: string,
        length: number
    }) => Promise<TwoStoriesOneTitle | undefined>
}

export function useStreamFailingAssertionAction(): StreamFailingAssertionHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<TwoStoriesOneTitle | null>(null)
    const [data, setData] = useState<TwoStoriesOneTitle | null>(null)

    const mutate = async (params: {
        theme: string,
        length: number
    }): Promise<TwoStoriesOneTitle | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/StreamFailingAssertion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface StreamOneBigNumberHookResult {
    data: number | null
    partialData: number | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        digits: number
    }) => Promise<number | undefined>
}

export function useStreamOneBigNumberAction(): StreamOneBigNumberHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | null>(null)
    const [data, setData] = useState<number | null>(null)

    const mutate = async (params: {
        digits: number
    }): Promise<number | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/StreamOneBigNumber', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface StreamUnionIntegersHookResult {
    data: (number | string)[] | null
    partialData: (number | string)[] | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        digits: number
    }) => Promise<(number | string)[] | undefined>
}

export function useStreamUnionIntegersAction(): StreamUnionIntegersHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<(number | string)[] | null>(null)
    const [data, setData] = useState<(number | string)[] | null>(null)

    const mutate = async (params: {
        digits: number
    }): Promise<(number | string)[] | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/StreamUnionIntegers', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface StreamingCompoundNumbersHookResult {
    data: CompoundBigNumbers | null
    partialData: CompoundBigNumbers | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        digits: number,
        yapping: boolean
    }) => Promise<CompoundBigNumbers | undefined>
}

export function useStreamingCompoundNumbersAction(): StreamingCompoundNumbersHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<CompoundBigNumbers | null>(null)
    const [data, setData] = useState<CompoundBigNumbers | null>(null)

    const mutate = async (params: {
        digits: number,
        yapping: boolean
    }): Promise<CompoundBigNumbers | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/StreamingCompoundNumbers', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAnthropicHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAnthropicAction(): TestAnthropicHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAnthropic', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAnthropicShorthandHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAnthropicShorthandAction(): TestAnthropicShorthandHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAnthropicShorthand', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAwsHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAwsAction(): TestAwsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAws', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAwsInvalidAccessKeyHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAwsInvalidAccessKeyAction(): TestAwsInvalidAccessKeyHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAwsInvalidAccessKey', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAwsInvalidProfileHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAwsInvalidProfileAction(): TestAwsInvalidProfileHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAwsInvalidProfile', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAwsInvalidRegionHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAwsInvalidRegionAction(): TestAwsInvalidRegionHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAwsInvalidRegion', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAwsInvalidSessionTokenHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAwsInvalidSessionTokenAction(): TestAwsInvalidSessionTokenHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAwsInvalidSessionToken', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAzureHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAzureAction(): TestAzureHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAzure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestAzureFailureHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestAzureFailureAction(): TestAzureFailureHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestAzureFailure', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestCachingHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string,
        not_cached: string
    }) => Promise<string | undefined>
}

export function useTestCachingAction(): TestCachingHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string,
        not_cached: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestCaching', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFallbackClientHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<string | undefined>
}

export function useTestFallbackClientAction(): TestFallbackClientHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFallbackClient', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFallbackToShorthandHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestFallbackToShorthandAction(): TestFallbackToShorthandHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFallbackToShorthand', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleBoolHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myBool: boolean
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleBoolAction(): TestFnNamedArgsSingleBoolHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myBool: boolean
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleBool', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleClassHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myArg: NamedArgsSingleClass
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleClassAction(): TestFnNamedArgsSingleClassHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myArg: NamedArgsSingleClass
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleClass', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleEnumListHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myArg: NamedArgsSingleEnumList[]
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleEnumListAction(): TestFnNamedArgsSingleEnumListHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myArg: NamedArgsSingleEnumList[]
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleEnumList', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleFloatHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myFloat: number
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleFloatAction(): TestFnNamedArgsSingleFloatHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myFloat: number
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleFloat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleIntHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myInt: number
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleIntAction(): TestFnNamedArgsSingleIntHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myInt: number
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleInt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleMapStringToClassHookResult {
    data: Record<string, StringToClassEntry> | null
    partialData: Record<string, StringToClassEntry> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myMap: Record<string, StringToClassEntry>
    }) => Promise<Record<string, StringToClassEntry> | undefined>
}

export function useTestFnNamedArgsSingleMapStringToClassAction(): TestFnNamedArgsSingleMapStringToClassHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Record<string, StringToClassEntry> | null>(null)
    const [data, setData] = useState<Record<string, StringToClassEntry> | null>(null)

    const mutate = async (params: {
        myMap: Record<string, StringToClassEntry>
    }): Promise<Record<string, StringToClassEntry> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleMapStringToClass', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleMapStringToMapHookResult {
    data: Record<string, Record<string, string>> | null
    partialData: Record<string, Record<string, string>> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myMap: Record<string, Record<string, string>>
    }) => Promise<Record<string, Record<string, string>> | undefined>
}

export function useTestFnNamedArgsSingleMapStringToMapAction(): TestFnNamedArgsSingleMapStringToMapHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Record<string, Record<string, string>> | null>(null)
    const [data, setData] = useState<Record<string, Record<string, string>> | null>(null)

    const mutate = async (params: {
        myMap: Record<string, Record<string, string>>
    }): Promise<Record<string, Record<string, string>> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleMapStringToMap', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleMapStringToStringHookResult {
    data: Record<string, string> | null
    partialData: Record<string, string> | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myMap: Record<string, string>
    }) => Promise<Record<string, string> | undefined>
}

export function useTestFnNamedArgsSingleMapStringToStringAction(): TestFnNamedArgsSingleMapStringToStringHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<Record<string, string> | null>(null)
    const [data, setData] = useState<Record<string, string> | null>(null)

    const mutate = async (params: {
        myMap: Record<string, string>
    }): Promise<Record<string, string> | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleMapStringToString', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleStringHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myString: string
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleStringAction(): TestFnNamedArgsSingleStringHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myString: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleString', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleStringArrayHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myStringArray: string[]
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleStringArrayAction(): TestFnNamedArgsSingleStringArrayHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myStringArray: string[]
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleStringArray', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestFnNamedArgsSingleStringListHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myArg: string[]
    }) => Promise<string | undefined>
}

export function useTestFnNamedArgsSingleStringListAction(): TestFnNamedArgsSingleStringListHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myArg: string[]
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestFnNamedArgsSingleStringList', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestGeminiHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestGeminiAction(): TestGeminiHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestGemini', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestImageInputHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        img: Image
    }) => Promise<string | undefined>
}

export function useTestImageInputAction(): TestImageInputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        img: Image
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestImageInput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestImageInputAnthropicHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        img: Image
    }) => Promise<string | undefined>
}

export function useTestImageInputAnthropicAction(): TestImageInputAnthropicHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        img: Image
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestImageInputAnthropic', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestImageListInputHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        imgs: Image[]
    }) => Promise<string | undefined>
}

export function useTestImageListInputAction(): TestImageListInputHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        imgs: Image[]
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestImageListInput', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestMulticlassNamedArgsHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myArg: NamedArgsSingleClass,
        myArg2: NamedArgsSingleClass
    }) => Promise<string | undefined>
}

export function useTestMulticlassNamedArgsAction(): TestMulticlassNamedArgsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myArg: NamedArgsSingleClass,
        myArg2: NamedArgsSingleClass
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestMulticlassNamedArgs', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestNamedArgsLiteralBoolHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myBool: true
    }) => Promise<string | undefined>
}

export function useTestNamedArgsLiteralBoolAction(): TestNamedArgsLiteralBoolHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myBool: true
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestNamedArgsLiteralBool', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestNamedArgsLiteralIntHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myInt: 1
    }) => Promise<string | undefined>
}

export function useTestNamedArgsLiteralIntAction(): TestNamedArgsLiteralIntHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myInt: 1
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestNamedArgsLiteralInt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestNamedArgsLiteralStringHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        myString: "My String"
    }) => Promise<string | undefined>
}

export function useTestNamedArgsLiteralStringAction(): TestNamedArgsLiteralStringHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        myString: "My String"
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestNamedArgsLiteralString', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestOllamaHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestOllamaAction(): TestOllamaHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestOllama', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestOpenAILegacyProviderHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestOpenAILegacyProviderAction(): TestOpenAILegacyProviderHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestOpenAILegacyProvider', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestOpenAIShorthandHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestOpenAIShorthandAction(): TestOpenAIShorthandHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestOpenAIShorthand', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestRetryConstantHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<string | undefined>
}

export function useTestRetryConstantAction(): TestRetryConstantHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestRetryConstant', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestRetryExponentialHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<string | undefined>
}

export function useTestRetryExponentialAction(): TestRetryExponentialHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestRetryExponential', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestSingleFallbackClientHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
    }) => Promise<string | undefined>
}

export function useTestSingleFallbackClientAction(): TestSingleFallbackClientHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestSingleFallbackClient', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface TestVertexHookResult {
    data: string | null
    partialData: string | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string
    }) => Promise<string | undefined>
}

export function useTestVertexAction(): TestVertexHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<string | null>(null)
    const [data, setData] = useState<string | null>(null)

    const mutate = async (params: {
        input: string
    }): Promise<string | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/TestVertex', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface UnionTest_FunctionHookResult {
    data: UnionTest_ReturnType | null
    partialData: UnionTest_ReturnType | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        input: string | boolean
    }) => Promise<UnionTest_ReturnType | undefined>
}

export function useUnionTest_FunctionAction(): UnionTest_FunctionHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<UnionTest_ReturnType | null>(null)
    const [data, setData] = useState<UnionTest_ReturnType | null>(null)

    const mutate = async (params: {
        input: string | boolean
    }): Promise<UnionTest_ReturnType | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/UnionTest_Function', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface UseBlockConstraintHookResult {
    data: number | null
    partialData: number | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        inp: BlockConstraintForParam
    }) => Promise<number | undefined>
}

export function useUseBlockConstraintAction(): UseBlockConstraintHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | null>(null)
    const [data, setData] = useState<number | null>(null)

    const mutate = async (params: {
        inp: BlockConstraintForParam
    }): Promise<number | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/UseBlockConstraint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface UseMalformedConstraintsHookResult {
    data: number | null
    partialData: number | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        a: MalformedConstraints2
    }) => Promise<number | undefined>
}

export function useUseMalformedConstraintsAction(): UseMalformedConstraintsHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | null>(null)
    const [data, setData] = useState<number | null>(null)

    const mutate = async (params: {
        a: MalformedConstraints2
    }): Promise<number | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/UseMalformedConstraints', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

interface UseNestedBlockConstraintHookResult {
    data: number | null
    partialData: number | null
    isLoading: boolean
    isError: boolean
    error: Error | null
    mutate: (params: {
        inp: NestedBlockConstraintForParam
    }) => Promise<number | undefined>
}

export function useUseNestedBlockConstraintAction(): UseNestedBlockConstraintHookResult {
    const [isLoading, setIsLoading] = useState<boolean>(false)
    const [isError, setIsError] = useState<boolean>(false)
    const [error, setError] = useState<Error | null>(null)
    const [partialData, setPartialData] = useState<number | null>(null)
    const [data, setData] = useState<number | null>(null)

    const mutate = async (params: {
        inp: NestedBlockConstraintForParam
    }): Promise<number | undefined> => {
        setIsLoading(true)
        setIsError(false)
        setError(null)

        try {
            const response = await fetch('/api/baml/UseNestedBlockConstraint', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(params),
            })

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`)
            }

            const reader = response.body?.getReader()
            const decoder = new TextDecoder()

            while (reader) {
                const { value, done } = await reader.read()
                if (done) break

                const chunk = decoder.decode(value)
                const parsed = JSON.parse(chunk)

                if ('partial' in parsed) {
                    setPartialData(parsed.partial)
                } else if ('final' in parsed) {
                    setData(parsed.final)
                    return parsed.final
                }
            }
        } catch (err) {
            setIsError(true)
            setError(err instanceof Error ? err : new Error('An error occurred'))
        } finally {
            setIsLoading(false)
        }
    }

    return {
        data,
        partialData,
        isLoading,
        isError,
        error,
        mutate,
    }
}

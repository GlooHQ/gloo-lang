/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use server'

import { b } from '../index';
import { Check, Checked, RecursivePartialNull } from "../types"
import { Image, Audio } from "@boundaryml/baml"
import {BigNumbers, BinaryNode, Blah, BlockConstraint, BlockConstraintForParam, BookOrder, ClassOptionalOutput, ClassOptionalOutput2, ClassToRecAlias, ClassWithImage, CompoundBigNumbers, ContactInfo, CustomTaskResult, DummyOutput, DynInputOutput, DynamicClassOne, DynamicClassTwo, DynamicOutput, Earthling, Education, Email, EmailAddress, Event, FakeImage, FlightConfirmation, FooAny, Forest, FormatterTest0, FormatterTest1, FormatterTest2, FormatterTest3, GroceryReceipt, InnerClass, InnerClass2, InputClass, InputClassNested, LinkedList, LinkedListAliasNode, LiteralClassHello, LiteralClassOne, LiteralClassTwo, MalformedConstraints, MalformedConstraints2, Martian, MergeAttrs, NamedArgsSingleClass, Nested, Nested2, NestedBlockConstraint, NestedBlockConstraintForParam, Node, NodeWithAliasIndirection, OptionalListAndMap, OptionalTest_Prop1, OptionalTest_ReturnType, OrderInfo, OriginalA, OriginalB, Person, PhoneNumber, Quantity, RaysData, ReceiptInfo, ReceiptItem, Recipe, Resume, Schema, SearchParams, SomeClassNestedDynamic, StringToClassEntry, TestClassAlias, TestClassNested, TestClassWithEnum, TestOutputClass, Tree, TwoStoriesOneTitle, UnionTest_ReturnType, UniverseQuestion, UniverseQuestionInput, WithReasoning, AliasedEnum, Category, Category2, Category3, Color, DataType, DynEnumOne, DynEnumTwo, EnumInClass, EnumOutput, Hobby, MapKey, NamedArgsSingleEnum, NamedArgsSingleEnumList, OptionalTest_CategoryType, OrderStatus, Tag, TestEnum} from "../types"
/**
 * Server action for the AaaSamOutputFormat BAML function.
 *
 * Input Types:
 *
 * - recipe: string
 *
 *
 * Return Type:
 * - Non-streaming: Recipe
 * - Streaming: ReadableStream
 */
 export async function AaaSamOutputFormatAction<Options extends { stream: true }>(
  recipe: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AaaSamOutputFormatAction<Options extends { stream?: false }>(
  recipe: string,
  options?: Options
): Promise<Recipe>;

export async function AaaSamOutputFormatAction<Options extends { stream?: boolean }>(
  recipe: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Recipe> {
  if (options?.stream) {
    const stream = b.stream.AaaSamOutputFormat(
      recipe,
    );
    return stream.toStreamable();
  }
  return b.AaaSamOutputFormat(
    recipe,
  );
};

/**
 * Server action for the AliasThatPointsToRecursiveType BAML function.
 *
 * Input Types:
 *
 * - list: LinkedListAliasNode
 *
 *
 * Return Type:
 * - Non-streaming: LinkedListAliasNode
 * - Streaming: ReadableStream
 */
 export async function AliasThatPointsToRecursiveTypeAction<Options extends { stream: true }>(
  list: LinkedListAliasNode,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AliasThatPointsToRecursiveTypeAction<Options extends { stream?: false }>(
  list: LinkedListAliasNode,
  options?: Options
): Promise<LinkedListAliasNode>;

export async function AliasThatPointsToRecursiveTypeAction<Options extends { stream?: boolean }>(
  list: LinkedListAliasNode,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : LinkedListAliasNode> {
  if (options?.stream) {
    const stream = b.stream.AliasThatPointsToRecursiveType(
      list,
    );
    return stream.toStreamable();
  }
  return b.AliasThatPointsToRecursiveType(
    list,
  );
};

/**
 * Server action for the AliasWithMultipleAttrs BAML function.
 *
 * Input Types:
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"gt_ten">
 * - Streaming: ReadableStream
 */
 export async function AliasWithMultipleAttrsAction<Options extends { stream: true }>(
  money: Checked<number,"gt_ten">,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AliasWithMultipleAttrsAction<Options extends { stream?: false }>(
  money: Checked<number,"gt_ten">,
  options?: Options
): Promise<Checked<number,"gt_ten">>;

export async function AliasWithMultipleAttrsAction<Options extends { stream?: boolean }>(
  money: Checked<number,"gt_ten">,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Checked<number,"gt_ten">> {
  if (options?.stream) {
    const stream = b.stream.AliasWithMultipleAttrs(
      money,
    );
    return stream.toStreamable();
  }
  return b.AliasWithMultipleAttrs(
    money,
  );
};

/**
 * Server action for the AliasedInputClass BAML function.
 *
 * Input Types:
 *
 * - input: InputClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function AliasedInputClassAction<Options extends { stream: true }>(
  input: InputClass,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AliasedInputClassAction<Options extends { stream?: false }>(
  input: InputClass,
  options?: Options
): Promise<string>;

export async function AliasedInputClassAction<Options extends { stream?: boolean }>(
  input: InputClass,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.AliasedInputClass(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputClass(
    input,
  );
};

/**
 * Server action for the AliasedInputClass2 BAML function.
 *
 * Input Types:
 *
 * - input: InputClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function AliasedInputClass2Action<Options extends { stream: true }>(
  input: InputClass,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AliasedInputClass2Action<Options extends { stream?: false }>(
  input: InputClass,
  options?: Options
): Promise<string>;

export async function AliasedInputClass2Action<Options extends { stream?: boolean }>(
  input: InputClass,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.AliasedInputClass2(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputClass2(
    input,
  );
};

/**
 * Server action for the AliasedInputClassNested BAML function.
 *
 * Input Types:
 *
 * - input: InputClassNested
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function AliasedInputClassNestedAction<Options extends { stream: true }>(
  input: InputClassNested,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AliasedInputClassNestedAction<Options extends { stream?: false }>(
  input: InputClassNested,
  options?: Options
): Promise<string>;

export async function AliasedInputClassNestedAction<Options extends { stream?: boolean }>(
  input: InputClassNested,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.AliasedInputClassNested(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputClassNested(
    input,
  );
};

/**
 * Server action for the AliasedInputEnum BAML function.
 *
 * Input Types:
 *
 * - input: AliasedEnum
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function AliasedInputEnumAction<Options extends { stream: true }>(
  input: AliasedEnum,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AliasedInputEnumAction<Options extends { stream?: false }>(
  input: AliasedEnum,
  options?: Options
): Promise<string>;

export async function AliasedInputEnumAction<Options extends { stream?: boolean }>(
  input: AliasedEnum,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.AliasedInputEnum(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputEnum(
    input,
  );
};

/**
 * Server action for the AliasedInputList BAML function.
 *
 * Input Types:
 *
 * - input: AliasedEnum[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function AliasedInputListAction<Options extends { stream: true }>(
  input: AliasedEnum[],
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AliasedInputListAction<Options extends { stream?: false }>(
  input: AliasedEnum[],
  options?: Options
): Promise<string>;

export async function AliasedInputListAction<Options extends { stream?: boolean }>(
  input: AliasedEnum[],
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.AliasedInputList(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputList(
    input,
  );
};

/**
 * Server action for the AllowedOptionals BAML function.
 *
 * Input Types:
 *
 * - optionals: OptionalListAndMap
 *
 *
 * Return Type:
 * - Non-streaming: OptionalListAndMap
 * - Streaming: ReadableStream
 */
 export async function AllowedOptionalsAction<Options extends { stream: true }>(
  optionals: OptionalListAndMap,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AllowedOptionalsAction<Options extends { stream?: false }>(
  optionals: OptionalListAndMap,
  options?: Options
): Promise<OptionalListAndMap>;

export async function AllowedOptionalsAction<Options extends { stream?: boolean }>(
  optionals: OptionalListAndMap,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : OptionalListAndMap> {
  if (options?.stream) {
    const stream = b.stream.AllowedOptionals(
      optionals,
    );
    return stream.toStreamable();
  }
  return b.AllowedOptionals(
    optionals,
  );
};

/**
 * Server action for the AudioInput BAML function.
 *
 * Input Types:
 *
 * - aud: Audio
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function AudioInputAction<Options extends { stream: true }>(
  aud: Audio,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function AudioInputAction<Options extends { stream?: false }>(
  aud: Audio,
  options?: Options
): Promise<string>;

export async function AudioInputAction<Options extends { stream?: boolean }>(
  aud: Audio,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.AudioInput(
      aud,
    );
    return stream.toStreamable();
  }
  return b.AudioInput(
    aud,
  );
};

/**
 * Server action for the BuildLinkedList BAML function.
 *
 * Input Types:
 *
 * - input: number[]
 *
 *
 * Return Type:
 * - Non-streaming: LinkedList
 * - Streaming: ReadableStream
 */
 export async function BuildLinkedListAction<Options extends { stream: true }>(
  input: number[],
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function BuildLinkedListAction<Options extends { stream?: false }>(
  input: number[],
  options?: Options
): Promise<LinkedList>;

export async function BuildLinkedListAction<Options extends { stream?: boolean }>(
  input: number[],
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : LinkedList> {
  if (options?.stream) {
    const stream = b.stream.BuildLinkedList(
      input,
    );
    return stream.toStreamable();
  }
  return b.BuildLinkedList(
    input,
  );
};

/**
 * Server action for the BuildTree BAML function.
 *
 * Input Types:
 *
 * - input: BinaryNode
 *
 *
 * Return Type:
 * - Non-streaming: Tree
 * - Streaming: ReadableStream
 */
 export async function BuildTreeAction<Options extends { stream: true }>(
  input: BinaryNode,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function BuildTreeAction<Options extends { stream?: false }>(
  input: BinaryNode,
  options?: Options
): Promise<Tree>;

export async function BuildTreeAction<Options extends { stream?: boolean }>(
  input: BinaryNode,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Tree> {
  if (options?.stream) {
    const stream = b.stream.BuildTree(
      input,
    );
    return stream.toStreamable();
  }
  return b.BuildTree(
    input,
  );
};

/**
 * Server action for the ClassThatPointsToRecursiveClassThroughAlias BAML function.
 *
 * Input Types:
 *
 * - cls: ClassToRecAlias
 *
 *
 * Return Type:
 * - Non-streaming: ClassToRecAlias
 * - Streaming: ReadableStream
 */
 export async function ClassThatPointsToRecursiveClassThroughAliasAction<Options extends { stream: true }>(
  cls: ClassToRecAlias,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ClassThatPointsToRecursiveClassThroughAliasAction<Options extends { stream?: false }>(
  cls: ClassToRecAlias,
  options?: Options
): Promise<ClassToRecAlias>;

export async function ClassThatPointsToRecursiveClassThroughAliasAction<Options extends { stream?: boolean }>(
  cls: ClassToRecAlias,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : ClassToRecAlias> {
  if (options?.stream) {
    const stream = b.stream.ClassThatPointsToRecursiveClassThroughAlias(
      cls,
    );
    return stream.toStreamable();
  }
  return b.ClassThatPointsToRecursiveClassThroughAlias(
    cls,
  );
};

/**
 * Server action for the ClassifyDynEnumTwo BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: (string | DynEnumTwo)
 * - Streaming: ReadableStream
 */
 export async function ClassifyDynEnumTwoAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ClassifyDynEnumTwoAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<(string | DynEnumTwo)>;

export async function ClassifyDynEnumTwoAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : (string | DynEnumTwo)> {
  if (options?.stream) {
    const stream = b.stream.ClassifyDynEnumTwo(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyDynEnumTwo(
    input,
  );
};

/**
 * Server action for the ClassifyMessage BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming: ReadableStream
 */
 export async function ClassifyMessageAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ClassifyMessageAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<Category>;

export async function ClassifyMessageAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Category> {
  if (options?.stream) {
    const stream = b.stream.ClassifyMessage(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyMessage(
    input,
  );
};

/**
 * Server action for the ClassifyMessage2 BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming: ReadableStream
 */
 export async function ClassifyMessage2Action<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ClassifyMessage2Action<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<Category>;

export async function ClassifyMessage2Action<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Category> {
  if (options?.stream) {
    const stream = b.stream.ClassifyMessage2(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyMessage2(
    input,
  );
};

/**
 * Server action for the ClassifyMessage3 BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming: ReadableStream
 */
 export async function ClassifyMessage3Action<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ClassifyMessage3Action<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<Category>;

export async function ClassifyMessage3Action<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Category> {
  if (options?.stream) {
    const stream = b.stream.ClassifyMessage3(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyMessage3(
    input,
  );
};

/**
 * Server action for the Completion BAML function.
 *
 * Input Types:
 *
 * - prefix: string
 *
 * - suffix: string
 *
 * - language: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function CompletionAction<Options extends { stream: true }>(
  prefix: string,
  suffix: string,
  language: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function CompletionAction<Options extends { stream?: false }>(
  prefix: string,
  suffix: string,
  language: string,
  options?: Options
): Promise<string>;

export async function CompletionAction<Options extends { stream?: boolean }>(
  prefix: string,
  suffix: string,
  language: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.Completion(
      prefix,
      suffix,
      language,
    );
    return stream.toStreamable();
  }
  return b.Completion(
    prefix,
    suffix,
    language,
  );
};

/**
 * Server action for the CustomTask BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: BookOrder | FlightConfirmation | GroceryReceipt
 * - Streaming: ReadableStream
 */
 export async function CustomTaskAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function CustomTaskAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<BookOrder | FlightConfirmation | GroceryReceipt>;

export async function CustomTaskAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : BookOrder | FlightConfirmation | GroceryReceipt> {
  if (options?.stream) {
    const stream = b.stream.CustomTask(
      input,
    );
    return stream.toStreamable();
  }
  return b.CustomTask(
    input,
  );
};

/**
 * Server action for the DescribeImage BAML function.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function DescribeImageAction<Options extends { stream: true }>(
  img: Image,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DescribeImageAction<Options extends { stream?: false }>(
  img: Image,
  options?: Options
): Promise<string>;

export async function DescribeImageAction<Options extends { stream?: boolean }>(
  img: Image,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.DescribeImage(
      img,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage(
    img,
  );
};

/**
 * Server action for the DescribeImage2 BAML function.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function DescribeImage2Action<Options extends { stream: true }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DescribeImage2Action<Options extends { stream?: false }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<string>;

export async function DescribeImage2Action<Options extends { stream?: boolean }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.DescribeImage2(
      classWithImage,
      img2,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage2(
    classWithImage,
    img2,
  );
};

/**
 * Server action for the DescribeImage3 BAML function.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function DescribeImage3Action<Options extends { stream: true }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DescribeImage3Action<Options extends { stream?: false }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<string>;

export async function DescribeImage3Action<Options extends { stream?: boolean }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.DescribeImage3(
      classWithImage,
      img2,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage3(
    classWithImage,
    img2,
  );
};

/**
 * Server action for the DescribeImage4 BAML function.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function DescribeImage4Action<Options extends { stream: true }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DescribeImage4Action<Options extends { stream?: false }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<string>;

export async function DescribeImage4Action<Options extends { stream?: boolean }>(
  classWithImage: ClassWithImage,
  img2: Image,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.DescribeImage4(
      classWithImage,
      img2,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage4(
    classWithImage,
    img2,
  );
};

/**
 * Server action for the DifferentiateUnions BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: OriginalA | OriginalB
 * - Streaming: ReadableStream
 */
 export async function DifferentiateUnionsAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DifferentiateUnionsAction<Options extends { stream?: false }>(
  options?: Options
): Promise<OriginalA | OriginalB>;

export async function DifferentiateUnionsAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : OriginalA | OriginalB> {
  if (options?.stream) {
    const stream = b.stream.DifferentiateUnions(
    );
    return stream.toStreamable();
  }
  return b.DifferentiateUnions(
  );
};

/**
 * Server action for the DummyOutputFunction BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: DummyOutput
 * - Streaming: ReadableStream
 */
 export async function DummyOutputFunctionAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DummyOutputFunctionAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<DummyOutput>;

export async function DummyOutputFunctionAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : DummyOutput> {
  if (options?.stream) {
    const stream = b.stream.DummyOutputFunction(
      input,
    );
    return stream.toStreamable();
  }
  return b.DummyOutputFunction(
    input,
  );
};

/**
 * Server action for the DynamicFunc BAML function.
 *
 * Input Types:
 *
 * - input: DynamicClassOne
 *
 *
 * Return Type:
 * - Non-streaming: DynamicClassTwo
 * - Streaming: ReadableStream
 */
 export async function DynamicFuncAction<Options extends { stream: true }>(
  input: DynamicClassOne,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DynamicFuncAction<Options extends { stream?: false }>(
  input: DynamicClassOne,
  options?: Options
): Promise<DynamicClassTwo>;

export async function DynamicFuncAction<Options extends { stream?: boolean }>(
  input: DynamicClassOne,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : DynamicClassTwo> {
  if (options?.stream) {
    const stream = b.stream.DynamicFunc(
      input,
    );
    return stream.toStreamable();
  }
  return b.DynamicFunc(
    input,
  );
};

/**
 * Server action for the DynamicInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: DynInputOutput
 *
 *
 * Return Type:
 * - Non-streaming: DynInputOutput
 * - Streaming: ReadableStream
 */
 export async function DynamicInputOutputAction<Options extends { stream: true }>(
  input: DynInputOutput,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DynamicInputOutputAction<Options extends { stream?: false }>(
  input: DynInputOutput,
  options?: Options
): Promise<DynInputOutput>;

export async function DynamicInputOutputAction<Options extends { stream?: boolean }>(
  input: DynInputOutput,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : DynInputOutput> {
  if (options?.stream) {
    const stream = b.stream.DynamicInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.DynamicInputOutput(
    input,
  );
};

/**
 * Server action for the DynamicListInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: DynInputOutput[]
 *
 *
 * Return Type:
 * - Non-streaming: DynInputOutput[]
 * - Streaming: ReadableStream
 */
 export async function DynamicListInputOutputAction<Options extends { stream: true }>(
  input: DynInputOutput[],
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function DynamicListInputOutputAction<Options extends { stream?: false }>(
  input: DynInputOutput[],
  options?: Options
): Promise<DynInputOutput[]>;

export async function DynamicListInputOutputAction<Options extends { stream?: boolean }>(
  input: DynInputOutput[],
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : DynInputOutput[]> {
  if (options?.stream) {
    const stream = b.stream.DynamicListInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.DynamicListInputOutput(
    input,
  );
};

/**
 * Server action for the ExpectFailure BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function ExpectFailureAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExpectFailureAction<Options extends { stream?: false }>(
  options?: Options
): Promise<string>;

export async function ExpectFailureAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.ExpectFailure(
    );
    return stream.toStreamable();
  }
  return b.ExpectFailure(
  );
};

/**
 * Server action for the ExtractContactInfo BAML function.
 *
 * Input Types:
 *
 * - document: string
 *
 *
 * Return Type:
 * - Non-streaming: ContactInfo
 * - Streaming: ReadableStream
 */
 export async function ExtractContactInfoAction<Options extends { stream: true }>(
  document: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExtractContactInfoAction<Options extends { stream?: false }>(
  document: string,
  options?: Options
): Promise<ContactInfo>;

export async function ExtractContactInfoAction<Options extends { stream?: boolean }>(
  document: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : ContactInfo> {
  if (options?.stream) {
    const stream = b.stream.ExtractContactInfo(
      document,
    );
    return stream.toStreamable();
  }
  return b.ExtractContactInfo(
    document,
  );
};

/**
 * Server action for the ExtractHobby BAML function.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: (string | Hobby)[]
 * - Streaming: ReadableStream
 */
 export async function ExtractHobbyAction<Options extends { stream: true }>(
  text: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExtractHobbyAction<Options extends { stream?: false }>(
  text: string,
  options?: Options
): Promise<(string | Hobby)[]>;

export async function ExtractHobbyAction<Options extends { stream?: boolean }>(
  text: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : (string | Hobby)[]> {
  if (options?.stream) {
    const stream = b.stream.ExtractHobby(
      text,
    );
    return stream.toStreamable();
  }
  return b.ExtractHobby(
    text,
  );
};

/**
 * Server action for the ExtractNames BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string[]
 * - Streaming: ReadableStream
 */
 export async function ExtractNamesAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExtractNamesAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string[]>;

export async function ExtractNamesAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string[]> {
  if (options?.stream) {
    const stream = b.stream.ExtractNames(
      input,
    );
    return stream.toStreamable();
  }
  return b.ExtractNames(
    input,
  );
};

/**
 * Server action for the ExtractPeople BAML function.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: Person[]
 * - Streaming: ReadableStream
 */
 export async function ExtractPeopleAction<Options extends { stream: true }>(
  text: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExtractPeopleAction<Options extends { stream?: false }>(
  text: string,
  options?: Options
): Promise<Person[]>;

export async function ExtractPeopleAction<Options extends { stream?: boolean }>(
  text: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Person[]> {
  if (options?.stream) {
    const stream = b.stream.ExtractPeople(
      text,
    );
    return stream.toStreamable();
  }
  return b.ExtractPeople(
    text,
  );
};

/**
 * Server action for the ExtractReceiptInfo BAML function.
 *
 * Input Types:
 *
 * - email: string
 *
 * - reason: "curiosity" | "personal_finance"
 *
 *
 * Return Type:
 * - Non-streaming: ReceiptInfo
 * - Streaming: ReadableStream
 */
 export async function ExtractReceiptInfoAction<Options extends { stream: true }>(
  email: string,
  reason: "curiosity" | "personal_finance",
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExtractReceiptInfoAction<Options extends { stream?: false }>(
  email: string,
  reason: "curiosity" | "personal_finance",
  options?: Options
): Promise<ReceiptInfo>;

export async function ExtractReceiptInfoAction<Options extends { stream?: boolean }>(
  email: string,
  reason: "curiosity" | "personal_finance",
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : ReceiptInfo> {
  if (options?.stream) {
    const stream = b.stream.ExtractReceiptInfo(
      email,
      reason,
    );
    return stream.toStreamable();
  }
  return b.ExtractReceiptInfo(
    email,
    reason,
  );
};

/**
 * Server action for the ExtractResume BAML function.
 *
 * Input Types:
 *
 * - resume: string
 *
 * - img (optional): Image | null
 *
 *
 * Return Type:
 * - Non-streaming: Resume
 * - Streaming: ReadableStream
 */
 export async function ExtractResumeAction<Options extends { stream: true }>(
  resume: string,
  img?: Image | null,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExtractResumeAction<Options extends { stream?: false }>(
  resume: string,
  img?: Image | null,
  options?: Options
): Promise<Resume>;

export async function ExtractResumeAction<Options extends { stream?: boolean }>(
  resume: string,
  img?: Image | null,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Resume> {
  if (options?.stream) {
    const stream = b.stream.ExtractResume(
      resume,
      img,
    );
    return stream.toStreamable();
  }
  return b.ExtractResume(
    resume,
    img,
  );
};

/**
 * Server action for the ExtractResume2 BAML function.
 *
 * Input Types:
 *
 * - resume: string
 *
 *
 * Return Type:
 * - Non-streaming: Resume
 * - Streaming: ReadableStream
 */
 export async function ExtractResume2Action<Options extends { stream: true }>(
  resume: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ExtractResume2Action<Options extends { stream?: false }>(
  resume: string,
  options?: Options
): Promise<Resume>;

export async function ExtractResume2Action<Options extends { stream?: boolean }>(
  resume: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Resume> {
  if (options?.stream) {
    const stream = b.stream.ExtractResume2(
      resume,
    );
    return stream.toStreamable();
  }
  return b.ExtractResume2(
    resume,
  );
};

/**
 * Server action for the FnClassOptionalOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: ClassOptionalOutput | null
 * - Streaming: ReadableStream
 */
 export async function FnClassOptionalOutputAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnClassOptionalOutputAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<ClassOptionalOutput | null>;

export async function FnClassOptionalOutputAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : ClassOptionalOutput | null> {
  if (options?.stream) {
    const stream = b.stream.FnClassOptionalOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnClassOptionalOutput(
    input,
  );
};

/**
 * Server action for the FnClassOptionalOutput2 BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: ClassOptionalOutput2 | null
 * - Streaming: ReadableStream
 */
 export async function FnClassOptionalOutput2Action<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnClassOptionalOutput2Action<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<ClassOptionalOutput2 | null>;

export async function FnClassOptionalOutput2Action<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : ClassOptionalOutput2 | null> {
  if (options?.stream) {
    const stream = b.stream.FnClassOptionalOutput2(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnClassOptionalOutput2(
    input,
  );
};

/**
 * Server action for the FnEnumListOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: EnumOutput[]
 * - Streaming: ReadableStream
 */
 export async function FnEnumListOutputAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnEnumListOutputAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<EnumOutput[]>;

export async function FnEnumListOutputAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : EnumOutput[]> {
  if (options?.stream) {
    const stream = b.stream.FnEnumListOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnEnumListOutput(
    input,
  );
};

/**
 * Server action for the FnEnumOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: EnumOutput
 * - Streaming: ReadableStream
 */
 export async function FnEnumOutputAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnEnumOutputAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<EnumOutput>;

export async function FnEnumOutputAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : EnumOutput> {
  if (options?.stream) {
    const stream = b.stream.FnEnumOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnEnumOutput(
    input,
  );
};

/**
 * Server action for the FnLiteralClassInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: LiteralClassHello
 *
 *
 * Return Type:
 * - Non-streaming: LiteralClassHello
 * - Streaming: ReadableStream
 */
 export async function FnLiteralClassInputOutputAction<Options extends { stream: true }>(
  input: LiteralClassHello,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnLiteralClassInputOutputAction<Options extends { stream?: false }>(
  input: LiteralClassHello,
  options?: Options
): Promise<LiteralClassHello>;

export async function FnLiteralClassInputOutputAction<Options extends { stream?: boolean }>(
  input: LiteralClassHello,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : LiteralClassHello> {
  if (options?.stream) {
    const stream = b.stream.FnLiteralClassInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnLiteralClassInputOutput(
    input,
  );
};

/**
 * Server action for the FnLiteralUnionClassInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: LiteralClassOne | LiteralClassTwo
 *
 *
 * Return Type:
 * - Non-streaming: LiteralClassOne | LiteralClassTwo
 * - Streaming: ReadableStream
 */
 export async function FnLiteralUnionClassInputOutputAction<Options extends { stream: true }>(
  input: LiteralClassOne | LiteralClassTwo,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnLiteralUnionClassInputOutputAction<Options extends { stream?: false }>(
  input: LiteralClassOne | LiteralClassTwo,
  options?: Options
): Promise<LiteralClassOne | LiteralClassTwo>;

export async function FnLiteralUnionClassInputOutputAction<Options extends { stream?: boolean }>(
  input: LiteralClassOne | LiteralClassTwo,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : LiteralClassOne | LiteralClassTwo> {
  if (options?.stream) {
    const stream = b.stream.FnLiteralUnionClassInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnLiteralUnionClassInputOutput(
    input,
  );
};

/**
 * Server action for the FnNamedArgsSingleStringOptional BAML function.
 *
 * Input Types:
 *
 * - myString (optional): string | null
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function FnNamedArgsSingleStringOptionalAction<Options extends { stream: true }>(
  myString?: string | null,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnNamedArgsSingleStringOptionalAction<Options extends { stream?: false }>(
  myString?: string | null,
  options?: Options
): Promise<string>;

export async function FnNamedArgsSingleStringOptionalAction<Options extends { stream?: boolean }>(
  myString?: string | null,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.FnNamedArgsSingleStringOptional(
      myString,
    );
    return stream.toStreamable();
  }
  return b.FnNamedArgsSingleStringOptional(
    myString,
  );
};

/**
 * Server action for the FnOutputBool BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: boolean
 * - Streaming: ReadableStream
 */
 export async function FnOutputBoolAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputBoolAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<boolean>;

export async function FnOutputBoolAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : boolean> {
  if (options?.stream) {
    const stream = b.stream.FnOutputBool(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputBool(
    input,
  );
};

/**
 * Server action for the FnOutputClass BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestOutputClass
 * - Streaming: ReadableStream
 */
 export async function FnOutputClassAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputClassAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<TestOutputClass>;

export async function FnOutputClassAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : TestOutputClass> {
  if (options?.stream) {
    const stream = b.stream.FnOutputClass(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClass(
    input,
  );
};

/**
 * Server action for the FnOutputClassList BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestOutputClass[]
 * - Streaming: ReadableStream
 */
 export async function FnOutputClassListAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputClassListAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<TestOutputClass[]>;

export async function FnOutputClassListAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : TestOutputClass[]> {
  if (options?.stream) {
    const stream = b.stream.FnOutputClassList(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClassList(
    input,
  );
};

/**
 * Server action for the FnOutputClassNested BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassNested
 * - Streaming: ReadableStream
 */
 export async function FnOutputClassNestedAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputClassNestedAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<TestClassNested>;

export async function FnOutputClassNestedAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : TestClassNested> {
  if (options?.stream) {
    const stream = b.stream.FnOutputClassNested(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClassNested(
    input,
  );
};

/**
 * Server action for the FnOutputClassWithEnum BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassWithEnum
 * - Streaming: ReadableStream
 */
 export async function FnOutputClassWithEnumAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputClassWithEnumAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<TestClassWithEnum>;

export async function FnOutputClassWithEnumAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : TestClassWithEnum> {
  if (options?.stream) {
    const stream = b.stream.FnOutputClassWithEnum(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClassWithEnum(
    input,
  );
};

/**
 * Server action for the FnOutputInt BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
 export async function FnOutputIntAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputIntAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<number>;

export async function FnOutputIntAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number> {
  if (options?.stream) {
    const stream = b.stream.FnOutputInt(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputInt(
    input,
  );
};

/**
 * Server action for the FnOutputLiteralBool BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: false
 * - Streaming: ReadableStream
 */
 export async function FnOutputLiteralBoolAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputLiteralBoolAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<false>;

export async function FnOutputLiteralBoolAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : false> {
  if (options?.stream) {
    const stream = b.stream.FnOutputLiteralBool(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputLiteralBool(
    input,
  );
};

/**
 * Server action for the FnOutputLiteralInt BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: 5
 * - Streaming: ReadableStream
 */
 export async function FnOutputLiteralIntAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputLiteralIntAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<5>;

export async function FnOutputLiteralIntAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : 5> {
  if (options?.stream) {
    const stream = b.stream.FnOutputLiteralInt(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputLiteralInt(
    input,
  );
};

/**
 * Server action for the FnOutputLiteralString BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: "example output"
 * - Streaming: ReadableStream
 */
 export async function FnOutputLiteralStringAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputLiteralStringAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<"example output">;

export async function FnOutputLiteralStringAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : "example output"> {
  if (options?.stream) {
    const stream = b.stream.FnOutputLiteralString(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputLiteralString(
    input,
  );
};

/**
 * Server action for the FnOutputStringList BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string[]
 * - Streaming: ReadableStream
 */
 export async function FnOutputStringListAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnOutputStringListAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string[]>;

export async function FnOutputStringListAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string[]> {
  if (options?.stream) {
    const stream = b.stream.FnOutputStringList(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputStringList(
    input,
  );
};

/**
 * Server action for the FnTestAliasedEnumOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestEnum
 * - Streaming: ReadableStream
 */
 export async function FnTestAliasedEnumOutputAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnTestAliasedEnumOutputAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<TestEnum>;

export async function FnTestAliasedEnumOutputAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : TestEnum> {
  if (options?.stream) {
    const stream = b.stream.FnTestAliasedEnumOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnTestAliasedEnumOutput(
    input,
  );
};

/**
 * Server action for the FnTestClassAlias BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassAlias
 * - Streaming: ReadableStream
 */
 export async function FnTestClassAliasAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnTestClassAliasAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<TestClassAlias>;

export async function FnTestClassAliasAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : TestClassAlias> {
  if (options?.stream) {
    const stream = b.stream.FnTestClassAlias(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnTestClassAlias(
    input,
  );
};

/**
 * Server action for the FnTestNamedArgsSingleEnum BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleEnum
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function FnTestNamedArgsSingleEnumAction<Options extends { stream: true }>(
  myArg: NamedArgsSingleEnum,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function FnTestNamedArgsSingleEnumAction<Options extends { stream?: false }>(
  myArg: NamedArgsSingleEnum,
  options?: Options
): Promise<string>;

export async function FnTestNamedArgsSingleEnumAction<Options extends { stream?: boolean }>(
  myArg: NamedArgsSingleEnum,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.FnTestNamedArgsSingleEnum(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.FnTestNamedArgsSingleEnum(
    myArg,
  );
};

/**
 * Server action for the GetDataType BAML function.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: RaysData
 * - Streaming: ReadableStream
 */
 export async function GetDataTypeAction<Options extends { stream: true }>(
  text: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function GetDataTypeAction<Options extends { stream?: false }>(
  text: string,
  options?: Options
): Promise<RaysData>;

export async function GetDataTypeAction<Options extends { stream?: boolean }>(
  text: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : RaysData> {
  if (options?.stream) {
    const stream = b.stream.GetDataType(
      text,
    );
    return stream.toStreamable();
  }
  return b.GetDataType(
    text,
  );
};

/**
 * Server action for the GetOrderInfo BAML function.
 *
 * Input Types:
 *
 * - email: Email
 *
 *
 * Return Type:
 * - Non-streaming: OrderInfo
 * - Streaming: ReadableStream
 */
 export async function GetOrderInfoAction<Options extends { stream: true }>(
  email: Email,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function GetOrderInfoAction<Options extends { stream?: false }>(
  email: Email,
  options?: Options
): Promise<OrderInfo>;

export async function GetOrderInfoAction<Options extends { stream?: boolean }>(
  email: Email,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : OrderInfo> {
  if (options?.stream) {
    const stream = b.stream.GetOrderInfo(
      email,
    );
    return stream.toStreamable();
  }
  return b.GetOrderInfo(
    email,
  );
};

/**
 * Server action for the GetQuery BAML function.
 *
 * Input Types:
 *
 * - query: string
 *
 *
 * Return Type:
 * - Non-streaming: SearchParams
 * - Streaming: ReadableStream
 */
 export async function GetQueryAction<Options extends { stream: true }>(
  query: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function GetQueryAction<Options extends { stream?: false }>(
  query: string,
  options?: Options
): Promise<SearchParams>;

export async function GetQueryAction<Options extends { stream?: boolean }>(
  query: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : SearchParams> {
  if (options?.stream) {
    const stream = b.stream.GetQuery(
      query,
    );
    return stream.toStreamable();
  }
  return b.GetQuery(
    query,
  );
};

/**
 * Server action for the InOutEnumMapKey BAML function.
 *
 * Input Types:
 *
 * - i1: Partial<Record<MapKey, string>>
 *
 * - i2: Partial<Record<MapKey, string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<MapKey, string>>
 * - Streaming: ReadableStream
 */
 export async function InOutEnumMapKeyAction<Options extends { stream: true }>(
  i1: Partial<Record<MapKey, string>>,
  i2: Partial<Record<MapKey, string>>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function InOutEnumMapKeyAction<Options extends { stream?: false }>(
  i1: Partial<Record<MapKey, string>>,
  i2: Partial<Record<MapKey, string>>,
  options?: Options
): Promise<Partial<Record<MapKey, string>>>;

export async function InOutEnumMapKeyAction<Options extends { stream?: boolean }>(
  i1: Partial<Record<MapKey, string>>,
  i2: Partial<Record<MapKey, string>>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Partial<Record<MapKey, string>>> {
  if (options?.stream) {
    const stream = b.stream.InOutEnumMapKey(
      i1,
      i2,
    );
    return stream.toStreamable();
  }
  return b.InOutEnumMapKey(
    i1,
    i2,
  );
};

/**
 * Server action for the InOutLiteralStringUnionMapKey BAML function.
 *
 * Input Types:
 *
 * - i1: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * - i2: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<"one" | "two" | "three" | "four", string>>
 * - Streaming: ReadableStream
 */
 export async function InOutLiteralStringUnionMapKeyAction<Options extends { stream: true }>(
  i1: Partial<Record<"one" | "two" | "three" | "four", string>>,
  i2: Partial<Record<"one" | "two" | "three" | "four", string>>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function InOutLiteralStringUnionMapKeyAction<Options extends { stream?: false }>(
  i1: Partial<Record<"one" | "two" | "three" | "four", string>>,
  i2: Partial<Record<"one" | "two" | "three" | "four", string>>,
  options?: Options
): Promise<Partial<Record<"one" | "two" | "three" | "four", string>>>;

export async function InOutLiteralStringUnionMapKeyAction<Options extends { stream?: boolean }>(
  i1: Partial<Record<"one" | "two" | "three" | "four", string>>,
  i2: Partial<Record<"one" | "two" | "three" | "four", string>>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Partial<Record<"one" | "two" | "three" | "four", string>>> {
  if (options?.stream) {
    const stream = b.stream.InOutLiteralStringUnionMapKey(
      i1,
      i2,
    );
    return stream.toStreamable();
  }
  return b.InOutLiteralStringUnionMapKey(
    i1,
    i2,
  );
};

/**
 * Server action for the InOutSingleLiteralStringMapKey BAML function.
 *
 * Input Types:
 *
 * - m: Partial<Record<"key", string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<"key", string>>
 * - Streaming: ReadableStream
 */
 export async function InOutSingleLiteralStringMapKeyAction<Options extends { stream: true }>(
  m: Partial<Record<"key", string>>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function InOutSingleLiteralStringMapKeyAction<Options extends { stream?: false }>(
  m: Partial<Record<"key", string>>,
  options?: Options
): Promise<Partial<Record<"key", string>>>;

export async function InOutSingleLiteralStringMapKeyAction<Options extends { stream?: boolean }>(
  m: Partial<Record<"key", string>>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Partial<Record<"key", string>>> {
  if (options?.stream) {
    const stream = b.stream.InOutSingleLiteralStringMapKey(
      m,
    );
    return stream.toStreamable();
  }
  return b.InOutSingleLiteralStringMapKey(
    m,
  );
};

/**
 * Server action for the JsonTypeAliasCycle BAML function.
 *
 * Input Types:
 *
 * - input: JsonValue
 *
 *
 * Return Type:
 * - Non-streaming: JsonValue
 * - Streaming: ReadableStream
 */
 export async function JsonTypeAliasCycleAction<Options extends { stream: true }>(
  input: JsonValue,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function JsonTypeAliasCycleAction<Options extends { stream?: false }>(
  input: JsonValue,
  options?: Options
): Promise<JsonValue>;

export async function JsonTypeAliasCycleAction<Options extends { stream?: boolean }>(
  input: JsonValue,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : JsonValue> {
  if (options?.stream) {
    const stream = b.stream.JsonTypeAliasCycle(
      input,
    );
    return stream.toStreamable();
  }
  return b.JsonTypeAliasCycle(
    input,
  );
};

/**
 * Server action for the LiteralUnionsTest BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: 1 | true | "string output"
 * - Streaming: ReadableStream
 */
 export async function LiteralUnionsTestAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function LiteralUnionsTestAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<1 | true | "string output">;

export async function LiteralUnionsTestAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : 1 | true | "string output"> {
  if (options?.stream) {
    const stream = b.stream.LiteralUnionsTest(
      input,
    );
    return stream.toStreamable();
  }
  return b.LiteralUnionsTest(
    input,
  );
};

/**
 * Server action for the MakeBlockConstraint BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: Checked<BlockConstraint,"cross_field">
 * - Streaming: ReadableStream
 */
 export async function MakeBlockConstraintAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function MakeBlockConstraintAction<Options extends { stream?: false }>(
  options?: Options
): Promise<Checked<BlockConstraint,"cross_field">>;

export async function MakeBlockConstraintAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Checked<BlockConstraint,"cross_field">> {
  if (options?.stream) {
    const stream = b.stream.MakeBlockConstraint(
    );
    return stream.toStreamable();
  }
  return b.MakeBlockConstraint(
  );
};

/**
 * Server action for the MakeNestedBlockConstraint BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: NestedBlockConstraint
 * - Streaming: ReadableStream
 */
 export async function MakeNestedBlockConstraintAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function MakeNestedBlockConstraintAction<Options extends { stream?: false }>(
  options?: Options
): Promise<NestedBlockConstraint>;

export async function MakeNestedBlockConstraintAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : NestedBlockConstraint> {
  if (options?.stream) {
    const stream = b.stream.MakeNestedBlockConstraint(
    );
    return stream.toStreamable();
  }
  return b.MakeNestedBlockConstraint(
  );
};

/**
 * Server action for the MapAlias BAML function.
 *
 * Input Types:
 *
 * - m: Record<string, string[]>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, string[]>
 * - Streaming: ReadableStream
 */
 export async function MapAliasAction<Options extends { stream: true }>(
  m: Record<string, string[]>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function MapAliasAction<Options extends { stream?: false }>(
  m: Record<string, string[]>,
  options?: Options
): Promise<Record<string, string[]>>;

export async function MapAliasAction<Options extends { stream?: boolean }>(
  m: Record<string, string[]>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Record<string, string[]>> {
  if (options?.stream) {
    const stream = b.stream.MapAlias(
      m,
    );
    return stream.toStreamable();
  }
  return b.MapAlias(
    m,
  );
};

/**
 * Server action for the MergeAliasAttributes BAML function.
 *
 * Input Types:
 *
 * - money: number
 *
 *
 * Return Type:
 * - Non-streaming: MergeAttrs
 * - Streaming: ReadableStream
 */
 export async function MergeAliasAttributesAction<Options extends { stream: true }>(
  money: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function MergeAliasAttributesAction<Options extends { stream?: false }>(
  money: number,
  options?: Options
): Promise<MergeAttrs>;

export async function MergeAliasAttributesAction<Options extends { stream?: boolean }>(
  money: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : MergeAttrs> {
  if (options?.stream) {
    const stream = b.stream.MergeAliasAttributes(
      money,
    );
    return stream.toStreamable();
  }
  return b.MergeAliasAttributes(
    money,
  );
};

/**
 * Server action for the MyFunc BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: DynamicOutput
 * - Streaming: ReadableStream
 */
 export async function MyFuncAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function MyFuncAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<DynamicOutput>;

export async function MyFuncAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : DynamicOutput> {
  if (options?.stream) {
    const stream = b.stream.MyFunc(
      input,
    );
    return stream.toStreamable();
  }
  return b.MyFunc(
    input,
  );
};

/**
 * Server action for the NestedAlias BAML function.
 *
 * Input Types:
 *
 * - c: number | string | boolean | number | string[] | Record<string, string[]>
 *
 *
 * Return Type:
 * - Non-streaming: number | string | boolean | number | string[] | Record<string, string[]>
 * - Streaming: ReadableStream
 */
 export async function NestedAliasAction<Options extends { stream: true }>(
  c: number | string | boolean | number | string[] | Record<string, string[]>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function NestedAliasAction<Options extends { stream?: false }>(
  c: number | string | boolean | number | string[] | Record<string, string[]>,
  options?: Options
): Promise<number | string | boolean | number | string[] | Record<string, string[]>>;

export async function NestedAliasAction<Options extends { stream?: boolean }>(
  c: number | string | boolean | number | string[] | Record<string, string[]>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number | string | boolean | number | string[] | Record<string, string[]>> {
  if (options?.stream) {
    const stream = b.stream.NestedAlias(
      c,
    );
    return stream.toStreamable();
  }
  return b.NestedAlias(
    c,
  );
};

/**
 * Server action for the OptionalTest_Function BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: (OptionalTest_ReturnType | null)[]
 * - Streaming: ReadableStream
 */
 export async function OptionalTest_FunctionAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function OptionalTest_FunctionAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<(OptionalTest_ReturnType | null)[]>;

export async function OptionalTest_FunctionAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : (OptionalTest_ReturnType | null)[]> {
  if (options?.stream) {
    const stream = b.stream.OptionalTest_Function(
      input,
    );
    return stream.toStreamable();
  }
  return b.OptionalTest_Function(
    input,
  );
};

/**
 * Server action for the PredictAge BAML function.
 *
 * Input Types:
 *
 * - name: string
 *
 *
 * Return Type:
 * - Non-streaming: FooAny
 * - Streaming: ReadableStream
 */
 export async function PredictAgeAction<Options extends { stream: true }>(
  name: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PredictAgeAction<Options extends { stream?: false }>(
  name: string,
  options?: Options
): Promise<FooAny>;

export async function PredictAgeAction<Options extends { stream?: boolean }>(
  name: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : FooAny> {
  if (options?.stream) {
    const stream = b.stream.PredictAge(
      name,
    );
    return stream.toStreamable();
  }
  return b.PredictAge(
    name,
  );
};

/**
 * Server action for the PredictAgeBare BAML function.
 *
 * Input Types:
 *
 * - inp: string
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"too_big">
 * - Streaming: ReadableStream
 */
 export async function PredictAgeBareAction<Options extends { stream: true }>(
  inp: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PredictAgeBareAction<Options extends { stream?: false }>(
  inp: string,
  options?: Options
): Promise<Checked<number,"too_big">>;

export async function PredictAgeBareAction<Options extends { stream?: boolean }>(
  inp: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Checked<number,"too_big">> {
  if (options?.stream) {
    const stream = b.stream.PredictAgeBare(
      inp,
    );
    return stream.toStreamable();
  }
  return b.PredictAgeBare(
    inp,
  );
};

/**
 * Server action for the PrimitiveAlias BAML function.
 *
 * Input Types:
 *
 * - p: number | string | boolean | number
 *
 *
 * Return Type:
 * - Non-streaming: number | string | boolean | number
 * - Streaming: ReadableStream
 */
 export async function PrimitiveAliasAction<Options extends { stream: true }>(
  p: number | string | boolean | number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PrimitiveAliasAction<Options extends { stream?: false }>(
  p: number | string | boolean | number,
  options?: Options
): Promise<number | string | boolean | number>;

export async function PrimitiveAliasAction<Options extends { stream?: boolean }>(
  p: number | string | boolean | number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number | string | boolean | number> {
  if (options?.stream) {
    const stream = b.stream.PrimitiveAlias(
      p,
    );
    return stream.toStreamable();
  }
  return b.PrimitiveAlias(
    p,
  );
};

/**
 * Server action for the PromptTestClaude BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function PromptTestClaudeAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PromptTestClaudeAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function PromptTestClaudeAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.PromptTestClaude(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestClaude(
    input,
  );
};

/**
 * Server action for the PromptTestClaudeChat BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function PromptTestClaudeChatAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PromptTestClaudeChatAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function PromptTestClaudeChatAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.PromptTestClaudeChat(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestClaudeChat(
    input,
  );
};

/**
 * Server action for the PromptTestClaudeChatNoSystem BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function PromptTestClaudeChatNoSystemAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PromptTestClaudeChatNoSystemAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function PromptTestClaudeChatNoSystemAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.PromptTestClaudeChatNoSystem(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestClaudeChatNoSystem(
    input,
  );
};

/**
 * Server action for the PromptTestOpenAI BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function PromptTestOpenAIAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PromptTestOpenAIAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function PromptTestOpenAIAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.PromptTestOpenAI(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestOpenAI(
    input,
  );
};

/**
 * Server action for the PromptTestOpenAIChat BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function PromptTestOpenAIChatAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PromptTestOpenAIChatAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function PromptTestOpenAIChatAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.PromptTestOpenAIChat(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestOpenAIChat(
    input,
  );
};

/**
 * Server action for the PromptTestOpenAIChatNoSystem BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function PromptTestOpenAIChatNoSystemAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PromptTestOpenAIChatNoSystemAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function PromptTestOpenAIChatNoSystemAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.PromptTestOpenAIChatNoSystem(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestOpenAIChatNoSystem(
    input,
  );
};

/**
 * Server action for the PromptTestStreaming BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function PromptTestStreamingAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function PromptTestStreamingAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function PromptTestStreamingAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.PromptTestStreaming(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestStreaming(
    input,
  );
};

/**
 * Server action for the RecursiveAliasCycle BAML function.
 *
 * Input Types:
 *
 * - input: RecAliasOne
 *
 *
 * Return Type:
 * - Non-streaming: RecAliasOne
 * - Streaming: ReadableStream
 */
 export async function RecursiveAliasCycleAction<Options extends { stream: true }>(
  input: RecAliasOne,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function RecursiveAliasCycleAction<Options extends { stream?: false }>(
  input: RecAliasOne,
  options?: Options
): Promise<RecAliasOne>;

export async function RecursiveAliasCycleAction<Options extends { stream?: boolean }>(
  input: RecAliasOne,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : RecAliasOne> {
  if (options?.stream) {
    const stream = b.stream.RecursiveAliasCycle(
      input,
    );
    return stream.toStreamable();
  }
  return b.RecursiveAliasCycle(
    input,
  );
};

/**
 * Server action for the RecursiveClassWithAliasIndirection BAML function.
 *
 * Input Types:
 *
 * - cls: NodeWithAliasIndirection
 *
 *
 * Return Type:
 * - Non-streaming: NodeWithAliasIndirection
 * - Streaming: ReadableStream
 */
 export async function RecursiveClassWithAliasIndirectionAction<Options extends { stream: true }>(
  cls: NodeWithAliasIndirection,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function RecursiveClassWithAliasIndirectionAction<Options extends { stream?: false }>(
  cls: NodeWithAliasIndirection,
  options?: Options
): Promise<NodeWithAliasIndirection>;

export async function RecursiveClassWithAliasIndirectionAction<Options extends { stream?: boolean }>(
  cls: NodeWithAliasIndirection,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : NodeWithAliasIndirection> {
  if (options?.stream) {
    const stream = b.stream.RecursiveClassWithAliasIndirection(
      cls,
    );
    return stream.toStreamable();
  }
  return b.RecursiveClassWithAliasIndirection(
    cls,
  );
};

/**
 * Server action for the ReturnAliasWithMergedAttributes BAML function.
 *
 * Input Types:
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"gt_ten">
 * - Streaming: ReadableStream
 */
 export async function ReturnAliasWithMergedAttributesAction<Options extends { stream: true }>(
  money: Checked<number,"gt_ten">,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ReturnAliasWithMergedAttributesAction<Options extends { stream?: false }>(
  money: Checked<number,"gt_ten">,
  options?: Options
): Promise<Checked<number,"gt_ten">>;

export async function ReturnAliasWithMergedAttributesAction<Options extends { stream?: boolean }>(
  money: Checked<number,"gt_ten">,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Checked<number,"gt_ten">> {
  if (options?.stream) {
    const stream = b.stream.ReturnAliasWithMergedAttributes(
      money,
    );
    return stream.toStreamable();
  }
  return b.ReturnAliasWithMergedAttributes(
    money,
  );
};

/**
 * Server action for the ReturnFailingAssert BAML function.
 *
 * Input Types:
 *
 * - inp: number
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
 export async function ReturnFailingAssertAction<Options extends { stream: true }>(
  inp: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ReturnFailingAssertAction<Options extends { stream?: false }>(
  inp: number,
  options?: Options
): Promise<number>;

export async function ReturnFailingAssertAction<Options extends { stream?: boolean }>(
  inp: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number> {
  if (options?.stream) {
    const stream = b.stream.ReturnFailingAssert(
      inp,
    );
    return stream.toStreamable();
  }
  return b.ReturnFailingAssert(
    inp,
  );
};

/**
 * Server action for the ReturnMalformedConstraints BAML function.
 *
 * Input Types:
 *
 * - a: number
 *
 *
 * Return Type:
 * - Non-streaming: MalformedConstraints
 * - Streaming: ReadableStream
 */
 export async function ReturnMalformedConstraintsAction<Options extends { stream: true }>(
  a: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function ReturnMalformedConstraintsAction<Options extends { stream?: false }>(
  a: number,
  options?: Options
): Promise<MalformedConstraints>;

export async function ReturnMalformedConstraintsAction<Options extends { stream?: boolean }>(
  a: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : MalformedConstraints> {
  if (options?.stream) {
    const stream = b.stream.ReturnMalformedConstraints(
      a,
    );
    return stream.toStreamable();
  }
  return b.ReturnMalformedConstraints(
    a,
  );
};

/**
 * Server action for the SchemaDescriptions BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Schema
 * - Streaming: ReadableStream
 */
 export async function SchemaDescriptionsAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function SchemaDescriptionsAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<Schema>;

export async function SchemaDescriptionsAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Schema> {
  if (options?.stream) {
    const stream = b.stream.SchemaDescriptions(
      input,
    );
    return stream.toStreamable();
  }
  return b.SchemaDescriptions(
    input,
  );
};

/**
 * Server action for the SimpleRecursiveListAlias BAML function.
 *
 * Input Types:
 *
 * - input: RecursiveListAlias
 *
 *
 * Return Type:
 * - Non-streaming: RecursiveListAlias
 * - Streaming: ReadableStream
 */
 export async function SimpleRecursiveListAliasAction<Options extends { stream: true }>(
  input: RecursiveListAlias,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function SimpleRecursiveListAliasAction<Options extends { stream?: false }>(
  input: RecursiveListAlias,
  options?: Options
): Promise<RecursiveListAlias>;

export async function SimpleRecursiveListAliasAction<Options extends { stream?: boolean }>(
  input: RecursiveListAlias,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : RecursiveListAlias> {
  if (options?.stream) {
    const stream = b.stream.SimpleRecursiveListAlias(
      input,
    );
    return stream.toStreamable();
  }
  return b.SimpleRecursiveListAlias(
    input,
  );
};

/**
 * Server action for the SimpleRecursiveMapAlias BAML function.
 *
 * Input Types:
 *
 * - input: RecursiveMapAlias
 *
 *
 * Return Type:
 * - Non-streaming: RecursiveMapAlias
 * - Streaming: ReadableStream
 */
 export async function SimpleRecursiveMapAliasAction<Options extends { stream: true }>(
  input: RecursiveMapAlias,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function SimpleRecursiveMapAliasAction<Options extends { stream?: false }>(
  input: RecursiveMapAlias,
  options?: Options
): Promise<RecursiveMapAlias>;

export async function SimpleRecursiveMapAliasAction<Options extends { stream?: boolean }>(
  input: RecursiveMapAlias,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : RecursiveMapAlias> {
  if (options?.stream) {
    const stream = b.stream.SimpleRecursiveMapAlias(
      input,
    );
    return stream.toStreamable();
  }
  return b.SimpleRecursiveMapAlias(
    input,
  );
};

/**
 * Server action for the StreamBigNumbers BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: BigNumbers
 * - Streaming: ReadableStream
 */
 export async function StreamBigNumbersAction<Options extends { stream: true }>(
  digits: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function StreamBigNumbersAction<Options extends { stream?: false }>(
  digits: number,
  options?: Options
): Promise<BigNumbers>;

export async function StreamBigNumbersAction<Options extends { stream?: boolean }>(
  digits: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : BigNumbers> {
  if (options?.stream) {
    const stream = b.stream.StreamBigNumbers(
      digits,
    );
    return stream.toStreamable();
  }
  return b.StreamBigNumbers(
    digits,
  );
};

/**
 * Server action for the StreamFailingAssertion BAML function.
 *
 * Input Types:
 *
 * - theme: string
 *
 * - length: number
 *
 *
 * Return Type:
 * - Non-streaming: TwoStoriesOneTitle
 * - Streaming: ReadableStream
 */
 export async function StreamFailingAssertionAction<Options extends { stream: true }>(
  theme: string,
  length: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function StreamFailingAssertionAction<Options extends { stream?: false }>(
  theme: string,
  length: number,
  options?: Options
): Promise<TwoStoriesOneTitle>;

export async function StreamFailingAssertionAction<Options extends { stream?: boolean }>(
  theme: string,
  length: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : TwoStoriesOneTitle> {
  if (options?.stream) {
    const stream = b.stream.StreamFailingAssertion(
      theme,
      length,
    );
    return stream.toStreamable();
  }
  return b.StreamFailingAssertion(
    theme,
    length,
  );
};

/**
 * Server action for the StreamOneBigNumber BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
 export async function StreamOneBigNumberAction<Options extends { stream: true }>(
  digits: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function StreamOneBigNumberAction<Options extends { stream?: false }>(
  digits: number,
  options?: Options
): Promise<number>;

export async function StreamOneBigNumberAction<Options extends { stream?: boolean }>(
  digits: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number> {
  if (options?.stream) {
    const stream = b.stream.StreamOneBigNumber(
      digits,
    );
    return stream.toStreamable();
  }
  return b.StreamOneBigNumber(
    digits,
  );
};

/**
 * Server action for the StreamUnionIntegers BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: (number | string)[]
 * - Streaming: ReadableStream
 */
 export async function StreamUnionIntegersAction<Options extends { stream: true }>(
  digits: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function StreamUnionIntegersAction<Options extends { stream?: false }>(
  digits: number,
  options?: Options
): Promise<(number | string)[]>;

export async function StreamUnionIntegersAction<Options extends { stream?: boolean }>(
  digits: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : (number | string)[]> {
  if (options?.stream) {
    const stream = b.stream.StreamUnionIntegers(
      digits,
    );
    return stream.toStreamable();
  }
  return b.StreamUnionIntegers(
    digits,
  );
};

/**
 * Server action for the StreamingCompoundNumbers BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 * - yapping: boolean
 *
 *
 * Return Type:
 * - Non-streaming: CompoundBigNumbers
 * - Streaming: ReadableStream
 */
 export async function StreamingCompoundNumbersAction<Options extends { stream: true }>(
  digits: number,
  yapping: boolean,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function StreamingCompoundNumbersAction<Options extends { stream?: false }>(
  digits: number,
  yapping: boolean,
  options?: Options
): Promise<CompoundBigNumbers>;

export async function StreamingCompoundNumbersAction<Options extends { stream?: boolean }>(
  digits: number,
  yapping: boolean,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : CompoundBigNumbers> {
  if (options?.stream) {
    const stream = b.stream.StreamingCompoundNumbers(
      digits,
      yapping,
    );
    return stream.toStreamable();
  }
  return b.StreamingCompoundNumbers(
    digits,
    yapping,
  );
};

/**
 * Server action for the TestAnthropic BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAnthropicAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAnthropicAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAnthropicAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAnthropic(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAnthropic(
    input,
  );
};

/**
 * Server action for the TestAnthropicShorthand BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAnthropicShorthandAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAnthropicShorthandAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAnthropicShorthandAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAnthropicShorthand(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAnthropicShorthand(
    input,
  );
};

/**
 * Server action for the TestAws BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAwsAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAwsAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAwsAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAws(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAws(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidAccessKey BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAwsInvalidAccessKeyAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAwsInvalidAccessKeyAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAwsInvalidAccessKeyAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidAccessKey(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidAccessKey(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidProfile BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAwsInvalidProfileAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAwsInvalidProfileAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAwsInvalidProfileAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidProfile(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidProfile(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidRegion BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAwsInvalidRegionAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAwsInvalidRegionAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAwsInvalidRegionAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidRegion(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidRegion(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidSessionToken BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAwsInvalidSessionTokenAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAwsInvalidSessionTokenAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAwsInvalidSessionTokenAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidSessionToken(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidSessionToken(
    input,
  );
};

/**
 * Server action for the TestAzure BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAzureAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAzureAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAzureAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAzure(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAzure(
    input,
  );
};

/**
 * Server action for the TestAzureFailure BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestAzureFailureAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestAzureFailureAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestAzureFailureAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestAzureFailure(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAzureFailure(
    input,
  );
};

/**
 * Server action for the TestCaching BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 * - not_cached: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestCachingAction<Options extends { stream: true }>(
  input: string,
  not_cached: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestCachingAction<Options extends { stream?: false }>(
  input: string,
  not_cached: string,
  options?: Options
): Promise<string>;

export async function TestCachingAction<Options extends { stream?: boolean }>(
  input: string,
  not_cached: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestCaching(
      input,
      not_cached,
    );
    return stream.toStreamable();
  }
  return b.TestCaching(
    input,
    not_cached,
  );
};

/**
 * Server action for the TestFallbackClient BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFallbackClientAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFallbackClientAction<Options extends { stream?: false }>(
  options?: Options
): Promise<string>;

export async function TestFallbackClientAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFallbackClient(
    );
    return stream.toStreamable();
  }
  return b.TestFallbackClient(
  );
};

/**
 * Server action for the TestFallbackToShorthand BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFallbackToShorthandAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFallbackToShorthandAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestFallbackToShorthandAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFallbackToShorthand(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestFallbackToShorthand(
    input,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleBool BAML function.
 *
 * Input Types:
 *
 * - myBool: boolean
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleBoolAction<Options extends { stream: true }>(
  myBool: boolean,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleBoolAction<Options extends { stream?: false }>(
  myBool: boolean,
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleBoolAction<Options extends { stream?: boolean }>(
  myBool: boolean,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleBool(
      myBool,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleBool(
    myBool,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleClass BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleClassAction<Options extends { stream: true }>(
  myArg: NamedArgsSingleClass,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleClassAction<Options extends { stream?: false }>(
  myArg: NamedArgsSingleClass,
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleClassAction<Options extends { stream?: boolean }>(
  myArg: NamedArgsSingleClass,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleClass(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleClass(
    myArg,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleEnumList BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleEnumList[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleEnumListAction<Options extends { stream: true }>(
  myArg: NamedArgsSingleEnumList[],
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleEnumListAction<Options extends { stream?: false }>(
  myArg: NamedArgsSingleEnumList[],
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleEnumListAction<Options extends { stream?: boolean }>(
  myArg: NamedArgsSingleEnumList[],
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleEnumList(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleEnumList(
    myArg,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleFloat BAML function.
 *
 * Input Types:
 *
 * - myFloat: number
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleFloatAction<Options extends { stream: true }>(
  myFloat: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleFloatAction<Options extends { stream?: false }>(
  myFloat: number,
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleFloatAction<Options extends { stream?: boolean }>(
  myFloat: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleFloat(
      myFloat,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleFloat(
    myFloat,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleInt BAML function.
 *
 * Input Types:
 *
 * - myInt: number
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleIntAction<Options extends { stream: true }>(
  myInt: number,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleIntAction<Options extends { stream?: false }>(
  myInt: number,
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleIntAction<Options extends { stream?: boolean }>(
  myInt: number,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleInt(
      myInt,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleInt(
    myInt,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleMapStringToClass BAML function.
 *
 * Input Types:
 *
 * - myMap: Record<string, StringToClassEntry>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, StringToClassEntry>
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleMapStringToClassAction<Options extends { stream: true }>(
  myMap: Record<string, StringToClassEntry>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleMapStringToClassAction<Options extends { stream?: false }>(
  myMap: Record<string, StringToClassEntry>,
  options?: Options
): Promise<Record<string, StringToClassEntry>>;

export async function TestFnNamedArgsSingleMapStringToClassAction<Options extends { stream?: boolean }>(
  myMap: Record<string, StringToClassEntry>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Record<string, StringToClassEntry>> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleMapStringToClass(
      myMap,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleMapStringToClass(
    myMap,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleMapStringToMap BAML function.
 *
 * Input Types:
 *
 * - myMap: Record<string, Record<string, string>>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, Record<string, string>>
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleMapStringToMapAction<Options extends { stream: true }>(
  myMap: Record<string, Record<string, string>>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleMapStringToMapAction<Options extends { stream?: false }>(
  myMap: Record<string, Record<string, string>>,
  options?: Options
): Promise<Record<string, Record<string, string>>>;

export async function TestFnNamedArgsSingleMapStringToMapAction<Options extends { stream?: boolean }>(
  myMap: Record<string, Record<string, string>>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Record<string, Record<string, string>>> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleMapStringToMap(
      myMap,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleMapStringToMap(
    myMap,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleMapStringToString BAML function.
 *
 * Input Types:
 *
 * - myMap: Record<string, string>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, string>
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleMapStringToStringAction<Options extends { stream: true }>(
  myMap: Record<string, string>,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleMapStringToStringAction<Options extends { stream?: false }>(
  myMap: Record<string, string>,
  options?: Options
): Promise<Record<string, string>>;

export async function TestFnNamedArgsSingleMapStringToStringAction<Options extends { stream?: boolean }>(
  myMap: Record<string, string>,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : Record<string, string>> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleMapStringToString(
      myMap,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleMapStringToString(
    myMap,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleString BAML function.
 *
 * Input Types:
 *
 * - myString: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleStringAction<Options extends { stream: true }>(
  myString: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleStringAction<Options extends { stream?: false }>(
  myString: string,
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleStringAction<Options extends { stream?: boolean }>(
  myString: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleString(
      myString,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleString(
    myString,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleStringArray BAML function.
 *
 * Input Types:
 *
 * - myStringArray: string[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleStringArrayAction<Options extends { stream: true }>(
  myStringArray: string[],
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleStringArrayAction<Options extends { stream?: false }>(
  myStringArray: string[],
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleStringArrayAction<Options extends { stream?: boolean }>(
  myStringArray: string[],
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleStringArray(
      myStringArray,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleStringArray(
    myStringArray,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleStringList BAML function.
 *
 * Input Types:
 *
 * - myArg: string[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestFnNamedArgsSingleStringListAction<Options extends { stream: true }>(
  myArg: string[],
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestFnNamedArgsSingleStringListAction<Options extends { stream?: false }>(
  myArg: string[],
  options?: Options
): Promise<string>;

export async function TestFnNamedArgsSingleStringListAction<Options extends { stream?: boolean }>(
  myArg: string[],
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleStringList(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleStringList(
    myArg,
  );
};

/**
 * Server action for the TestGemini BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestGeminiAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestGeminiAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestGeminiAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestGemini(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestGemini(
    input,
  );
};

/**
 * Server action for the TestImageInput BAML function.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestImageInputAction<Options extends { stream: true }>(
  img: Image,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestImageInputAction<Options extends { stream?: false }>(
  img: Image,
  options?: Options
): Promise<string>;

export async function TestImageInputAction<Options extends { stream?: boolean }>(
  img: Image,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestImageInput(
      img,
    );
    return stream.toStreamable();
  }
  return b.TestImageInput(
    img,
  );
};

/**
 * Server action for the TestImageInputAnthropic BAML function.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestImageInputAnthropicAction<Options extends { stream: true }>(
  img: Image,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestImageInputAnthropicAction<Options extends { stream?: false }>(
  img: Image,
  options?: Options
): Promise<string>;

export async function TestImageInputAnthropicAction<Options extends { stream?: boolean }>(
  img: Image,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestImageInputAnthropic(
      img,
    );
    return stream.toStreamable();
  }
  return b.TestImageInputAnthropic(
    img,
  );
};

/**
 * Server action for the TestImageListInput BAML function.
 *
 * Input Types:
 *
 * - imgs: Image[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestImageListInputAction<Options extends { stream: true }>(
  imgs: Image[],
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestImageListInputAction<Options extends { stream?: false }>(
  imgs: Image[],
  options?: Options
): Promise<string>;

export async function TestImageListInputAction<Options extends { stream?: boolean }>(
  imgs: Image[],
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestImageListInput(
      imgs,
    );
    return stream.toStreamable();
  }
  return b.TestImageListInput(
    imgs,
  );
};

/**
 * Server action for the TestMulticlassNamedArgs BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleClass
 *
 * - myArg2: NamedArgsSingleClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestMulticlassNamedArgsAction<Options extends { stream: true }>(
  myArg: NamedArgsSingleClass,
  myArg2: NamedArgsSingleClass,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestMulticlassNamedArgsAction<Options extends { stream?: false }>(
  myArg: NamedArgsSingleClass,
  myArg2: NamedArgsSingleClass,
  options?: Options
): Promise<string>;

export async function TestMulticlassNamedArgsAction<Options extends { stream?: boolean }>(
  myArg: NamedArgsSingleClass,
  myArg2: NamedArgsSingleClass,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestMulticlassNamedArgs(
      myArg,
      myArg2,
    );
    return stream.toStreamable();
  }
  return b.TestMulticlassNamedArgs(
    myArg,
    myArg2,
  );
};

/**
 * Server action for the TestNamedArgsLiteralBool BAML function.
 *
 * Input Types:
 *
 * - myBool: true
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestNamedArgsLiteralBoolAction<Options extends { stream: true }>(
  myBool: true,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestNamedArgsLiteralBoolAction<Options extends { stream?: false }>(
  myBool: true,
  options?: Options
): Promise<string>;

export async function TestNamedArgsLiteralBoolAction<Options extends { stream?: boolean }>(
  myBool: true,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestNamedArgsLiteralBool(
      myBool,
    );
    return stream.toStreamable();
  }
  return b.TestNamedArgsLiteralBool(
    myBool,
  );
};

/**
 * Server action for the TestNamedArgsLiteralInt BAML function.
 *
 * Input Types:
 *
 * - myInt: 1
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestNamedArgsLiteralIntAction<Options extends { stream: true }>(
  myInt: 1,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestNamedArgsLiteralIntAction<Options extends { stream?: false }>(
  myInt: 1,
  options?: Options
): Promise<string>;

export async function TestNamedArgsLiteralIntAction<Options extends { stream?: boolean }>(
  myInt: 1,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestNamedArgsLiteralInt(
      myInt,
    );
    return stream.toStreamable();
  }
  return b.TestNamedArgsLiteralInt(
    myInt,
  );
};

/**
 * Server action for the TestNamedArgsLiteralString BAML function.
 *
 * Input Types:
 *
 * - myString: "My String"
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestNamedArgsLiteralStringAction<Options extends { stream: true }>(
  myString: "My String",
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestNamedArgsLiteralStringAction<Options extends { stream?: false }>(
  myString: "My String",
  options?: Options
): Promise<string>;

export async function TestNamedArgsLiteralStringAction<Options extends { stream?: boolean }>(
  myString: "My String",
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestNamedArgsLiteralString(
      myString,
    );
    return stream.toStreamable();
  }
  return b.TestNamedArgsLiteralString(
    myString,
  );
};

/**
 * Server action for the TestOllama BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestOllamaAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestOllamaAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestOllamaAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestOllama(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestOllama(
    input,
  );
};

/**
 * Server action for the TestOpenAILegacyProvider BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestOpenAILegacyProviderAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestOpenAILegacyProviderAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestOpenAILegacyProviderAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestOpenAILegacyProvider(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestOpenAILegacyProvider(
    input,
  );
};

/**
 * Server action for the TestOpenAIShorthand BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestOpenAIShorthandAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestOpenAIShorthandAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestOpenAIShorthandAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestOpenAIShorthand(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestOpenAIShorthand(
    input,
  );
};

/**
 * Server action for the TestRetryConstant BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestRetryConstantAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestRetryConstantAction<Options extends { stream?: false }>(
  options?: Options
): Promise<string>;

export async function TestRetryConstantAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestRetryConstant(
    );
    return stream.toStreamable();
  }
  return b.TestRetryConstant(
  );
};

/**
 * Server action for the TestRetryExponential BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestRetryExponentialAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestRetryExponentialAction<Options extends { stream?: false }>(
  options?: Options
): Promise<string>;

export async function TestRetryExponentialAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestRetryExponential(
    );
    return stream.toStreamable();
  }
  return b.TestRetryExponential(
  );
};

/**
 * Server action for the TestSingleFallbackClient BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestSingleFallbackClientAction<Options extends { stream: true }>(
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestSingleFallbackClientAction<Options extends { stream?: false }>(
  options?: Options
): Promise<string>;

export async function TestSingleFallbackClientAction<Options extends { stream?: boolean }>(
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestSingleFallbackClient(
    );
    return stream.toStreamable();
  }
  return b.TestSingleFallbackClient(
  );
};

/**
 * Server action for the TestUniverseQuestion BAML function.
 *
 * Input Types:
 *
 * - question: UniverseQuestionInput
 *
 *
 * Return Type:
 * - Non-streaming: UniverseQuestion
 * - Streaming: ReadableStream
 */
 export async function TestUniverseQuestionAction<Options extends { stream: true }>(
  question: UniverseQuestionInput,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestUniverseQuestionAction<Options extends { stream?: false }>(
  question: UniverseQuestionInput,
  options?: Options
): Promise<UniverseQuestion>;

export async function TestUniverseQuestionAction<Options extends { stream?: boolean }>(
  question: UniverseQuestionInput,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : UniverseQuestion> {
  if (options?.stream) {
    const stream = b.stream.TestUniverseQuestion(
      question,
    );
    return stream.toStreamable();
  }
  return b.TestUniverseQuestion(
    question,
  );
};

/**
 * Server action for the TestVertex BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
 export async function TestVertexAction<Options extends { stream: true }>(
  input: string,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function TestVertexAction<Options extends { stream?: false }>(
  input: string,
  options?: Options
): Promise<string>;

export async function TestVertexAction<Options extends { stream?: boolean }>(
  input: string,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : string> {
  if (options?.stream) {
    const stream = b.stream.TestVertex(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestVertex(
    input,
  );
};

/**
 * Server action for the UnionTest_Function BAML function.
 *
 * Input Types:
 *
 * - input: string | boolean
 *
 *
 * Return Type:
 * - Non-streaming: UnionTest_ReturnType
 * - Streaming: ReadableStream
 */
 export async function UnionTest_FunctionAction<Options extends { stream: true }>(
  input: string | boolean,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function UnionTest_FunctionAction<Options extends { stream?: false }>(
  input: string | boolean,
  options?: Options
): Promise<UnionTest_ReturnType>;

export async function UnionTest_FunctionAction<Options extends { stream?: boolean }>(
  input: string | boolean,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : UnionTest_ReturnType> {
  if (options?.stream) {
    const stream = b.stream.UnionTest_Function(
      input,
    );
    return stream.toStreamable();
  }
  return b.UnionTest_Function(
    input,
  );
};

/**
 * Server action for the UseBlockConstraint BAML function.
 *
 * Input Types:
 *
 * - inp: BlockConstraintForParam
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
 export async function UseBlockConstraintAction<Options extends { stream: true }>(
  inp: BlockConstraintForParam,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function UseBlockConstraintAction<Options extends { stream?: false }>(
  inp: BlockConstraintForParam,
  options?: Options
): Promise<number>;

export async function UseBlockConstraintAction<Options extends { stream?: boolean }>(
  inp: BlockConstraintForParam,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number> {
  if (options?.stream) {
    const stream = b.stream.UseBlockConstraint(
      inp,
    );
    return stream.toStreamable();
  }
  return b.UseBlockConstraint(
    inp,
  );
};

/**
 * Server action for the UseMalformedConstraints BAML function.
 *
 * Input Types:
 *
 * - a: MalformedConstraints2
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
 export async function UseMalformedConstraintsAction<Options extends { stream: true }>(
  a: MalformedConstraints2,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function UseMalformedConstraintsAction<Options extends { stream?: false }>(
  a: MalformedConstraints2,
  options?: Options
): Promise<number>;

export async function UseMalformedConstraintsAction<Options extends { stream?: boolean }>(
  a: MalformedConstraints2,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number> {
  if (options?.stream) {
    const stream = b.stream.UseMalformedConstraints(
      a,
    );
    return stream.toStreamable();
  }
  return b.UseMalformedConstraints(
    a,
  );
};

/**
 * Server action for the UseNestedBlockConstraint BAML function.
 *
 * Input Types:
 *
 * - inp: NestedBlockConstraintForParam
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
 export async function UseNestedBlockConstraintAction<Options extends { stream: true }>(
  inp: NestedBlockConstraintForParam,
  options?: Options
): Promise<ReadableStream<Uint8Array>>;

export async function UseNestedBlockConstraintAction<Options extends { stream?: false }>(
  inp: NestedBlockConstraintForParam,
  options?: Options
): Promise<number>;

export async function UseNestedBlockConstraintAction<Options extends { stream?: boolean }>(
  inp: NestedBlockConstraintForParam,
  options?: Options
): Promise<Options['stream'] extends true ? ReadableStream<Uint8Array> : number> {
  if (options?.stream) {
    const stream = b.stream.UseNestedBlockConstraint(
      inp,
    );
    return stream.toStreamable();
  }
  return b.UseNestedBlockConstraint(
    inp,
  );
};

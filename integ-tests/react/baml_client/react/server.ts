/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use server'

import { b } from '../index';
import type { StreamedObject } from './types';
import { Check, Checked, RecursivePartialNull } from "../types"
import { Image, Audio } from "@boundaryml/baml"
import {BigNumbers, BinaryNode, Blah, BlockConstraint, BlockConstraintForParam, BookOrder, ClassOptionalOutput, ClassOptionalOutput2, ClassToRecAlias, ClassWithImage, CompoundBigNumbers, ContactInfo, CustomTaskResult, DummyOutput, DynInputOutput, DynamicClassOne, DynamicClassTwo, DynamicOutput, Earthling, Education, Email, EmailAddress, Event, FakeImage, FlightConfirmation, FooAny, Forest, FormatterTest0, FormatterTest1, FormatterTest2, FormatterTest3, GroceryReceipt, InnerClass, InnerClass2, InputClass, InputClassNested, LinkedList, LinkedListAliasNode, LiteralClassHello, LiteralClassOne, LiteralClassTwo, MalformedConstraints, MalformedConstraints2, Martian, MergeAttrs, NamedArgsSingleClass, Nested, Nested2, NestedBlockConstraint, NestedBlockConstraintForParam, Node, NodeWithAliasIndirection, OptionalListAndMap, OptionalTest_Prop1, OptionalTest_ReturnType, OrderInfo, OriginalA, OriginalB, Person, PhoneNumber, Quantity, RaysData, ReceiptInfo, ReceiptItem, Recipe, Resume, Schema, SearchParams, SomeClassNestedDynamic, StringToClassEntry, TestClassAlias, TestClassNested, TestClassWithEnum, TestOutputClass, Tree, TwoStoriesOneTitle, UnionTest_ReturnType, WithReasoning, AliasedEnum, Category, Category2, Category3, Color, DataType, DynEnumOne, DynEnumTwo, EnumInClass, EnumOutput, Hobby, MapKey, NamedArgsSingleEnum, NamedArgsSingleEnumList, OptionalTest_CategoryType, OrderStatus, Tag, TestEnum} from "../types"
/**
 * Server action for the AaaSamOutputFormat BAML function.
 *
 * Input Types:
 *
 * - recipe: string
 *
 *
 * Return Type:
 * - Non-streaming: Recipe
 * - Streaming: ReadableStream
 */
export const AaaSamOutputFormatAction = async (
  recipe: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AaaSamOutputFormat(
      recipe,
    );
    return stream.toStreamable();
  }
  return b.AaaSamOutputFormat(
    recipe,
  );
};

/**
 * Server action for the AliasThatPointsToRecursiveType BAML function.
 *
 * Input Types:
 *
 * - list: LinkedListAliasNode
 *
 *
 * Return Type:
 * - Non-streaming: LinkedListAliasNode
 * - Streaming: ReadableStream
 */
export const AliasThatPointsToRecursiveTypeAction = async (
  list: LinkedListAliasNode,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AliasThatPointsToRecursiveType(
      list,
    );
    return stream.toStreamable();
  }
  return b.AliasThatPointsToRecursiveType(
    list,
  );
};

/**
 * Server action for the AliasWithMultipleAttrs BAML function.
 *
 * Input Types:
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"gt_ten">
 * - Streaming: ReadableStream
 */
export const AliasWithMultipleAttrsAction = async (
  money: Checked<number,"gt_ten">,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AliasWithMultipleAttrs(
      money,
    );
    return stream.toStreamable();
  }
  return b.AliasWithMultipleAttrs(
    money,
  );
};

/**
 * Server action for the AliasedInputClass BAML function.
 *
 * Input Types:
 *
 * - input: InputClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const AliasedInputClassAction = async (
  input: InputClass,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AliasedInputClass(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputClass(
    input,
  );
};

/**
 * Server action for the AliasedInputClass2 BAML function.
 *
 * Input Types:
 *
 * - input: InputClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const AliasedInputClass2Action = async (
  input: InputClass,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AliasedInputClass2(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputClass2(
    input,
  );
};

/**
 * Server action for the AliasedInputClassNested BAML function.
 *
 * Input Types:
 *
 * - input: InputClassNested
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const AliasedInputClassNestedAction = async (
  input: InputClassNested,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AliasedInputClassNested(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputClassNested(
    input,
  );
};

/**
 * Server action for the AliasedInputEnum BAML function.
 *
 * Input Types:
 *
 * - input: AliasedEnum
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const AliasedInputEnumAction = async (
  input: AliasedEnum,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AliasedInputEnum(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputEnum(
    input,
  );
};

/**
 * Server action for the AliasedInputList BAML function.
 *
 * Input Types:
 *
 * - input: AliasedEnum[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const AliasedInputListAction = async (
  input: AliasedEnum[],
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AliasedInputList(
      input,
    );
    return stream.toStreamable();
  }
  return b.AliasedInputList(
    input,
  );
};

/**
 * Server action for the AllowedOptionals BAML function.
 *
 * Input Types:
 *
 * - optionals: OptionalListAndMap
 *
 *
 * Return Type:
 * - Non-streaming: OptionalListAndMap
 * - Streaming: ReadableStream
 */
export const AllowedOptionalsAction = async (
  optionals: OptionalListAndMap,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AllowedOptionals(
      optionals,
    );
    return stream.toStreamable();
  }
  return b.AllowedOptionals(
    optionals,
  );
};

/**
 * Server action for the AudioInput BAML function.
 *
 * Input Types:
 *
 * - aud: Audio
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const AudioInputAction = async (
  aud: Audio,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.AudioInput(
      aud,
    );
    return stream.toStreamable();
  }
  return b.AudioInput(
    aud,
  );
};

/**
 * Server action for the BuildLinkedList BAML function.
 *
 * Input Types:
 *
 * - input: number[]
 *
 *
 * Return Type:
 * - Non-streaming: LinkedList
 * - Streaming: ReadableStream
 */
export const BuildLinkedListAction = async (
  input: number[],
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.BuildLinkedList(
      input,
    );
    return stream.toStreamable();
  }
  return b.BuildLinkedList(
    input,
  );
};

/**
 * Server action for the BuildTree BAML function.
 *
 * Input Types:
 *
 * - input: BinaryNode
 *
 *
 * Return Type:
 * - Non-streaming: Tree
 * - Streaming: ReadableStream
 */
export const BuildTreeAction = async (
  input: BinaryNode,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.BuildTree(
      input,
    );
    return stream.toStreamable();
  }
  return b.BuildTree(
    input,
  );
};

/**
 * Server action for the ClassThatPointsToRecursiveClassThroughAlias BAML function.
 *
 * Input Types:
 *
 * - cls: ClassToRecAlias
 *
 *
 * Return Type:
 * - Non-streaming: ClassToRecAlias
 * - Streaming: ReadableStream
 */
export const ClassThatPointsToRecursiveClassThroughAliasAction = async (
  cls: ClassToRecAlias,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ClassThatPointsToRecursiveClassThroughAlias(
      cls,
    );
    return stream.toStreamable();
  }
  return b.ClassThatPointsToRecursiveClassThroughAlias(
    cls,
  );
};

/**
 * Server action for the ClassifyDynEnumTwo BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: (string | DynEnumTwo)
 * - Streaming: ReadableStream
 */
export const ClassifyDynEnumTwoAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ClassifyDynEnumTwo(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyDynEnumTwo(
    input,
  );
};

/**
 * Server action for the ClassifyMessage BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming: ReadableStream
 */
export const ClassifyMessageAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ClassifyMessage(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyMessage(
    input,
  );
};

/**
 * Server action for the ClassifyMessage2 BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming: ReadableStream
 */
export const ClassifyMessage2Action = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ClassifyMessage2(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyMessage2(
    input,
  );
};

/**
 * Server action for the ClassifyMessage3 BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming: ReadableStream
 */
export const ClassifyMessage3Action = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ClassifyMessage3(
      input,
    );
    return stream.toStreamable();
  }
  return b.ClassifyMessage3(
    input,
  );
};

/**
 * Server action for the Completion BAML function.
 *
 * Input Types:
 *
 * - prefix: string
 *
 * - suffix: string
 *
 * - language: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const CompletionAction = async (
  prefix: string,
  suffix: string,
  language: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.Completion(
      prefix,
      suffix,
      language,
    );
    return stream.toStreamable();
  }
  return b.Completion(
    prefix,
    suffix,
    language,
  );
};

/**
 * Server action for the CustomTask BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: BookOrder | FlightConfirmation | GroceryReceipt
 * - Streaming: ReadableStream
 */
export const CustomTaskAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.CustomTask(
      input,
    );
    return stream.toStreamable();
  }
  return b.CustomTask(
    input,
  );
};

/**
 * Server action for the DescribeImage BAML function.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const DescribeImageAction = async (
  img: Image,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DescribeImage(
      img,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage(
    img,
  );
};

/**
 * Server action for the DescribeImage2 BAML function.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const DescribeImage2Action = async (
  classWithImage: ClassWithImage,
  img2: Image,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DescribeImage2(
      classWithImage,
      img2,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage2(
    classWithImage,
    img2,
  );
};

/**
 * Server action for the DescribeImage3 BAML function.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const DescribeImage3Action = async (
  classWithImage: ClassWithImage,
  img2: Image,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DescribeImage3(
      classWithImage,
      img2,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage3(
    classWithImage,
    img2,
  );
};

/**
 * Server action for the DescribeImage4 BAML function.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const DescribeImage4Action = async (
  classWithImage: ClassWithImage,
  img2: Image,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DescribeImage4(
      classWithImage,
      img2,
    );
    return stream.toStreamable();
  }
  return b.DescribeImage4(
    classWithImage,
    img2,
  );
};

/**
 * Server action for the DifferentiateUnions BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: OriginalA | OriginalB
 * - Streaming: ReadableStream
 */
export const DifferentiateUnionsAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DifferentiateUnions(
    );
    return stream.toStreamable();
  }
  return b.DifferentiateUnions(
  );
};

/**
 * Server action for the DummyOutputFunction BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: DummyOutput
 * - Streaming: ReadableStream
 */
export const DummyOutputFunctionAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DummyOutputFunction(
      input,
    );
    return stream.toStreamable();
  }
  return b.DummyOutputFunction(
    input,
  );
};

/**
 * Server action for the DynamicFunc BAML function.
 *
 * Input Types:
 *
 * - input: DynamicClassOne
 *
 *
 * Return Type:
 * - Non-streaming: DynamicClassTwo
 * - Streaming: ReadableStream
 */
export const DynamicFuncAction = async (
  input: DynamicClassOne,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DynamicFunc(
      input,
    );
    return stream.toStreamable();
  }
  return b.DynamicFunc(
    input,
  );
};

/**
 * Server action for the DynamicInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: DynInputOutput
 *
 *
 * Return Type:
 * - Non-streaming: DynInputOutput
 * - Streaming: ReadableStream
 */
export const DynamicInputOutputAction = async (
  input: DynInputOutput,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DynamicInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.DynamicInputOutput(
    input,
  );
};

/**
 * Server action for the DynamicListInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: DynInputOutput[]
 *
 *
 * Return Type:
 * - Non-streaming: DynInputOutput[]
 * - Streaming: ReadableStream
 */
export const DynamicListInputOutputAction = async (
  input: DynInputOutput[],
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.DynamicListInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.DynamicListInputOutput(
    input,
  );
};

/**
 * Server action for the ExpectFailure BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const ExpectFailureAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExpectFailure(
    );
    return stream.toStreamable();
  }
  return b.ExpectFailure(
  );
};

/**
 * Server action for the ExtractContactInfo BAML function.
 *
 * Input Types:
 *
 * - document: string
 *
 *
 * Return Type:
 * - Non-streaming: ContactInfo
 * - Streaming: ReadableStream
 */
export const ExtractContactInfoAction = async (
  document: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExtractContactInfo(
      document,
    );
    return stream.toStreamable();
  }
  return b.ExtractContactInfo(
    document,
  );
};

/**
 * Server action for the ExtractHobby BAML function.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: (string | Hobby)[]
 * - Streaming: ReadableStream
 */
export const ExtractHobbyAction = async (
  text: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExtractHobby(
      text,
    );
    return stream.toStreamable();
  }
  return b.ExtractHobby(
    text,
  );
};

/**
 * Server action for the ExtractNames BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string[]
 * - Streaming: ReadableStream
 */
export const ExtractNamesAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExtractNames(
      input,
    );
    return stream.toStreamable();
  }
  return b.ExtractNames(
    input,
  );
};

/**
 * Server action for the ExtractPeople BAML function.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: Person[]
 * - Streaming: ReadableStream
 */
export const ExtractPeopleAction = async (
  text: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExtractPeople(
      text,
    );
    return stream.toStreamable();
  }
  return b.ExtractPeople(
    text,
  );
};

/**
 * Server action for the ExtractReceiptInfo BAML function.
 *
 * Input Types:
 *
 * - email: string
 *
 * - reason: "curiosity" | "personal_finance"
 *
 *
 * Return Type:
 * - Non-streaming: ReceiptInfo
 * - Streaming: ReadableStream
 */
export const ExtractReceiptInfoAction = async (
  email: string,
  reason: "curiosity" | "personal_finance",
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExtractReceiptInfo(
      email,
      reason,
    );
    return stream.toStreamable();
  }
  return b.ExtractReceiptInfo(
    email,
    reason,
  );
};

/**
 * Server action for the ExtractResume BAML function.
 *
 * Input Types:
 *
 * - resume: string
 *
 * - img (optional): Image | null
 *
 *
 * Return Type:
 * - Non-streaming: Resume
 * - Streaming: ReadableStream
 */
export const ExtractResumeAction = async (
  resume: string,
  img?: Image | null,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExtractResume(
      resume,
      img,
    );
    return stream.toStreamable();
  }
  return b.ExtractResume(
    resume,
    img,
  );
};

/**
 * Server action for the ExtractResume2 BAML function.
 *
 * Input Types:
 *
 * - resume: string
 *
 *
 * Return Type:
 * - Non-streaming: Resume
 * - Streaming: ReadableStream
 */
export const ExtractResume2Action = async (
  resume: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ExtractResume2(
      resume,
    );
    return stream.toStreamable();
  }
  return b.ExtractResume2(
    resume,
  );
};

/**
 * Server action for the FnClassOptionalOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: ClassOptionalOutput | null
 * - Streaming: ReadableStream
 */
export const FnClassOptionalOutputAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnClassOptionalOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnClassOptionalOutput(
    input,
  );
};

/**
 * Server action for the FnClassOptionalOutput2 BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: ClassOptionalOutput2 | null
 * - Streaming: ReadableStream
 */
export const FnClassOptionalOutput2Action = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnClassOptionalOutput2(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnClassOptionalOutput2(
    input,
  );
};

/**
 * Server action for the FnEnumListOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: EnumOutput[]
 * - Streaming: ReadableStream
 */
export const FnEnumListOutputAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnEnumListOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnEnumListOutput(
    input,
  );
};

/**
 * Server action for the FnEnumOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: EnumOutput
 * - Streaming: ReadableStream
 */
export const FnEnumOutputAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnEnumOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnEnumOutput(
    input,
  );
};

/**
 * Server action for the FnLiteralClassInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: LiteralClassHello
 *
 *
 * Return Type:
 * - Non-streaming: LiteralClassHello
 * - Streaming: ReadableStream
 */
export const FnLiteralClassInputOutputAction = async (
  input: LiteralClassHello,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnLiteralClassInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnLiteralClassInputOutput(
    input,
  );
};

/**
 * Server action for the FnLiteralUnionClassInputOutput BAML function.
 *
 * Input Types:
 *
 * - input: LiteralClassOne | LiteralClassTwo
 *
 *
 * Return Type:
 * - Non-streaming: LiteralClassOne | LiteralClassTwo
 * - Streaming: ReadableStream
 */
export const FnLiteralUnionClassInputOutputAction = async (
  input: LiteralClassOne | LiteralClassTwo,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnLiteralUnionClassInputOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnLiteralUnionClassInputOutput(
    input,
  );
};

/**
 * Server action for the FnNamedArgsSingleStringOptional BAML function.
 *
 * Input Types:
 *
 * - myString (optional): string | null
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const FnNamedArgsSingleStringOptionalAction = async (
  myString?: string | null,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnNamedArgsSingleStringOptional(
      myString,
    );
    return stream.toStreamable();
  }
  return b.FnNamedArgsSingleStringOptional(
    myString,
  );
};

/**
 * Server action for the FnOutputBool BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: boolean
 * - Streaming: ReadableStream
 */
export const FnOutputBoolAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputBool(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputBool(
    input,
  );
};

/**
 * Server action for the FnOutputClass BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestOutputClass
 * - Streaming: ReadableStream
 */
export const FnOutputClassAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputClass(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClass(
    input,
  );
};

/**
 * Server action for the FnOutputClassList BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestOutputClass[]
 * - Streaming: ReadableStream
 */
export const FnOutputClassListAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputClassList(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClassList(
    input,
  );
};

/**
 * Server action for the FnOutputClassNested BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassNested
 * - Streaming: ReadableStream
 */
export const FnOutputClassNestedAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputClassNested(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClassNested(
    input,
  );
};

/**
 * Server action for the FnOutputClassWithEnum BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassWithEnum
 * - Streaming: ReadableStream
 */
export const FnOutputClassWithEnumAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputClassWithEnum(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputClassWithEnum(
    input,
  );
};

/**
 * Server action for the FnOutputInt BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
export const FnOutputIntAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputInt(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputInt(
    input,
  );
};

/**
 * Server action for the FnOutputLiteralBool BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: false
 * - Streaming: ReadableStream
 */
export const FnOutputLiteralBoolAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputLiteralBool(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputLiteralBool(
    input,
  );
};

/**
 * Server action for the FnOutputLiteralInt BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: 5
 * - Streaming: ReadableStream
 */
export const FnOutputLiteralIntAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputLiteralInt(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputLiteralInt(
    input,
  );
};

/**
 * Server action for the FnOutputLiteralString BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: "example output"
 * - Streaming: ReadableStream
 */
export const FnOutputLiteralStringAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputLiteralString(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputLiteralString(
    input,
  );
};

/**
 * Server action for the FnOutputStringList BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string[]
 * - Streaming: ReadableStream
 */
export const FnOutputStringListAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnOutputStringList(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnOutputStringList(
    input,
  );
};

/**
 * Server action for the FnTestAliasedEnumOutput BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestEnum
 * - Streaming: ReadableStream
 */
export const FnTestAliasedEnumOutputAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnTestAliasedEnumOutput(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnTestAliasedEnumOutput(
    input,
  );
};

/**
 * Server action for the FnTestClassAlias BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassAlias
 * - Streaming: ReadableStream
 */
export const FnTestClassAliasAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnTestClassAlias(
      input,
    );
    return stream.toStreamable();
  }
  return b.FnTestClassAlias(
    input,
  );
};

/**
 * Server action for the FnTestNamedArgsSingleEnum BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleEnum
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const FnTestNamedArgsSingleEnumAction = async (
  myArg: NamedArgsSingleEnum,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.FnTestNamedArgsSingleEnum(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.FnTestNamedArgsSingleEnum(
    myArg,
  );
};

/**
 * Server action for the GetDataType BAML function.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: RaysData
 * - Streaming: ReadableStream
 */
export const GetDataTypeAction = async (
  text: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.GetDataType(
      text,
    );
    return stream.toStreamable();
  }
  return b.GetDataType(
    text,
  );
};

/**
 * Server action for the GetOrderInfo BAML function.
 *
 * Input Types:
 *
 * - email: Email
 *
 *
 * Return Type:
 * - Non-streaming: OrderInfo
 * - Streaming: ReadableStream
 */
export const GetOrderInfoAction = async (
  email: Email,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.GetOrderInfo(
      email,
    );
    return stream.toStreamable();
  }
  return b.GetOrderInfo(
    email,
  );
};

/**
 * Server action for the GetQuery BAML function.
 *
 * Input Types:
 *
 * - query: string
 *
 *
 * Return Type:
 * - Non-streaming: SearchParams
 * - Streaming: ReadableStream
 */
export const GetQueryAction = async (
  query: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.GetQuery(
      query,
    );
    return stream.toStreamable();
  }
  return b.GetQuery(
    query,
  );
};

/**
 * Server action for the InOutEnumMapKey BAML function.
 *
 * Input Types:
 *
 * - i1: Partial<Record<MapKey, string>>
 *
 * - i2: Partial<Record<MapKey, string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<MapKey, string>>
 * - Streaming: ReadableStream
 */
export const InOutEnumMapKeyAction = async (
  i1: Partial<Record<MapKey, string>>,
  i2: Partial<Record<MapKey, string>>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.InOutEnumMapKey(
      i1,
      i2,
    );
    return stream.toStreamable();
  }
  return b.InOutEnumMapKey(
    i1,
    i2,
  );
};

/**
 * Server action for the InOutLiteralStringUnionMapKey BAML function.
 *
 * Input Types:
 *
 * - i1: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * - i2: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<"one" | "two" | "three" | "four", string>>
 * - Streaming: ReadableStream
 */
export const InOutLiteralStringUnionMapKeyAction = async (
  i1: Partial<Record<"one" | "two" | "three" | "four", string>>,
  i2: Partial<Record<"one" | "two" | "three" | "four", string>>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.InOutLiteralStringUnionMapKey(
      i1,
      i2,
    );
    return stream.toStreamable();
  }
  return b.InOutLiteralStringUnionMapKey(
    i1,
    i2,
  );
};

/**
 * Server action for the InOutSingleLiteralStringMapKey BAML function.
 *
 * Input Types:
 *
 * - m: Partial<Record<"key", string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<"key", string>>
 * - Streaming: ReadableStream
 */
export const InOutSingleLiteralStringMapKeyAction = async (
  m: Partial<Record<"key", string>>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.InOutSingleLiteralStringMapKey(
      m,
    );
    return stream.toStreamable();
  }
  return b.InOutSingleLiteralStringMapKey(
    m,
  );
};

/**
 * Server action for the JsonTypeAliasCycle BAML function.
 *
 * Input Types:
 *
 * - input: JsonValue
 *
 *
 * Return Type:
 * - Non-streaming: JsonValue
 * - Streaming: ReadableStream
 */
export const JsonTypeAliasCycleAction = async (
  input: JsonValue,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.JsonTypeAliasCycle(
      input,
    );
    return stream.toStreamable();
  }
  return b.JsonTypeAliasCycle(
    input,
  );
};

/**
 * Server action for the LiteralUnionsTest BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: 1 | true | "string output"
 * - Streaming: ReadableStream
 */
export const LiteralUnionsTestAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.LiteralUnionsTest(
      input,
    );
    return stream.toStreamable();
  }
  return b.LiteralUnionsTest(
    input,
  );
};

/**
 * Server action for the MakeBlockConstraint BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: Checked<BlockConstraint,"cross_field">
 * - Streaming: ReadableStream
 */
export const MakeBlockConstraintAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.MakeBlockConstraint(
    );
    return stream.toStreamable();
  }
  return b.MakeBlockConstraint(
  );
};

/**
 * Server action for the MakeNestedBlockConstraint BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: NestedBlockConstraint
 * - Streaming: ReadableStream
 */
export const MakeNestedBlockConstraintAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.MakeNestedBlockConstraint(
    );
    return stream.toStreamable();
  }
  return b.MakeNestedBlockConstraint(
  );
};

/**
 * Server action for the MapAlias BAML function.
 *
 * Input Types:
 *
 * - m: Record<string, string[]>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, string[]>
 * - Streaming: ReadableStream
 */
export const MapAliasAction = async (
  m: Record<string, string[]>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.MapAlias(
      m,
    );
    return stream.toStreamable();
  }
  return b.MapAlias(
    m,
  );
};

/**
 * Server action for the MergeAliasAttributes BAML function.
 *
 * Input Types:
 *
 * - money: number
 *
 *
 * Return Type:
 * - Non-streaming: MergeAttrs
 * - Streaming: ReadableStream
 */
export const MergeAliasAttributesAction = async (
  money: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.MergeAliasAttributes(
      money,
    );
    return stream.toStreamable();
  }
  return b.MergeAliasAttributes(
    money,
  );
};

/**
 * Server action for the MyFunc BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: DynamicOutput
 * - Streaming: ReadableStream
 */
export const MyFuncAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.MyFunc(
      input,
    );
    return stream.toStreamable();
  }
  return b.MyFunc(
    input,
  );
};

/**
 * Server action for the NestedAlias BAML function.
 *
 * Input Types:
 *
 * - c: number | string | boolean | number | string[] | Record<string, string[]>
 *
 *
 * Return Type:
 * - Non-streaming: number | string | boolean | number | string[] | Record<string, string[]>
 * - Streaming: ReadableStream
 */
export const NestedAliasAction = async (
  c: number | string | boolean | number | string[] | Record<string, string[]>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.NestedAlias(
      c,
    );
    return stream.toStreamable();
  }
  return b.NestedAlias(
    c,
  );
};

/**
 * Server action for the OptionalTest_Function BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: (OptionalTest_ReturnType | null)[]
 * - Streaming: ReadableStream
 */
export const OptionalTest_FunctionAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.OptionalTest_Function(
      input,
    );
    return stream.toStreamable();
  }
  return b.OptionalTest_Function(
    input,
  );
};

/**
 * Server action for the PredictAge BAML function.
 *
 * Input Types:
 *
 * - name: string
 *
 *
 * Return Type:
 * - Non-streaming: FooAny
 * - Streaming: ReadableStream
 */
export const PredictAgeAction = async (
  name: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PredictAge(
      name,
    );
    return stream.toStreamable();
  }
  return b.PredictAge(
    name,
  );
};

/**
 * Server action for the PredictAgeBare BAML function.
 *
 * Input Types:
 *
 * - inp: string
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"too_big">
 * - Streaming: ReadableStream
 */
export const PredictAgeBareAction = async (
  inp: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PredictAgeBare(
      inp,
    );
    return stream.toStreamable();
  }
  return b.PredictAgeBare(
    inp,
  );
};

/**
 * Server action for the PrimitiveAlias BAML function.
 *
 * Input Types:
 *
 * - p: number | string | boolean | number
 *
 *
 * Return Type:
 * - Non-streaming: number | string | boolean | number
 * - Streaming: ReadableStream
 */
export const PrimitiveAliasAction = async (
  p: number | string | boolean | number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PrimitiveAlias(
      p,
    );
    return stream.toStreamable();
  }
  return b.PrimitiveAlias(
    p,
  );
};

/**
 * Server action for the PromptTestClaude BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const PromptTestClaudeAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PromptTestClaude(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestClaude(
    input,
  );
};

/**
 * Server action for the PromptTestClaudeChat BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const PromptTestClaudeChatAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PromptTestClaudeChat(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestClaudeChat(
    input,
  );
};

/**
 * Server action for the PromptTestClaudeChatNoSystem BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const PromptTestClaudeChatNoSystemAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PromptTestClaudeChatNoSystem(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestClaudeChatNoSystem(
    input,
  );
};

/**
 * Server action for the PromptTestOpenAI BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const PromptTestOpenAIAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PromptTestOpenAI(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestOpenAI(
    input,
  );
};

/**
 * Server action for the PromptTestOpenAIChat BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const PromptTestOpenAIChatAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PromptTestOpenAIChat(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestOpenAIChat(
    input,
  );
};

/**
 * Server action for the PromptTestOpenAIChatNoSystem BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const PromptTestOpenAIChatNoSystemAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PromptTestOpenAIChatNoSystem(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestOpenAIChatNoSystem(
    input,
  );
};

/**
 * Server action for the PromptTestStreaming BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const PromptTestStreamingAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.PromptTestStreaming(
      input,
    );
    return stream.toStreamable();
  }
  return b.PromptTestStreaming(
    input,
  );
};

/**
 * Server action for the RecursiveAliasCycle BAML function.
 *
 * Input Types:
 *
 * - input: RecAliasOne
 *
 *
 * Return Type:
 * - Non-streaming: RecAliasOne
 * - Streaming: ReadableStream
 */
export const RecursiveAliasCycleAction = async (
  input: RecAliasOne,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.RecursiveAliasCycle(
      input,
    );
    return stream.toStreamable();
  }
  return b.RecursiveAliasCycle(
    input,
  );
};

/**
 * Server action for the RecursiveClassWithAliasIndirection BAML function.
 *
 * Input Types:
 *
 * - cls: NodeWithAliasIndirection
 *
 *
 * Return Type:
 * - Non-streaming: NodeWithAliasIndirection
 * - Streaming: ReadableStream
 */
export const RecursiveClassWithAliasIndirectionAction = async (
  cls: NodeWithAliasIndirection,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.RecursiveClassWithAliasIndirection(
      cls,
    );
    return stream.toStreamable();
  }
  return b.RecursiveClassWithAliasIndirection(
    cls,
  );
};

/**
 * Server action for the ReturnAliasWithMergedAttributes BAML function.
 *
 * Input Types:
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"gt_ten">
 * - Streaming: ReadableStream
 */
export const ReturnAliasWithMergedAttributesAction = async (
  money: Checked<number,"gt_ten">,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ReturnAliasWithMergedAttributes(
      money,
    );
    return stream.toStreamable();
  }
  return b.ReturnAliasWithMergedAttributes(
    money,
  );
};

/**
 * Server action for the ReturnFailingAssert BAML function.
 *
 * Input Types:
 *
 * - inp: number
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
export const ReturnFailingAssertAction = async (
  inp: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ReturnFailingAssert(
      inp,
    );
    return stream.toStreamable();
  }
  return b.ReturnFailingAssert(
    inp,
  );
};

/**
 * Server action for the ReturnMalformedConstraints BAML function.
 *
 * Input Types:
 *
 * - a: number
 *
 *
 * Return Type:
 * - Non-streaming: MalformedConstraints
 * - Streaming: ReadableStream
 */
export const ReturnMalformedConstraintsAction = async (
  a: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.ReturnMalformedConstraints(
      a,
    );
    return stream.toStreamable();
  }
  return b.ReturnMalformedConstraints(
    a,
  );
};

/**
 * Server action for the SchemaDescriptions BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Schema
 * - Streaming: ReadableStream
 */
export const SchemaDescriptionsAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.SchemaDescriptions(
      input,
    );
    return stream.toStreamable();
  }
  return b.SchemaDescriptions(
    input,
  );
};

/**
 * Server action for the SimpleRecursiveListAlias BAML function.
 *
 * Input Types:
 *
 * - input: RecursiveListAlias
 *
 *
 * Return Type:
 * - Non-streaming: RecursiveListAlias
 * - Streaming: ReadableStream
 */
export const SimpleRecursiveListAliasAction = async (
  input: RecursiveListAlias,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.SimpleRecursiveListAlias(
      input,
    );
    return stream.toStreamable();
  }
  return b.SimpleRecursiveListAlias(
    input,
  );
};

/**
 * Server action for the SimpleRecursiveMapAlias BAML function.
 *
 * Input Types:
 *
 * - input: RecursiveMapAlias
 *
 *
 * Return Type:
 * - Non-streaming: RecursiveMapAlias
 * - Streaming: ReadableStream
 */
export const SimpleRecursiveMapAliasAction = async (
  input: RecursiveMapAlias,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.SimpleRecursiveMapAlias(
      input,
    );
    return stream.toStreamable();
  }
  return b.SimpleRecursiveMapAlias(
    input,
  );
};

/**
 * Server action for the StreamBigNumbers BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: BigNumbers
 * - Streaming: ReadableStream
 */
export const StreamBigNumbersAction = async (
  digits: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.StreamBigNumbers(
      digits,
    );
    return stream.toStreamable();
  }
  return b.StreamBigNumbers(
    digits,
  );
};

/**
 * Server action for the StreamFailingAssertion BAML function.
 *
 * Input Types:
 *
 * - theme: string
 *
 * - length: number
 *
 *
 * Return Type:
 * - Non-streaming: TwoStoriesOneTitle
 * - Streaming: ReadableStream
 */
export const StreamFailingAssertionAction = async (
  theme: string,
  length: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.StreamFailingAssertion(
      theme,
      length,
    );
    return stream.toStreamable();
  }
  return b.StreamFailingAssertion(
    theme,
    length,
  );
};

/**
 * Server action for the StreamOneBigNumber BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
export const StreamOneBigNumberAction = async (
  digits: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.StreamOneBigNumber(
      digits,
    );
    return stream.toStreamable();
  }
  return b.StreamOneBigNumber(
    digits,
  );
};

/**
 * Server action for the StreamUnionIntegers BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: (number | string)[]
 * - Streaming: ReadableStream
 */
export const StreamUnionIntegersAction = async (
  digits: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.StreamUnionIntegers(
      digits,
    );
    return stream.toStreamable();
  }
  return b.StreamUnionIntegers(
    digits,
  );
};

/**
 * Server action for the StreamingCompoundNumbers BAML function.
 *
 * Input Types:
 *
 * - digits: number
 *
 * - yapping: boolean
 *
 *
 * Return Type:
 * - Non-streaming: CompoundBigNumbers
 * - Streaming: ReadableStream
 */
export const StreamingCompoundNumbersAction = async (
  digits: number,
  yapping: boolean,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.StreamingCompoundNumbers(
      digits,
      yapping,
    );
    return stream.toStreamable();
  }
  return b.StreamingCompoundNumbers(
    digits,
    yapping,
  );
};

/**
 * Server action for the TestAnthropic BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAnthropicAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAnthropic(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAnthropic(
    input,
  );
};

/**
 * Server action for the TestAnthropicShorthand BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAnthropicShorthandAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAnthropicShorthand(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAnthropicShorthand(
    input,
  );
};

/**
 * Server action for the TestAws BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAwsAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAws(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAws(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidAccessKey BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAwsInvalidAccessKeyAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidAccessKey(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidAccessKey(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidProfile BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAwsInvalidProfileAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidProfile(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidProfile(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidRegion BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAwsInvalidRegionAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidRegion(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidRegion(
    input,
  );
};

/**
 * Server action for the TestAwsInvalidSessionToken BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAwsInvalidSessionTokenAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAwsInvalidSessionToken(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAwsInvalidSessionToken(
    input,
  );
};

/**
 * Server action for the TestAzure BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAzureAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAzure(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAzure(
    input,
  );
};

/**
 * Server action for the TestAzureFailure BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestAzureFailureAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestAzureFailure(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestAzureFailure(
    input,
  );
};

/**
 * Server action for the TestCaching BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 * - not_cached: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestCachingAction = async (
  input: string,
  not_cached: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestCaching(
      input,
      not_cached,
    );
    return stream.toStreamable();
  }
  return b.TestCaching(
    input,
    not_cached,
  );
};

/**
 * Server action for the TestFallbackClient BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFallbackClientAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFallbackClient(
    );
    return stream.toStreamable();
  }
  return b.TestFallbackClient(
  );
};

/**
 * Server action for the TestFallbackToShorthand BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFallbackToShorthandAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFallbackToShorthand(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestFallbackToShorthand(
    input,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleBool BAML function.
 *
 * Input Types:
 *
 * - myBool: boolean
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleBoolAction = async (
  myBool: boolean,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleBool(
      myBool,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleBool(
    myBool,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleClass BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleClassAction = async (
  myArg: NamedArgsSingleClass,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleClass(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleClass(
    myArg,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleEnumList BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleEnumList[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleEnumListAction = async (
  myArg: NamedArgsSingleEnumList[],
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleEnumList(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleEnumList(
    myArg,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleFloat BAML function.
 *
 * Input Types:
 *
 * - myFloat: number
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleFloatAction = async (
  myFloat: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleFloat(
      myFloat,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleFloat(
    myFloat,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleInt BAML function.
 *
 * Input Types:
 *
 * - myInt: number
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleIntAction = async (
  myInt: number,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleInt(
      myInt,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleInt(
    myInt,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleMapStringToClass BAML function.
 *
 * Input Types:
 *
 * - myMap: Record<string, StringToClassEntry>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, StringToClassEntry>
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleMapStringToClassAction = async (
  myMap: Record<string, StringToClassEntry>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleMapStringToClass(
      myMap,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleMapStringToClass(
    myMap,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleMapStringToMap BAML function.
 *
 * Input Types:
 *
 * - myMap: Record<string, Record<string, string>>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, Record<string, string>>
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleMapStringToMapAction = async (
  myMap: Record<string, Record<string, string>>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleMapStringToMap(
      myMap,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleMapStringToMap(
    myMap,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleMapStringToString BAML function.
 *
 * Input Types:
 *
 * - myMap: Record<string, string>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, string>
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleMapStringToStringAction = async (
  myMap: Record<string, string>,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleMapStringToString(
      myMap,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleMapStringToString(
    myMap,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleString BAML function.
 *
 * Input Types:
 *
 * - myString: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleStringAction = async (
  myString: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleString(
      myString,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleString(
    myString,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleStringArray BAML function.
 *
 * Input Types:
 *
 * - myStringArray: string[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleStringArrayAction = async (
  myStringArray: string[],
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleStringArray(
      myStringArray,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleStringArray(
    myStringArray,
  );
};

/**
 * Server action for the TestFnNamedArgsSingleStringList BAML function.
 *
 * Input Types:
 *
 * - myArg: string[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestFnNamedArgsSingleStringListAction = async (
  myArg: string[],
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestFnNamedArgsSingleStringList(
      myArg,
    );
    return stream.toStreamable();
  }
  return b.TestFnNamedArgsSingleStringList(
    myArg,
  );
};

/**
 * Server action for the TestGemini BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestGeminiAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestGemini(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestGemini(
    input,
  );
};

/**
 * Server action for the TestImageInput BAML function.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestImageInputAction = async (
  img: Image,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestImageInput(
      img,
    );
    return stream.toStreamable();
  }
  return b.TestImageInput(
    img,
  );
};

/**
 * Server action for the TestImageInputAnthropic BAML function.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestImageInputAnthropicAction = async (
  img: Image,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestImageInputAnthropic(
      img,
    );
    return stream.toStreamable();
  }
  return b.TestImageInputAnthropic(
    img,
  );
};

/**
 * Server action for the TestImageListInput BAML function.
 *
 * Input Types:
 *
 * - imgs: Image[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestImageListInputAction = async (
  imgs: Image[],
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestImageListInput(
      imgs,
    );
    return stream.toStreamable();
  }
  return b.TestImageListInput(
    imgs,
  );
};

/**
 * Server action for the TestMulticlassNamedArgs BAML function.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleClass
 *
 * - myArg2: NamedArgsSingleClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestMulticlassNamedArgsAction = async (
  myArg: NamedArgsSingleClass,
  myArg2: NamedArgsSingleClass,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestMulticlassNamedArgs(
      myArg,
      myArg2,
    );
    return stream.toStreamable();
  }
  return b.TestMulticlassNamedArgs(
    myArg,
    myArg2,
  );
};

/**
 * Server action for the TestNamedArgsLiteralBool BAML function.
 *
 * Input Types:
 *
 * - myBool: true
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestNamedArgsLiteralBoolAction = async (
  myBool: true,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestNamedArgsLiteralBool(
      myBool,
    );
    return stream.toStreamable();
  }
  return b.TestNamedArgsLiteralBool(
    myBool,
  );
};

/**
 * Server action for the TestNamedArgsLiteralInt BAML function.
 *
 * Input Types:
 *
 * - myInt: 1
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestNamedArgsLiteralIntAction = async (
  myInt: 1,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestNamedArgsLiteralInt(
      myInt,
    );
    return stream.toStreamable();
  }
  return b.TestNamedArgsLiteralInt(
    myInt,
  );
};

/**
 * Server action for the TestNamedArgsLiteralString BAML function.
 *
 * Input Types:
 *
 * - myString: "My String"
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestNamedArgsLiteralStringAction = async (
  myString: "My String",
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestNamedArgsLiteralString(
      myString,
    );
    return stream.toStreamable();
  }
  return b.TestNamedArgsLiteralString(
    myString,
  );
};

/**
 * Server action for the TestOllama BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestOllamaAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestOllama(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestOllama(
    input,
  );
};

/**
 * Server action for the TestOpenAILegacyProvider BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestOpenAILegacyProviderAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestOpenAILegacyProvider(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestOpenAILegacyProvider(
    input,
  );
};

/**
 * Server action for the TestOpenAIShorthand BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestOpenAIShorthandAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestOpenAIShorthand(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestOpenAIShorthand(
    input,
  );
};

/**
 * Server action for the TestRetryConstant BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestRetryConstantAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestRetryConstant(
    );
    return stream.toStreamable();
  }
  return b.TestRetryConstant(
  );
};

/**
 * Server action for the TestRetryExponential BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestRetryExponentialAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestRetryExponential(
    );
    return stream.toStreamable();
  }
  return b.TestRetryExponential(
  );
};

/**
 * Server action for the TestSingleFallbackClient BAML function.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestSingleFallbackClientAction = async (
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestSingleFallbackClient(
    );
    return stream.toStreamable();
  }
  return b.TestSingleFallbackClient(
  );
};

/**
 * Server action for the TestVertex BAML function.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming: ReadableStream
 */
export const TestVertexAction = async (
  input: string,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.TestVertex(
      input,
    );
    return stream.toStreamable();
  }
  return b.TestVertex(
    input,
  );
};

/**
 * Server action for the UnionTest_Function BAML function.
 *
 * Input Types:
 *
 * - input: string | boolean
 *
 *
 * Return Type:
 * - Non-streaming: UnionTest_ReturnType
 * - Streaming: ReadableStream
 */
export const UnionTest_FunctionAction = async (
  input: string | boolean,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.UnionTest_Function(
      input,
    );
    return stream.toStreamable();
  }
  return b.UnionTest_Function(
    input,
  );
};

/**
 * Server action for the UseBlockConstraint BAML function.
 *
 * Input Types:
 *
 * - inp: BlockConstraintForParam
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
export const UseBlockConstraintAction = async (
  inp: BlockConstraintForParam,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.UseBlockConstraint(
      inp,
    );
    return stream.toStreamable();
  }
  return b.UseBlockConstraint(
    inp,
  );
};

/**
 * Server action for the UseMalformedConstraints BAML function.
 *
 * Input Types:
 *
 * - a: MalformedConstraints2
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
export const UseMalformedConstraintsAction = async (
  a: MalformedConstraints2,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.UseMalformedConstraints(
      a,
    );
    return stream.toStreamable();
  }
  return b.UseMalformedConstraints(
    a,
  );
};

/**
 * Server action for the UseNestedBlockConstraint BAML function.
 *
 * Input Types:
 *
 * - inp: NestedBlockConstraintForParam
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming: ReadableStream
 */
export const UseNestedBlockConstraintAction = async (
  inp: NestedBlockConstraintForParam,
  options?: { stream?: boolean }
) => {
  if (options?.stream) {
    const stream = b.stream.UseNestedBlockConstraint(
      inp,
    );
    return stream.toStreamable();
  }
  return b.UseNestedBlockConstraint(
    inp,
  );
};

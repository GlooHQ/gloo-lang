/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use client'

import { useCallback, useMemo, useReducer, useTransition } from 'react';
import type {
  StreamingProps,
  NonStreamingProps,
  StreamingHookResult,
  NonStreamingHookResult,
  HookProps,
  PartialReturnType,
  FinalReturnType,
  ServerAction,
  BamlStreamResponse,
  ActionKey,
} from './types';
import { BamlValidationError, BamlClientFinishReasonError } from "@boundaryml/baml/errors";
import * as Actions from './server';
import * as StreamingActions from './server_streaming'

/**
 * Type guard to check if the hook props are configured for streaming mode.
 *
 * @template TActionKey - The key of the Actions namespace.
 * @param props - The hook props.
 * @returns {boolean} True if the props indicate streaming mode.
 */
function isStreamingProps<TActionKey extends ActionKey>(
  props: HookProps<TActionKey>
): props is StreamingProps<TActionKey> {
  return props.stream === true;
}

function isBamlError(error?: Error | BamlValidationError | BamlClientFinishReasonError): error is (BamlValidationError | BamlClientFinishReasonError) & { type: string } {
  const errorType = (error as any)?.type;
  return errorType === 'BamlValidationError' || errorType === 'BamlClientFinishReasonError';
}

interface HookState<TPartial, TFinal> {
  isSuccess: boolean;
  error?: Error | BamlValidationError | BamlClientFinishReasonError;
  data?: TFinal;
  partialData?: TPartial;
}

type HookStateAction<TPartial, TFinal> =
  | { type: 'START_REQUEST' }
  | { type: 'SET_ERROR'; payload: Error | BamlValidationError | BamlClientFinishReasonError }
  | { type: 'SET_PARTIAL'; payload: TPartial }
  | { type: 'SET_FINAL'; payload: TFinal }
  | { type: 'RESET' };

/**
 * Reducer function to manage the hook state transitions.
 *
 * @template TPartial - The type of the partial (streaming) data.
 * @template TFinal - The type of the final (non‑streaming) data.
 * @param state - The current hook state.
 * @param action - The action to apply.
 * @returns The updated state.
 */
function hookReducer<TPartial, TFinal>(
  state: HookState<TPartial, TFinal>,
  action: HookStateAction<TPartial, TFinal>
): HookState<TPartial, TFinal> {
  switch (action.type) {
    case 'START_REQUEST':
      return {
        ...state,
        isSuccess: false,
        error: undefined,
        data: undefined,
        partialData: undefined,
      };
    case 'SET_ERROR':
      return {
        ...state,
        isSuccess: false,
        error: action.payload,
        data: undefined,
        partialData: undefined,
      };
    case 'SET_PARTIAL':
      return {
        ...state,
        partialData: action.payload,
      };
    case 'SET_FINAL':
      return {
        ...state,
        isSuccess: true,
        data: action.payload,
        partialData: undefined,
      };
    case 'RESET':
      return {
        isSuccess: false,
        error: undefined,
        data: undefined,
        partialData: undefined,
      };
    default:
      return state;
  }
}

/**
 * Base hook for executing BAML server actions, supporting both streaming and non‑streaming modes.
 *
 * This hook provides a unified interface for handling loading states, partial updates, errors,
 * and final responses. It is designed to be used directly with any BAML server action.
 *
 * Features:
 * - **Streaming Support:** Real‑time partial updates via `partialData`, progress indicators, and incremental UI updates.
 * - **State Management:** Manages loading state (`isPending`), success/error flags, and final/partial results.
 * - **Error Handling:** Supports type‑safe error handling for BamlValidationError, BamlClientFinishReasonError, and standard errors.
 *
 * @param Action - The server action to invoke.
 * @param props - Configuration props for the hook.
 * @returns An object with the current state and a `mutate` function to trigger the action.
 *
 * @example
 * ```tsx
 * const { data, error, isPending, mutate } = useBamlAction(StreamingActions.TestAws, { stream: true });
 * ```
 */
export function useBamlAction<TActionKey extends ActionKey>(
  action: ServerAction,
  props: StreamingProps<TActionKey>
): StreamingHookResult<TActionKey>;

export function useBamlAction<TActionKey extends ActionKey>(
  action: ServerAction,
  props?: NonStreamingProps<TActionKey>
): NonStreamingHookResult<TActionKey>;

export function useBamlAction<TActionKey extends ActionKey>(
  action: ServerAction,
  props: HookProps<TActionKey> = {}
): StreamingHookResult<TActionKey> | NonStreamingHookResult<TActionKey> {
  const { onFinal, onError, onPartial } = props;
  const isStreaming = isStreamingProps(props);
  const [isPending, startTransition] = useTransition();

  const [state, dispatch] = useReducer(
    hookReducer<PartialReturnType<TActionKey>, FinalReturnType<TActionKey>>,
    {
      isSuccess: false,
      error: undefined,
      data: undefined,
      partialData: undefined,
    }
  );

  const mutate = useCallback(
    async (...input: Parameters<ServerAction>) => {
      dispatch({ type: 'START_REQUEST' });
      try {
        let response: Awaited<ReturnType<ServerAction>>;
        startTransition(async () => {
          response = await action(...input);
          if (isStreaming && response instanceof ReadableStream) {
            const reader = response.getReader();
            const decoder = new TextDecoder();
            try {
              while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                if (value) {
                  const chunk = decoder.decode(value, { stream: true }).trim();
                  try {
                    const parsed: BamlStreamResponse<PartialReturnType<TActionKey>, FinalReturnType<TActionKey>> = JSON.parse(chunk);
                    if (parsed.error) {
                      let error: Error | BamlValidationError | BamlClientFinishReasonError = new Error('Unknown error')

                      if (isBamlError(parsed.error)) {
                        if (parsed.error?.type === 'BamlValidationError') {
                          error = new BamlValidationError(
                            parsed.error.prompt,
                            parsed.error.raw_output,
                            parsed.error.message,
                          )
                        } else if (parsed.error.type === 'BamlClientFinishReasonError') {
                          error = new BamlClientFinishReasonError(
                            parsed.error.prompt,
                            parsed.error.raw_output,
                            parsed.error.message,
                          )
                        }
                      } else {
                        error = new Error(parsed.error.message)
                      }
                      throw error;
                    }
                    if (parsed.partial !== undefined) {
                      dispatch({ type: 'SET_PARTIAL', payload: parsed.partial });
                      onPartial?.(parsed.partial);
                    }
                    if (parsed.final !== undefined) {
                      dispatch({ type: 'SET_FINAL', payload: parsed.final });
                      onFinal?.(parsed.final);
                      return;
                    }
                  } catch (err: unknown) {
                    dispatch({ type: "SET_ERROR", payload: err as Error | BamlValidationError | BamlClientFinishReasonError });
                    onError?.(err as Error | BamlValidationError | BamlClientFinishReasonError);
                    break;
                  }
                }
              }
            } finally {
              reader.releaseLock();
            }
            return;
          }
          // Non‑streaming case
          dispatch({ type: 'SET_FINAL', payload: response });
          onFinal?.(response);
        });
        return response;
      } catch (error_: unknown) {
        dispatch({ type: 'SET_ERROR', payload: error_ as Error | BamlValidationError | BamlClientFinishReasonError });
        onError?.(error_ as Error | BamlValidationError | BamlClientFinishReasonError);
        throw error_;
      }
    },
    [action, isStreaming, onPartial, onFinal, onError]
  );

  const status = useMemo<"idle" | "pending" | "success" | "error">(() => {
    if (isPending) return "pending";
    if (state.error) return "error";
    if (state.isSuccess) return "success";
    return "idle";
  }, [isPending, state.error, state.isSuccess]);

  const result = {
    data: state.data,
    error: state.error,
    isError: !!state.error,
    isSuccess: state.isSuccess,
    isPending,
    mutate,
    status,
  };

  return {
    ...result,
    partialData: isStreaming ? state.partialData : undefined,
  };
}
/**
 * A specialized hook for the AaaSamOutputFormat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - recipe: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Recipe
 * - **Streaming Partial:** partial_types.Recipe
 * - **Streaming Final:** Recipe
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAaaSamOutputFormat();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAaaSamOutputFormat({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAaaSamOutputFormat(
  props: StreamingProps<'AaaSamOutputFormat'>
): StreamingHookResult<'AaaSamOutputFormat'>;

export function useAaaSamOutputFormat(
  props?: NonStreamingProps<'AaaSamOutputFormat'>
): NonStreamingHookResult<'AaaSamOutputFormat'>;

export function useAaaSamOutputFormat(
  props: HookProps<'AaaSamOutputFormat'> = {}
): StreamingHookResult<'AaaSamOutputFormat'> | NonStreamingHookResult<'AaaSamOutputFormat'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AaaSamOutputFormat, props);
  }

  return useBamlAction(Actions.AaaSamOutputFormat, props);
}
/**
 * A specialized hook for the AliasThatPointsToRecursiveType BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - list: LinkedListAliasNode
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LinkedListAliasNode
 * - **Streaming Partial:** partial_types.LinkedListAliasNode
 * - **Streaming Final:** LinkedListAliasNode
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasThatPointsToRecursiveType();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAliasThatPointsToRecursiveType({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasThatPointsToRecursiveType(
  props: StreamingProps<'AliasThatPointsToRecursiveType'>
): StreamingHookResult<'AliasThatPointsToRecursiveType'>;

export function useAliasThatPointsToRecursiveType(
  props?: NonStreamingProps<'AliasThatPointsToRecursiveType'>
): NonStreamingHookResult<'AliasThatPointsToRecursiveType'>;

export function useAliasThatPointsToRecursiveType(
  props: HookProps<'AliasThatPointsToRecursiveType'> = {}
): StreamingHookResult<'AliasThatPointsToRecursiveType'> | NonStreamingHookResult<'AliasThatPointsToRecursiveType'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AliasThatPointsToRecursiveType, props);
  }

  return useBamlAction(Actions.AliasThatPointsToRecursiveType, props);
}
/**
 * A specialized hook for the AliasWithMultipleAttrs BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<number,"gt_ten">
 * - **Streaming Partial:** Checked<number,"gt_ten">
 * - **Streaming Final:** Checked<number,"gt_ten">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasWithMultipleAttrs();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAliasWithMultipleAttrs({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasWithMultipleAttrs(
  props: StreamingProps<'AliasWithMultipleAttrs'>
): StreamingHookResult<'AliasWithMultipleAttrs'>;

export function useAliasWithMultipleAttrs(
  props?: NonStreamingProps<'AliasWithMultipleAttrs'>
): NonStreamingHookResult<'AliasWithMultipleAttrs'>;

export function useAliasWithMultipleAttrs(
  props: HookProps<'AliasWithMultipleAttrs'> = {}
): StreamingHookResult<'AliasWithMultipleAttrs'> | NonStreamingHookResult<'AliasWithMultipleAttrs'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AliasWithMultipleAttrs, props);
  }

  return useBamlAction(Actions.AliasWithMultipleAttrs, props);
}
/**
 * A specialized hook for the AliasedInputClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: InputClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputClass();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAliasedInputClass({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputClass(
  props: StreamingProps<'AliasedInputClass'>
): StreamingHookResult<'AliasedInputClass'>;

export function useAliasedInputClass(
  props?: NonStreamingProps<'AliasedInputClass'>
): NonStreamingHookResult<'AliasedInputClass'>;

export function useAliasedInputClass(
  props: HookProps<'AliasedInputClass'> = {}
): StreamingHookResult<'AliasedInputClass'> | NonStreamingHookResult<'AliasedInputClass'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AliasedInputClass, props);
  }

  return useBamlAction(Actions.AliasedInputClass, props);
}
/**
 * A specialized hook for the AliasedInputClass2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: InputClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputClass2();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAliasedInputClass2({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputClass2(
  props: StreamingProps<'AliasedInputClass2'>
): StreamingHookResult<'AliasedInputClass2'>;

export function useAliasedInputClass2(
  props?: NonStreamingProps<'AliasedInputClass2'>
): NonStreamingHookResult<'AliasedInputClass2'>;

export function useAliasedInputClass2(
  props: HookProps<'AliasedInputClass2'> = {}
): StreamingHookResult<'AliasedInputClass2'> | NonStreamingHookResult<'AliasedInputClass2'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AliasedInputClass2, props);
  }

  return useBamlAction(Actions.AliasedInputClass2, props);
}
/**
 * A specialized hook for the AliasedInputClassNested BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: InputClassNested
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputClassNested();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAliasedInputClassNested({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputClassNested(
  props: StreamingProps<'AliasedInputClassNested'>
): StreamingHookResult<'AliasedInputClassNested'>;

export function useAliasedInputClassNested(
  props?: NonStreamingProps<'AliasedInputClassNested'>
): NonStreamingHookResult<'AliasedInputClassNested'>;

export function useAliasedInputClassNested(
  props: HookProps<'AliasedInputClassNested'> = {}
): StreamingHookResult<'AliasedInputClassNested'> | NonStreamingHookResult<'AliasedInputClassNested'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AliasedInputClassNested, props);
  }

  return useBamlAction(Actions.AliasedInputClassNested, props);
}
/**
 * A specialized hook for the AliasedInputEnum BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: AliasedEnum
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputEnum();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAliasedInputEnum({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputEnum(
  props: StreamingProps<'AliasedInputEnum'>
): StreamingHookResult<'AliasedInputEnum'>;

export function useAliasedInputEnum(
  props?: NonStreamingProps<'AliasedInputEnum'>
): NonStreamingHookResult<'AliasedInputEnum'>;

export function useAliasedInputEnum(
  props: HookProps<'AliasedInputEnum'> = {}
): StreamingHookResult<'AliasedInputEnum'> | NonStreamingHookResult<'AliasedInputEnum'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AliasedInputEnum, props);
  }

  return useBamlAction(Actions.AliasedInputEnum, props);
}
/**
 * A specialized hook for the AliasedInputList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: AliasedEnum[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputList();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAliasedInputList({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputList(
  props: StreamingProps<'AliasedInputList'>
): StreamingHookResult<'AliasedInputList'>;

export function useAliasedInputList(
  props?: NonStreamingProps<'AliasedInputList'>
): NonStreamingHookResult<'AliasedInputList'>;

export function useAliasedInputList(
  props: HookProps<'AliasedInputList'> = {}
): StreamingHookResult<'AliasedInputList'> | NonStreamingHookResult<'AliasedInputList'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AliasedInputList, props);
  }

  return useBamlAction(Actions.AliasedInputList, props);
}
/**
 * A specialized hook for the AllowedOptionals BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - optionals: OptionalListAndMap
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** OptionalListAndMap
 * - **Streaming Partial:** partial_types.OptionalListAndMap
 * - **Streaming Final:** OptionalListAndMap
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAllowedOptionals();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAllowedOptionals({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAllowedOptionals(
  props: StreamingProps<'AllowedOptionals'>
): StreamingHookResult<'AllowedOptionals'>;

export function useAllowedOptionals(
  props?: NonStreamingProps<'AllowedOptionals'>
): NonStreamingHookResult<'AllowedOptionals'>;

export function useAllowedOptionals(
  props: HookProps<'AllowedOptionals'> = {}
): StreamingHookResult<'AllowedOptionals'> | NonStreamingHookResult<'AllowedOptionals'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AllowedOptionals, props);
  }

  return useBamlAction(Actions.AllowedOptionals, props);
}
/**
 * A specialized hook for the AssertFn BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - a: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAssertFn();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAssertFn({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAssertFn(
  props: StreamingProps<'AssertFn'>
): StreamingHookResult<'AssertFn'>;

export function useAssertFn(
  props?: NonStreamingProps<'AssertFn'>
): NonStreamingHookResult<'AssertFn'>;

export function useAssertFn(
  props: HookProps<'AssertFn'> = {}
): StreamingHookResult<'AssertFn'> | NonStreamingHookResult<'AssertFn'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AssertFn, props);
  }

  return useBamlAction(Actions.AssertFn, props);
}
/**
 * A specialized hook for the AudioInput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - aud: Audio
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAudioInput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useAudioInput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAudioInput(
  props: StreamingProps<'AudioInput'>
): StreamingHookResult<'AudioInput'>;

export function useAudioInput(
  props?: NonStreamingProps<'AudioInput'>
): NonStreamingHookResult<'AudioInput'>;

export function useAudioInput(
  props: HookProps<'AudioInput'> = {}
): StreamingHookResult<'AudioInput'> | NonStreamingHookResult<'AudioInput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.AudioInput, props);
  }

  return useBamlAction(Actions.AudioInput, props);
}
/**
 * A specialized hook for the BuildLinkedList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: number[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LinkedList
 * - **Streaming Partial:** partial_types.LinkedList
 * - **Streaming Final:** LinkedList
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useBuildLinkedList();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useBuildLinkedList({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useBuildLinkedList(
  props: StreamingProps<'BuildLinkedList'>
): StreamingHookResult<'BuildLinkedList'>;

export function useBuildLinkedList(
  props?: NonStreamingProps<'BuildLinkedList'>
): NonStreamingHookResult<'BuildLinkedList'>;

export function useBuildLinkedList(
  props: HookProps<'BuildLinkedList'> = {}
): StreamingHookResult<'BuildLinkedList'> | NonStreamingHookResult<'BuildLinkedList'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.BuildLinkedList, props);
  }

  return useBamlAction(Actions.BuildLinkedList, props);
}
/**
 * A specialized hook for the BuildTree BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: BinaryNode
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Tree
 * - **Streaming Partial:** partial_types.Tree
 * - **Streaming Final:** Tree
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useBuildTree();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useBuildTree({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useBuildTree(
  props: StreamingProps<'BuildTree'>
): StreamingHookResult<'BuildTree'>;

export function useBuildTree(
  props?: NonStreamingProps<'BuildTree'>
): NonStreamingHookResult<'BuildTree'>;

export function useBuildTree(
  props: HookProps<'BuildTree'> = {}
): StreamingHookResult<'BuildTree'> | NonStreamingHookResult<'BuildTree'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.BuildTree, props);
  }

  return useBamlAction(Actions.BuildTree, props);
}
/**
 * A specialized hook for the ClassThatPointsToRecursiveClassThroughAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - cls: ClassToRecAlias
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassToRecAlias
 * - **Streaming Partial:** partial_types.ClassToRecAlias
 * - **Streaming Final:** ClassToRecAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassThatPointsToRecursiveClassThroughAlias();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useClassThatPointsToRecursiveClassThroughAlias({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassThatPointsToRecursiveClassThroughAlias(
  props: StreamingProps<'ClassThatPointsToRecursiveClassThroughAlias'>
): StreamingHookResult<'ClassThatPointsToRecursiveClassThroughAlias'>;

export function useClassThatPointsToRecursiveClassThroughAlias(
  props?: NonStreamingProps<'ClassThatPointsToRecursiveClassThroughAlias'>
): NonStreamingHookResult<'ClassThatPointsToRecursiveClassThroughAlias'>;

export function useClassThatPointsToRecursiveClassThroughAlias(
  props: HookProps<'ClassThatPointsToRecursiveClassThroughAlias'> = {}
): StreamingHookResult<'ClassThatPointsToRecursiveClassThroughAlias'> | NonStreamingHookResult<'ClassThatPointsToRecursiveClassThroughAlias'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ClassThatPointsToRecursiveClassThroughAlias, props);
  }

  return useBamlAction(Actions.ClassThatPointsToRecursiveClassThroughAlias, props);
}
/**
 * A specialized hook for the ClassifyDynEnumTwo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (string | DynEnumTwo)
 * - **Streaming Partial:** (string | DynEnumTwo)
 * - **Streaming Final:** (string | DynEnumTwo)
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyDynEnumTwo();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useClassifyDynEnumTwo({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyDynEnumTwo(
  props: StreamingProps<'ClassifyDynEnumTwo'>
): StreamingHookResult<'ClassifyDynEnumTwo'>;

export function useClassifyDynEnumTwo(
  props?: NonStreamingProps<'ClassifyDynEnumTwo'>
): NonStreamingHookResult<'ClassifyDynEnumTwo'>;

export function useClassifyDynEnumTwo(
  props: HookProps<'ClassifyDynEnumTwo'> = {}
): StreamingHookResult<'ClassifyDynEnumTwo'> | NonStreamingHookResult<'ClassifyDynEnumTwo'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ClassifyDynEnumTwo, props);
  }

  return useBamlAction(Actions.ClassifyDynEnumTwo, props);
}
/**
 * A specialized hook for the ClassifyMessage BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category
 * - **Streaming Partial:** types.Category
 * - **Streaming Final:** Category
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyMessage();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useClassifyMessage({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage(
  props: StreamingProps<'ClassifyMessage'>
): StreamingHookResult<'ClassifyMessage'>;

export function useClassifyMessage(
  props?: NonStreamingProps<'ClassifyMessage'>
): NonStreamingHookResult<'ClassifyMessage'>;

export function useClassifyMessage(
  props: HookProps<'ClassifyMessage'> = {}
): StreamingHookResult<'ClassifyMessage'> | NonStreamingHookResult<'ClassifyMessage'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ClassifyMessage, props);
  }

  return useBamlAction(Actions.ClassifyMessage, props);
}
/**
 * A specialized hook for the ClassifyMessage2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category
 * - **Streaming Partial:** types.Category
 * - **Streaming Final:** Category
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyMessage2();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useClassifyMessage2({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage2(
  props: StreamingProps<'ClassifyMessage2'>
): StreamingHookResult<'ClassifyMessage2'>;

export function useClassifyMessage2(
  props?: NonStreamingProps<'ClassifyMessage2'>
): NonStreamingHookResult<'ClassifyMessage2'>;

export function useClassifyMessage2(
  props: HookProps<'ClassifyMessage2'> = {}
): StreamingHookResult<'ClassifyMessage2'> | NonStreamingHookResult<'ClassifyMessage2'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ClassifyMessage2, props);
  }

  return useBamlAction(Actions.ClassifyMessage2, props);
}
/**
 * A specialized hook for the ClassifyMessage3 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category
 * - **Streaming Partial:** types.Category
 * - **Streaming Final:** Category
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyMessage3();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useClassifyMessage3({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage3(
  props: StreamingProps<'ClassifyMessage3'>
): StreamingHookResult<'ClassifyMessage3'>;

export function useClassifyMessage3(
  props?: NonStreamingProps<'ClassifyMessage3'>
): NonStreamingHookResult<'ClassifyMessage3'>;

export function useClassifyMessage3(
  props: HookProps<'ClassifyMessage3'> = {}
): StreamingHookResult<'ClassifyMessage3'> | NonStreamingHookResult<'ClassifyMessage3'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ClassifyMessage3, props);
  }

  return useBamlAction(Actions.ClassifyMessage3, props);
}
/**
 * A specialized hook for the Completion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - prefix: string
 *
 * - suffix: string
 *
 * - language: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useCompletion();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useCompletion({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useCompletion(
  props: StreamingProps<'Completion'>
): StreamingHookResult<'Completion'>;

export function useCompletion(
  props?: NonStreamingProps<'Completion'>
): NonStreamingHookResult<'Completion'>;

export function useCompletion(
  props: HookProps<'Completion'> = {}
): StreamingHookResult<'Completion'> | NonStreamingHookResult<'Completion'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.Completion, props);
  }

  return useBamlAction(Actions.Completion, props);
}
/**
 * A specialized hook for the CustomTask BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** BookOrder | FlightConfirmation | GroceryReceipt
 * - **Streaming Partial:** ((partial_types.BookOrder | null) | (partial_types.FlightConfirmation | null) | (partial_types.GroceryReceipt | null))
 * - **Streaming Final:** BookOrder | FlightConfirmation | GroceryReceipt
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useCustomTask();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useCustomTask({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useCustomTask(
  props: StreamingProps<'CustomTask'>
): StreamingHookResult<'CustomTask'>;

export function useCustomTask(
  props?: NonStreamingProps<'CustomTask'>
): NonStreamingHookResult<'CustomTask'>;

export function useCustomTask(
  props: HookProps<'CustomTask'> = {}
): StreamingHookResult<'CustomTask'> | NonStreamingHookResult<'CustomTask'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.CustomTask, props);
  }

  return useBamlAction(Actions.CustomTask, props);
}
/**
 * A specialized hook for the DescribeImage BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDescribeImage({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage(
  props: StreamingProps<'DescribeImage'>
): StreamingHookResult<'DescribeImage'>;

export function useDescribeImage(
  props?: NonStreamingProps<'DescribeImage'>
): NonStreamingHookResult<'DescribeImage'>;

export function useDescribeImage(
  props: HookProps<'DescribeImage'> = {}
): StreamingHookResult<'DescribeImage'> | NonStreamingHookResult<'DescribeImage'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DescribeImage, props);
  }

  return useBamlAction(Actions.DescribeImage, props);
}
/**
 * A specialized hook for the DescribeImage2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage2();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDescribeImage2({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage2(
  props: StreamingProps<'DescribeImage2'>
): StreamingHookResult<'DescribeImage2'>;

export function useDescribeImage2(
  props?: NonStreamingProps<'DescribeImage2'>
): NonStreamingHookResult<'DescribeImage2'>;

export function useDescribeImage2(
  props: HookProps<'DescribeImage2'> = {}
): StreamingHookResult<'DescribeImage2'> | NonStreamingHookResult<'DescribeImage2'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DescribeImage2, props);
  }

  return useBamlAction(Actions.DescribeImage2, props);
}
/**
 * A specialized hook for the DescribeImage3 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage3();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDescribeImage3({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage3(
  props: StreamingProps<'DescribeImage3'>
): StreamingHookResult<'DescribeImage3'>;

export function useDescribeImage3(
  props?: NonStreamingProps<'DescribeImage3'>
): NonStreamingHookResult<'DescribeImage3'>;

export function useDescribeImage3(
  props: HookProps<'DescribeImage3'> = {}
): StreamingHookResult<'DescribeImage3'> | NonStreamingHookResult<'DescribeImage3'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DescribeImage3, props);
  }

  return useBamlAction(Actions.DescribeImage3, props);
}
/**
 * A specialized hook for the DescribeImage4 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage4();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDescribeImage4({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage4(
  props: StreamingProps<'DescribeImage4'>
): StreamingHookResult<'DescribeImage4'>;

export function useDescribeImage4(
  props?: NonStreamingProps<'DescribeImage4'>
): NonStreamingHookResult<'DescribeImage4'>;

export function useDescribeImage4(
  props: HookProps<'DescribeImage4'> = {}
): StreamingHookResult<'DescribeImage4'> | NonStreamingHookResult<'DescribeImage4'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DescribeImage4, props);
  }

  return useBamlAction(Actions.DescribeImage4, props);
}
/**
 * A specialized hook for the DifferentiateUnions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** OriginalA | OriginalB
 * - **Streaming Partial:** ((partial_types.OriginalA | null) | (partial_types.OriginalB | null))
 * - **Streaming Final:** OriginalA | OriginalB
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDifferentiateUnions();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDifferentiateUnions({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDifferentiateUnions(
  props: StreamingProps<'DifferentiateUnions'>
): StreamingHookResult<'DifferentiateUnions'>;

export function useDifferentiateUnions(
  props?: NonStreamingProps<'DifferentiateUnions'>
): NonStreamingHookResult<'DifferentiateUnions'>;

export function useDifferentiateUnions(
  props: HookProps<'DifferentiateUnions'> = {}
): StreamingHookResult<'DifferentiateUnions'> | NonStreamingHookResult<'DifferentiateUnions'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DifferentiateUnions, props);
  }

  return useBamlAction(Actions.DifferentiateUnions, props);
}
/**
 * A specialized hook for the DummyOutputFunction BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DummyOutput
 * - **Streaming Partial:** partial_types.DummyOutput
 * - **Streaming Final:** DummyOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDummyOutputFunction();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDummyOutputFunction({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDummyOutputFunction(
  props: StreamingProps<'DummyOutputFunction'>
): StreamingHookResult<'DummyOutputFunction'>;

export function useDummyOutputFunction(
  props?: NonStreamingProps<'DummyOutputFunction'>
): NonStreamingHookResult<'DummyOutputFunction'>;

export function useDummyOutputFunction(
  props: HookProps<'DummyOutputFunction'> = {}
): StreamingHookResult<'DummyOutputFunction'> | NonStreamingHookResult<'DummyOutputFunction'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DummyOutputFunction, props);
  }

  return useBamlAction(Actions.DummyOutputFunction, props);
}
/**
 * A specialized hook for the DynamicFunc BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: DynamicClassOne
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynamicClassTwo
 * - **Streaming Partial:** partial_types.DynamicClassTwo
 * - **Streaming Final:** DynamicClassTwo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDynamicFunc();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDynamicFunc({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDynamicFunc(
  props: StreamingProps<'DynamicFunc'>
): StreamingHookResult<'DynamicFunc'>;

export function useDynamicFunc(
  props?: NonStreamingProps<'DynamicFunc'>
): NonStreamingHookResult<'DynamicFunc'>;

export function useDynamicFunc(
  props: HookProps<'DynamicFunc'> = {}
): StreamingHookResult<'DynamicFunc'> | NonStreamingHookResult<'DynamicFunc'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DynamicFunc, props);
  }

  return useBamlAction(Actions.DynamicFunc, props);
}
/**
 * A specialized hook for the DynamicInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: DynInputOutput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynInputOutput
 * - **Streaming Partial:** partial_types.DynInputOutput
 * - **Streaming Final:** DynInputOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDynamicInputOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDynamicInputOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDynamicInputOutput(
  props: StreamingProps<'DynamicInputOutput'>
): StreamingHookResult<'DynamicInputOutput'>;

export function useDynamicInputOutput(
  props?: NonStreamingProps<'DynamicInputOutput'>
): NonStreamingHookResult<'DynamicInputOutput'>;

export function useDynamicInputOutput(
  props: HookProps<'DynamicInputOutput'> = {}
): StreamingHookResult<'DynamicInputOutput'> | NonStreamingHookResult<'DynamicInputOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DynamicInputOutput, props);
  }

  return useBamlAction(Actions.DynamicInputOutput, props);
}
/**
 * A specialized hook for the DynamicListInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: DynInputOutput[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynInputOutput[]
 * - **Streaming Partial:** (partial_types.DynInputOutput | null)[]
 * - **Streaming Final:** DynInputOutput[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDynamicListInputOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useDynamicListInputOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDynamicListInputOutput(
  props: StreamingProps<'DynamicListInputOutput'>
): StreamingHookResult<'DynamicListInputOutput'>;

export function useDynamicListInputOutput(
  props?: NonStreamingProps<'DynamicListInputOutput'>
): NonStreamingHookResult<'DynamicListInputOutput'>;

export function useDynamicListInputOutput(
  props: HookProps<'DynamicListInputOutput'> = {}
): StreamingHookResult<'DynamicListInputOutput'> | NonStreamingHookResult<'DynamicListInputOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.DynamicListInputOutput, props);
  }

  return useBamlAction(Actions.DynamicListInputOutput, props);
}
/**
 * A specialized hook for the ExpectFailure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExpectFailure();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExpectFailure({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExpectFailure(
  props: StreamingProps<'ExpectFailure'>
): StreamingHookResult<'ExpectFailure'>;

export function useExpectFailure(
  props?: NonStreamingProps<'ExpectFailure'>
): NonStreamingHookResult<'ExpectFailure'>;

export function useExpectFailure(
  props: HookProps<'ExpectFailure'> = {}
): StreamingHookResult<'ExpectFailure'> | NonStreamingHookResult<'ExpectFailure'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExpectFailure, props);
  }

  return useBamlAction(Actions.ExpectFailure, props);
}
/**
 * A specialized hook for the ExtractContactInfo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - document: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ContactInfo
 * - **Streaming Partial:** partial_types.ContactInfo
 * - **Streaming Final:** ContactInfo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractContactInfo();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractContactInfo({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractContactInfo(
  props: StreamingProps<'ExtractContactInfo'>
): StreamingHookResult<'ExtractContactInfo'>;

export function useExtractContactInfo(
  props?: NonStreamingProps<'ExtractContactInfo'>
): NonStreamingHookResult<'ExtractContactInfo'>;

export function useExtractContactInfo(
  props: HookProps<'ExtractContactInfo'> = {}
): StreamingHookResult<'ExtractContactInfo'> | NonStreamingHookResult<'ExtractContactInfo'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractContactInfo, props);
  }

  return useBamlAction(Actions.ExtractContactInfo, props);
}
/**
 * A specialized hook for the ExtractHobby BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (string | Hobby)[]
 * - **Streaming Partial:** (string | Hobby | null)[]
 * - **Streaming Final:** (string | Hobby)[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractHobby();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractHobby({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractHobby(
  props: StreamingProps<'ExtractHobby'>
): StreamingHookResult<'ExtractHobby'>;

export function useExtractHobby(
  props?: NonStreamingProps<'ExtractHobby'>
): NonStreamingHookResult<'ExtractHobby'>;

export function useExtractHobby(
  props: HookProps<'ExtractHobby'> = {}
): StreamingHookResult<'ExtractHobby'> | NonStreamingHookResult<'ExtractHobby'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractHobby, props);
  }

  return useBamlAction(Actions.ExtractHobby, props);
}
/**
 * A specialized hook for the ExtractNames BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string[]
 * - **Streaming Partial:** (string | null)[]
 * - **Streaming Final:** string[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractNames();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractNames({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractNames(
  props: StreamingProps<'ExtractNames'>
): StreamingHookResult<'ExtractNames'>;

export function useExtractNames(
  props?: NonStreamingProps<'ExtractNames'>
): NonStreamingHookResult<'ExtractNames'>;

export function useExtractNames(
  props: HookProps<'ExtractNames'> = {}
): StreamingHookResult<'ExtractNames'> | NonStreamingHookResult<'ExtractNames'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractNames, props);
  }

  return useBamlAction(Actions.ExtractNames, props);
}
/**
 * A specialized hook for the ExtractPeople BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Person[]
 * - **Streaming Partial:** (partial_types.Person | null)[]
 * - **Streaming Final:** Person[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractPeople();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractPeople({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractPeople(
  props: StreamingProps<'ExtractPeople'>
): StreamingHookResult<'ExtractPeople'>;

export function useExtractPeople(
  props?: NonStreamingProps<'ExtractPeople'>
): NonStreamingHookResult<'ExtractPeople'>;

export function useExtractPeople(
  props: HookProps<'ExtractPeople'> = {}
): StreamingHookResult<'ExtractPeople'> | NonStreamingHookResult<'ExtractPeople'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractPeople, props);
  }

  return useBamlAction(Actions.ExtractPeople, props);
}
/**
 * A specialized hook for the ExtractReceiptInfo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - email: string
 *
 * - reason: "curiosity" | "personal_finance"
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ReceiptInfo
 * - **Streaming Partial:** partial_types.ReceiptInfo
 * - **Streaming Final:** ReceiptInfo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractReceiptInfo();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractReceiptInfo({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractReceiptInfo(
  props: StreamingProps<'ExtractReceiptInfo'>
): StreamingHookResult<'ExtractReceiptInfo'>;

export function useExtractReceiptInfo(
  props?: NonStreamingProps<'ExtractReceiptInfo'>
): NonStreamingHookResult<'ExtractReceiptInfo'>;

export function useExtractReceiptInfo(
  props: HookProps<'ExtractReceiptInfo'> = {}
): StreamingHookResult<'ExtractReceiptInfo'> | NonStreamingHookResult<'ExtractReceiptInfo'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractReceiptInfo, props);
  }

  return useBamlAction(Actions.ExtractReceiptInfo, props);
}
/**
 * A specialized hook for the ExtractResume BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - resume: string
 *
 * - img (optional): Image | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Resume
 * - **Streaming Partial:** partial_types.Resume
 * - **Streaming Final:** Resume
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractResume();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractResume({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResume(
  props: StreamingProps<'ExtractResume'>
): StreamingHookResult<'ExtractResume'>;

export function useExtractResume(
  props?: NonStreamingProps<'ExtractResume'>
): NonStreamingHookResult<'ExtractResume'>;

export function useExtractResume(
  props: HookProps<'ExtractResume'> = {}
): StreamingHookResult<'ExtractResume'> | NonStreamingHookResult<'ExtractResume'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractResume, props);
  }

  return useBamlAction(Actions.ExtractResume, props);
}
/**
 * A specialized hook for the ExtractResume2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - resume: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Resume
 * - **Streaming Partial:** partial_types.Resume
 * - **Streaming Final:** Resume
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractResume2();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useExtractResume2({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResume2(
  props: StreamingProps<'ExtractResume2'>
): StreamingHookResult<'ExtractResume2'>;

export function useExtractResume2(
  props?: NonStreamingProps<'ExtractResume2'>
): NonStreamingHookResult<'ExtractResume2'>;

export function useExtractResume2(
  props: HookProps<'ExtractResume2'> = {}
): StreamingHookResult<'ExtractResume2'> | NonStreamingHookResult<'ExtractResume2'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ExtractResume2, props);
  }

  return useBamlAction(Actions.ExtractResume2, props);
}
/**
 * A specialized hook for the FnClassOptionalOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassOptionalOutput | null
 * - **Streaming Partial:** ((partial_types.ClassOptionalOutput | null) | null)
 * - **Streaming Final:** ClassOptionalOutput | null
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnClassOptionalOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnClassOptionalOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnClassOptionalOutput(
  props: StreamingProps<'FnClassOptionalOutput'>
): StreamingHookResult<'FnClassOptionalOutput'>;

export function useFnClassOptionalOutput(
  props?: NonStreamingProps<'FnClassOptionalOutput'>
): NonStreamingHookResult<'FnClassOptionalOutput'>;

export function useFnClassOptionalOutput(
  props: HookProps<'FnClassOptionalOutput'> = {}
): StreamingHookResult<'FnClassOptionalOutput'> | NonStreamingHookResult<'FnClassOptionalOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnClassOptionalOutput, props);
  }

  return useBamlAction(Actions.FnClassOptionalOutput, props);
}
/**
 * A specialized hook for the FnClassOptionalOutput2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassOptionalOutput2 | null
 * - **Streaming Partial:** ((partial_types.ClassOptionalOutput2 | null) | null)
 * - **Streaming Final:** ClassOptionalOutput2 | null
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnClassOptionalOutput2();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnClassOptionalOutput2({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnClassOptionalOutput2(
  props: StreamingProps<'FnClassOptionalOutput2'>
): StreamingHookResult<'FnClassOptionalOutput2'>;

export function useFnClassOptionalOutput2(
  props?: NonStreamingProps<'FnClassOptionalOutput2'>
): NonStreamingHookResult<'FnClassOptionalOutput2'>;

export function useFnClassOptionalOutput2(
  props: HookProps<'FnClassOptionalOutput2'> = {}
): StreamingHookResult<'FnClassOptionalOutput2'> | NonStreamingHookResult<'FnClassOptionalOutput2'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnClassOptionalOutput2, props);
  }

  return useBamlAction(Actions.FnClassOptionalOutput2, props);
}
/**
 * A specialized hook for the FnEnumListOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** EnumOutput[]
 * - **Streaming Partial:** (EnumOutput | null)[]
 * - **Streaming Final:** EnumOutput[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnEnumListOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnEnumListOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnEnumListOutput(
  props: StreamingProps<'FnEnumListOutput'>
): StreamingHookResult<'FnEnumListOutput'>;

export function useFnEnumListOutput(
  props?: NonStreamingProps<'FnEnumListOutput'>
): NonStreamingHookResult<'FnEnumListOutput'>;

export function useFnEnumListOutput(
  props: HookProps<'FnEnumListOutput'> = {}
): StreamingHookResult<'FnEnumListOutput'> | NonStreamingHookResult<'FnEnumListOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnEnumListOutput, props);
  }

  return useBamlAction(Actions.FnEnumListOutput, props);
}
/**
 * A specialized hook for the FnEnumOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** EnumOutput
 * - **Streaming Partial:** types.EnumOutput
 * - **Streaming Final:** EnumOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnEnumOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnEnumOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnEnumOutput(
  props: StreamingProps<'FnEnumOutput'>
): StreamingHookResult<'FnEnumOutput'>;

export function useFnEnumOutput(
  props?: NonStreamingProps<'FnEnumOutput'>
): NonStreamingHookResult<'FnEnumOutput'>;

export function useFnEnumOutput(
  props: HookProps<'FnEnumOutput'> = {}
): StreamingHookResult<'FnEnumOutput'> | NonStreamingHookResult<'FnEnumOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnEnumOutput, props);
  }

  return useBamlAction(Actions.FnEnumOutput, props);
}
/**
 * A specialized hook for the FnLiteralClassInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: LiteralClassHello
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LiteralClassHello
 * - **Streaming Partial:** partial_types.LiteralClassHello
 * - **Streaming Final:** LiteralClassHello
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnLiteralClassInputOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnLiteralClassInputOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnLiteralClassInputOutput(
  props: StreamingProps<'FnLiteralClassInputOutput'>
): StreamingHookResult<'FnLiteralClassInputOutput'>;

export function useFnLiteralClassInputOutput(
  props?: NonStreamingProps<'FnLiteralClassInputOutput'>
): NonStreamingHookResult<'FnLiteralClassInputOutput'>;

export function useFnLiteralClassInputOutput(
  props: HookProps<'FnLiteralClassInputOutput'> = {}
): StreamingHookResult<'FnLiteralClassInputOutput'> | NonStreamingHookResult<'FnLiteralClassInputOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnLiteralClassInputOutput, props);
  }

  return useBamlAction(Actions.FnLiteralClassInputOutput, props);
}
/**
 * A specialized hook for the FnLiteralUnionClassInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: LiteralClassOne | LiteralClassTwo
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LiteralClassOne | LiteralClassTwo
 * - **Streaming Partial:** ((partial_types.LiteralClassOne | null) | (partial_types.LiteralClassTwo | null))
 * - **Streaming Final:** LiteralClassOne | LiteralClassTwo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnLiteralUnionClassInputOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnLiteralUnionClassInputOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnLiteralUnionClassInputOutput(
  props: StreamingProps<'FnLiteralUnionClassInputOutput'>
): StreamingHookResult<'FnLiteralUnionClassInputOutput'>;

export function useFnLiteralUnionClassInputOutput(
  props?: NonStreamingProps<'FnLiteralUnionClassInputOutput'>
): NonStreamingHookResult<'FnLiteralUnionClassInputOutput'>;

export function useFnLiteralUnionClassInputOutput(
  props: HookProps<'FnLiteralUnionClassInputOutput'> = {}
): StreamingHookResult<'FnLiteralUnionClassInputOutput'> | NonStreamingHookResult<'FnLiteralUnionClassInputOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnLiteralUnionClassInputOutput, props);
  }

  return useBamlAction(Actions.FnLiteralUnionClassInputOutput, props);
}
/**
 * A specialized hook for the FnNamedArgsSingleStringOptional BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myString (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnNamedArgsSingleStringOptional();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnNamedArgsSingleStringOptional({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnNamedArgsSingleStringOptional(
  props: StreamingProps<'FnNamedArgsSingleStringOptional'>
): StreamingHookResult<'FnNamedArgsSingleStringOptional'>;

export function useFnNamedArgsSingleStringOptional(
  props?: NonStreamingProps<'FnNamedArgsSingleStringOptional'>
): NonStreamingHookResult<'FnNamedArgsSingleStringOptional'>;

export function useFnNamedArgsSingleStringOptional(
  props: HookProps<'FnNamedArgsSingleStringOptional'> = {}
): StreamingHookResult<'FnNamedArgsSingleStringOptional'> | NonStreamingHookResult<'FnNamedArgsSingleStringOptional'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnNamedArgsSingleStringOptional, props);
  }

  return useBamlAction(Actions.FnNamedArgsSingleStringOptional, props);
}
/**
 * A specialized hook for the FnOutputBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** boolean
 * - **Streaming Partial:** boolean
 * - **Streaming Final:** boolean
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputBool();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputBool({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputBool(
  props: StreamingProps<'FnOutputBool'>
): StreamingHookResult<'FnOutputBool'>;

export function useFnOutputBool(
  props?: NonStreamingProps<'FnOutputBool'>
): NonStreamingHookResult<'FnOutputBool'>;

export function useFnOutputBool(
  props: HookProps<'FnOutputBool'> = {}
): StreamingHookResult<'FnOutputBool'> | NonStreamingHookResult<'FnOutputBool'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputBool, props);
  }

  return useBamlAction(Actions.FnOutputBool, props);
}
/**
 * A specialized hook for the FnOutputClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestOutputClass
 * - **Streaming Partial:** partial_types.TestOutputClass
 * - **Streaming Final:** TestOutputClass
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClass();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputClass({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClass(
  props: StreamingProps<'FnOutputClass'>
): StreamingHookResult<'FnOutputClass'>;

export function useFnOutputClass(
  props?: NonStreamingProps<'FnOutputClass'>
): NonStreamingHookResult<'FnOutputClass'>;

export function useFnOutputClass(
  props: HookProps<'FnOutputClass'> = {}
): StreamingHookResult<'FnOutputClass'> | NonStreamingHookResult<'FnOutputClass'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputClass, props);
  }

  return useBamlAction(Actions.FnOutputClass, props);
}
/**
 * A specialized hook for the FnOutputClassList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestOutputClass[]
 * - **Streaming Partial:** (partial_types.TestOutputClass | null)[]
 * - **Streaming Final:** TestOutputClass[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClassList();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputClassList({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClassList(
  props: StreamingProps<'FnOutputClassList'>
): StreamingHookResult<'FnOutputClassList'>;

export function useFnOutputClassList(
  props?: NonStreamingProps<'FnOutputClassList'>
): NonStreamingHookResult<'FnOutputClassList'>;

export function useFnOutputClassList(
  props: HookProps<'FnOutputClassList'> = {}
): StreamingHookResult<'FnOutputClassList'> | NonStreamingHookResult<'FnOutputClassList'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputClassList, props);
  }

  return useBamlAction(Actions.FnOutputClassList, props);
}
/**
 * A specialized hook for the FnOutputClassNested BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestClassNested
 * - **Streaming Partial:** partial_types.TestClassNested
 * - **Streaming Final:** TestClassNested
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClassNested();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputClassNested({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClassNested(
  props: StreamingProps<'FnOutputClassNested'>
): StreamingHookResult<'FnOutputClassNested'>;

export function useFnOutputClassNested(
  props?: NonStreamingProps<'FnOutputClassNested'>
): NonStreamingHookResult<'FnOutputClassNested'>;

export function useFnOutputClassNested(
  props: HookProps<'FnOutputClassNested'> = {}
): StreamingHookResult<'FnOutputClassNested'> | NonStreamingHookResult<'FnOutputClassNested'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputClassNested, props);
  }

  return useBamlAction(Actions.FnOutputClassNested, props);
}
/**
 * A specialized hook for the FnOutputClassWithEnum BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestClassWithEnum
 * - **Streaming Partial:** partial_types.TestClassWithEnum
 * - **Streaming Final:** TestClassWithEnum
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClassWithEnum();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputClassWithEnum({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClassWithEnum(
  props: StreamingProps<'FnOutputClassWithEnum'>
): StreamingHookResult<'FnOutputClassWithEnum'>;

export function useFnOutputClassWithEnum(
  props?: NonStreamingProps<'FnOutputClassWithEnum'>
): NonStreamingHookResult<'FnOutputClassWithEnum'>;

export function useFnOutputClassWithEnum(
  props: HookProps<'FnOutputClassWithEnum'> = {}
): StreamingHookResult<'FnOutputClassWithEnum'> | NonStreamingHookResult<'FnOutputClassWithEnum'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputClassWithEnum, props);
  }

  return useBamlAction(Actions.FnOutputClassWithEnum, props);
}
/**
 * A specialized hook for the FnOutputInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputInt();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputInt({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputInt(
  props: StreamingProps<'FnOutputInt'>
): StreamingHookResult<'FnOutputInt'>;

export function useFnOutputInt(
  props?: NonStreamingProps<'FnOutputInt'>
): NonStreamingHookResult<'FnOutputInt'>;

export function useFnOutputInt(
  props: HookProps<'FnOutputInt'> = {}
): StreamingHookResult<'FnOutputInt'> | NonStreamingHookResult<'FnOutputInt'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputInt, props);
  }

  return useBamlAction(Actions.FnOutputInt, props);
}
/**
 * A specialized hook for the FnOutputLiteralBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** false
 * - **Streaming Partial:** false
 * - **Streaming Final:** false
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputLiteralBool();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputLiteralBool({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputLiteralBool(
  props: StreamingProps<'FnOutputLiteralBool'>
): StreamingHookResult<'FnOutputLiteralBool'>;

export function useFnOutputLiteralBool(
  props?: NonStreamingProps<'FnOutputLiteralBool'>
): NonStreamingHookResult<'FnOutputLiteralBool'>;

export function useFnOutputLiteralBool(
  props: HookProps<'FnOutputLiteralBool'> = {}
): StreamingHookResult<'FnOutputLiteralBool'> | NonStreamingHookResult<'FnOutputLiteralBool'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputLiteralBool, props);
  }

  return useBamlAction(Actions.FnOutputLiteralBool, props);
}
/**
 * A specialized hook for the FnOutputLiteralInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** 5
 * - **Streaming Partial:** 5
 * - **Streaming Final:** 5
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputLiteralInt();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputLiteralInt({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputLiteralInt(
  props: StreamingProps<'FnOutputLiteralInt'>
): StreamingHookResult<'FnOutputLiteralInt'>;

export function useFnOutputLiteralInt(
  props?: NonStreamingProps<'FnOutputLiteralInt'>
): NonStreamingHookResult<'FnOutputLiteralInt'>;

export function useFnOutputLiteralInt(
  props: HookProps<'FnOutputLiteralInt'> = {}
): StreamingHookResult<'FnOutputLiteralInt'> | NonStreamingHookResult<'FnOutputLiteralInt'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputLiteralInt, props);
  }

  return useBamlAction(Actions.FnOutputLiteralInt, props);
}
/**
 * A specialized hook for the FnOutputLiteralString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** "example output"
 * - **Streaming Partial:** "example output"
 * - **Streaming Final:** "example output"
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputLiteralString();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputLiteralString({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputLiteralString(
  props: StreamingProps<'FnOutputLiteralString'>
): StreamingHookResult<'FnOutputLiteralString'>;

export function useFnOutputLiteralString(
  props?: NonStreamingProps<'FnOutputLiteralString'>
): NonStreamingHookResult<'FnOutputLiteralString'>;

export function useFnOutputLiteralString(
  props: HookProps<'FnOutputLiteralString'> = {}
): StreamingHookResult<'FnOutputLiteralString'> | NonStreamingHookResult<'FnOutputLiteralString'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputLiteralString, props);
  }

  return useBamlAction(Actions.FnOutputLiteralString, props);
}
/**
 * A specialized hook for the FnOutputStringList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string[]
 * - **Streaming Partial:** (string | null)[]
 * - **Streaming Final:** string[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputStringList();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnOutputStringList({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputStringList(
  props: StreamingProps<'FnOutputStringList'>
): StreamingHookResult<'FnOutputStringList'>;

export function useFnOutputStringList(
  props?: NonStreamingProps<'FnOutputStringList'>
): NonStreamingHookResult<'FnOutputStringList'>;

export function useFnOutputStringList(
  props: HookProps<'FnOutputStringList'> = {}
): StreamingHookResult<'FnOutputStringList'> | NonStreamingHookResult<'FnOutputStringList'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnOutputStringList, props);
  }

  return useBamlAction(Actions.FnOutputStringList, props);
}
/**
 * A specialized hook for the FnTestAliasedEnumOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestEnum
 * - **Streaming Partial:** types.TestEnum
 * - **Streaming Final:** TestEnum
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnTestAliasedEnumOutput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnTestAliasedEnumOutput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnTestAliasedEnumOutput(
  props: StreamingProps<'FnTestAliasedEnumOutput'>
): StreamingHookResult<'FnTestAliasedEnumOutput'>;

export function useFnTestAliasedEnumOutput(
  props?: NonStreamingProps<'FnTestAliasedEnumOutput'>
): NonStreamingHookResult<'FnTestAliasedEnumOutput'>;

export function useFnTestAliasedEnumOutput(
  props: HookProps<'FnTestAliasedEnumOutput'> = {}
): StreamingHookResult<'FnTestAliasedEnumOutput'> | NonStreamingHookResult<'FnTestAliasedEnumOutput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnTestAliasedEnumOutput, props);
  }

  return useBamlAction(Actions.FnTestAliasedEnumOutput, props);
}
/**
 * A specialized hook for the FnTestClassAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestClassAlias
 * - **Streaming Partial:** partial_types.TestClassAlias
 * - **Streaming Final:** TestClassAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnTestClassAlias();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnTestClassAlias({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnTestClassAlias(
  props: StreamingProps<'FnTestClassAlias'>
): StreamingHookResult<'FnTestClassAlias'>;

export function useFnTestClassAlias(
  props?: NonStreamingProps<'FnTestClassAlias'>
): NonStreamingHookResult<'FnTestClassAlias'>;

export function useFnTestClassAlias(
  props: HookProps<'FnTestClassAlias'> = {}
): StreamingHookResult<'FnTestClassAlias'> | NonStreamingHookResult<'FnTestClassAlias'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnTestClassAlias, props);
  }

  return useBamlAction(Actions.FnTestClassAlias, props);
}
/**
 * A specialized hook for the FnTestNamedArgsSingleEnum BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleEnum
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnTestNamedArgsSingleEnum();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useFnTestNamedArgsSingleEnum({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnTestNamedArgsSingleEnum(
  props: StreamingProps<'FnTestNamedArgsSingleEnum'>
): StreamingHookResult<'FnTestNamedArgsSingleEnum'>;

export function useFnTestNamedArgsSingleEnum(
  props?: NonStreamingProps<'FnTestNamedArgsSingleEnum'>
): NonStreamingHookResult<'FnTestNamedArgsSingleEnum'>;

export function useFnTestNamedArgsSingleEnum(
  props: HookProps<'FnTestNamedArgsSingleEnum'> = {}
): StreamingHookResult<'FnTestNamedArgsSingleEnum'> | NonStreamingHookResult<'FnTestNamedArgsSingleEnum'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.FnTestNamedArgsSingleEnum, props);
  }

  return useBamlAction(Actions.FnTestNamedArgsSingleEnum, props);
}
/**
 * A specialized hook for the GetDataType BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RaysData
 * - **Streaming Partial:** partial_types.RaysData
 * - **Streaming Final:** RaysData
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGetDataType();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useGetDataType({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetDataType(
  props: StreamingProps<'GetDataType'>
): StreamingHookResult<'GetDataType'>;

export function useGetDataType(
  props?: NonStreamingProps<'GetDataType'>
): NonStreamingHookResult<'GetDataType'>;

export function useGetDataType(
  props: HookProps<'GetDataType'> = {}
): StreamingHookResult<'GetDataType'> | NonStreamingHookResult<'GetDataType'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.GetDataType, props);
  }

  return useBamlAction(Actions.GetDataType, props);
}
/**
 * A specialized hook for the GetOrderInfo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - email: Email
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** OrderInfo
 * - **Streaming Partial:** partial_types.OrderInfo
 * - **Streaming Final:** OrderInfo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGetOrderInfo();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useGetOrderInfo({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetOrderInfo(
  props: StreamingProps<'GetOrderInfo'>
): StreamingHookResult<'GetOrderInfo'>;

export function useGetOrderInfo(
  props?: NonStreamingProps<'GetOrderInfo'>
): NonStreamingHookResult<'GetOrderInfo'>;

export function useGetOrderInfo(
  props: HookProps<'GetOrderInfo'> = {}
): StreamingHookResult<'GetOrderInfo'> | NonStreamingHookResult<'GetOrderInfo'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.GetOrderInfo, props);
  }

  return useBamlAction(Actions.GetOrderInfo, props);
}
/**
 * A specialized hook for the GetQuery BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - query: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SearchParams
 * - **Streaming Partial:** partial_types.SearchParams
 * - **Streaming Final:** SearchParams
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGetQuery();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useGetQuery({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetQuery(
  props: StreamingProps<'GetQuery'>
): StreamingHookResult<'GetQuery'>;

export function useGetQuery(
  props?: NonStreamingProps<'GetQuery'>
): NonStreamingHookResult<'GetQuery'>;

export function useGetQuery(
  props: HookProps<'GetQuery'> = {}
): StreamingHookResult<'GetQuery'> | NonStreamingHookResult<'GetQuery'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.GetQuery, props);
  }

  return useBamlAction(Actions.GetQuery, props);
}
/**
 * A specialized hook for the InOutEnumMapKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - i1: Partial<Record<types.MapKey, string>>
 *
 * - i2: Partial<Record<types.MapKey, string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Partial<Record<types.MapKey, string>>
 * - **Streaming Partial:** (Record<MapKey, (string | null)> )
 * - **Streaming Final:** Partial<Record<types.MapKey, string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useInOutEnumMapKey();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useInOutEnumMapKey({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useInOutEnumMapKey(
  props: StreamingProps<'InOutEnumMapKey'>
): StreamingHookResult<'InOutEnumMapKey'>;

export function useInOutEnumMapKey(
  props?: NonStreamingProps<'InOutEnumMapKey'>
): NonStreamingHookResult<'InOutEnumMapKey'>;

export function useInOutEnumMapKey(
  props: HookProps<'InOutEnumMapKey'> = {}
): StreamingHookResult<'InOutEnumMapKey'> | NonStreamingHookResult<'InOutEnumMapKey'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.InOutEnumMapKey, props);
  }

  return useBamlAction(Actions.InOutEnumMapKey, props);
}
/**
 * A specialized hook for the InOutLiteralStringUnionMapKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - i1: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * - i2: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Partial<Record<"one" | "two" | "three" | "four", string>>
 * - **Streaming Partial:** (Record<"one" | "two" | "three" | "four", (string | null)> )
 * - **Streaming Final:** Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useInOutLiteralStringUnionMapKey();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useInOutLiteralStringUnionMapKey({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useInOutLiteralStringUnionMapKey(
  props: StreamingProps<'InOutLiteralStringUnionMapKey'>
): StreamingHookResult<'InOutLiteralStringUnionMapKey'>;

export function useInOutLiteralStringUnionMapKey(
  props?: NonStreamingProps<'InOutLiteralStringUnionMapKey'>
): NonStreamingHookResult<'InOutLiteralStringUnionMapKey'>;

export function useInOutLiteralStringUnionMapKey(
  props: HookProps<'InOutLiteralStringUnionMapKey'> = {}
): StreamingHookResult<'InOutLiteralStringUnionMapKey'> | NonStreamingHookResult<'InOutLiteralStringUnionMapKey'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.InOutLiteralStringUnionMapKey, props);
  }

  return useBamlAction(Actions.InOutLiteralStringUnionMapKey, props);
}
/**
 * A specialized hook for the InOutSingleLiteralStringMapKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - m: Partial<Record<"key", string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Partial<Record<"key", string>>
 * - **Streaming Partial:** (Record<"key", (string | null)> )
 * - **Streaming Final:** Partial<Record<"key", string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useInOutSingleLiteralStringMapKey();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useInOutSingleLiteralStringMapKey({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useInOutSingleLiteralStringMapKey(
  props: StreamingProps<'InOutSingleLiteralStringMapKey'>
): StreamingHookResult<'InOutSingleLiteralStringMapKey'>;

export function useInOutSingleLiteralStringMapKey(
  props?: NonStreamingProps<'InOutSingleLiteralStringMapKey'>
): NonStreamingHookResult<'InOutSingleLiteralStringMapKey'>;

export function useInOutSingleLiteralStringMapKey(
  props: HookProps<'InOutSingleLiteralStringMapKey'> = {}
): StreamingHookResult<'InOutSingleLiteralStringMapKey'> | NonStreamingHookResult<'InOutSingleLiteralStringMapKey'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.InOutSingleLiteralStringMapKey, props);
  }

  return useBamlAction(Actions.InOutSingleLiteralStringMapKey, props);
}
/**
 * A specialized hook for the JsonTypeAliasCycle BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: JsonValue
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** JsonValue
 * - **Streaming Partial:** JsonValue
 * - **Streaming Final:** JsonValue
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useJsonTypeAliasCycle();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useJsonTypeAliasCycle({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useJsonTypeAliasCycle(
  props: StreamingProps<'JsonTypeAliasCycle'>
): StreamingHookResult<'JsonTypeAliasCycle'>;

export function useJsonTypeAliasCycle(
  props?: NonStreamingProps<'JsonTypeAliasCycle'>
): NonStreamingHookResult<'JsonTypeAliasCycle'>;

export function useJsonTypeAliasCycle(
  props: HookProps<'JsonTypeAliasCycle'> = {}
): StreamingHookResult<'JsonTypeAliasCycle'> | NonStreamingHookResult<'JsonTypeAliasCycle'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.JsonTypeAliasCycle, props);
  }

  return useBamlAction(Actions.JsonTypeAliasCycle, props);
}
/**
 * A specialized hook for the LiteralUnionsTest BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** 1 | true | "string output"
 * - **Streaming Partial:** (1 | true | "string output")
 * - **Streaming Final:** 1 | true | "string output"
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useLiteralUnionsTest();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useLiteralUnionsTest({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useLiteralUnionsTest(
  props: StreamingProps<'LiteralUnionsTest'>
): StreamingHookResult<'LiteralUnionsTest'>;

export function useLiteralUnionsTest(
  props?: NonStreamingProps<'LiteralUnionsTest'>
): NonStreamingHookResult<'LiteralUnionsTest'>;

export function useLiteralUnionsTest(
  props: HookProps<'LiteralUnionsTest'> = {}
): StreamingHookResult<'LiteralUnionsTest'> | NonStreamingHookResult<'LiteralUnionsTest'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.LiteralUnionsTest, props);
  }

  return useBamlAction(Actions.LiteralUnionsTest, props);
}
/**
 * A specialized hook for the MakeBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<BlockConstraint,"cross_field">
 * - **Streaming Partial:** Checked<partial_types.BlockConstraint,"cross_field">
 * - **Streaming Final:** Checked<BlockConstraint,"cross_field">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMakeBlockConstraint();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useMakeBlockConstraint({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeBlockConstraint(
  props: StreamingProps<'MakeBlockConstraint'>
): StreamingHookResult<'MakeBlockConstraint'>;

export function useMakeBlockConstraint(
  props?: NonStreamingProps<'MakeBlockConstraint'>
): NonStreamingHookResult<'MakeBlockConstraint'>;

export function useMakeBlockConstraint(
  props: HookProps<'MakeBlockConstraint'> = {}
): StreamingHookResult<'MakeBlockConstraint'> | NonStreamingHookResult<'MakeBlockConstraint'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.MakeBlockConstraint, props);
  }

  return useBamlAction(Actions.MakeBlockConstraint, props);
}
/**
 * A specialized hook for the MakeNestedBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** NestedBlockConstraint
 * - **Streaming Partial:** partial_types.NestedBlockConstraint
 * - **Streaming Final:** NestedBlockConstraint
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMakeNestedBlockConstraint();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useMakeNestedBlockConstraint({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeNestedBlockConstraint(
  props: StreamingProps<'MakeNestedBlockConstraint'>
): StreamingHookResult<'MakeNestedBlockConstraint'>;

export function useMakeNestedBlockConstraint(
  props?: NonStreamingProps<'MakeNestedBlockConstraint'>
): NonStreamingHookResult<'MakeNestedBlockConstraint'>;

export function useMakeNestedBlockConstraint(
  props: HookProps<'MakeNestedBlockConstraint'> = {}
): StreamingHookResult<'MakeNestedBlockConstraint'> | NonStreamingHookResult<'MakeNestedBlockConstraint'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.MakeNestedBlockConstraint, props);
  }

  return useBamlAction(Actions.MakeNestedBlockConstraint, props);
}
/**
 * A specialized hook for the MakeSemanticContainer BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SemanticContainer
 * - **Streaming Partial:** partial_types.SemanticContainer
 * - **Streaming Final:** SemanticContainer
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMakeSemanticContainer();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useMakeSemanticContainer({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeSemanticContainer(
  props: StreamingProps<'MakeSemanticContainer'>
): StreamingHookResult<'MakeSemanticContainer'>;

export function useMakeSemanticContainer(
  props?: NonStreamingProps<'MakeSemanticContainer'>
): NonStreamingHookResult<'MakeSemanticContainer'>;

export function useMakeSemanticContainer(
  props: HookProps<'MakeSemanticContainer'> = {}
): StreamingHookResult<'MakeSemanticContainer'> | NonStreamingHookResult<'MakeSemanticContainer'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.MakeSemanticContainer, props);
  }

  return useBamlAction(Actions.MakeSemanticContainer, props);
}
/**
 * A specialized hook for the MapAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - m: Record<string, string[]>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, string[]>
 * - **Streaming Partial:** (Record<string, (string | null)[]> )
 * - **Streaming Final:** Record<string, string[]>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMapAlias();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useMapAlias({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMapAlias(
  props: StreamingProps<'MapAlias'>
): StreamingHookResult<'MapAlias'>;

export function useMapAlias(
  props?: NonStreamingProps<'MapAlias'>
): NonStreamingHookResult<'MapAlias'>;

export function useMapAlias(
  props: HookProps<'MapAlias'> = {}
): StreamingHookResult<'MapAlias'> | NonStreamingHookResult<'MapAlias'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.MapAlias, props);
  }

  return useBamlAction(Actions.MapAlias, props);
}
/**
 * A specialized hook for the MergeAliasAttributes BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - money: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** MergeAttrs
 * - **Streaming Partial:** partial_types.MergeAttrs
 * - **Streaming Final:** MergeAttrs
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMergeAliasAttributes();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useMergeAliasAttributes({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMergeAliasAttributes(
  props: StreamingProps<'MergeAliasAttributes'>
): StreamingHookResult<'MergeAliasAttributes'>;

export function useMergeAliasAttributes(
  props?: NonStreamingProps<'MergeAliasAttributes'>
): NonStreamingHookResult<'MergeAliasAttributes'>;

export function useMergeAliasAttributes(
  props: HookProps<'MergeAliasAttributes'> = {}
): StreamingHookResult<'MergeAliasAttributes'> | NonStreamingHookResult<'MergeAliasAttributes'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.MergeAliasAttributes, props);
  }

  return useBamlAction(Actions.MergeAliasAttributes, props);
}
/**
 * A specialized hook for the MyFunc BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynamicOutput
 * - **Streaming Partial:** partial_types.DynamicOutput
 * - **Streaming Final:** DynamicOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMyFunc();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useMyFunc({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMyFunc(
  props: StreamingProps<'MyFunc'>
): StreamingHookResult<'MyFunc'>;

export function useMyFunc(
  props?: NonStreamingProps<'MyFunc'>
): NonStreamingHookResult<'MyFunc'>;

export function useMyFunc(
  props: HookProps<'MyFunc'> = {}
): StreamingHookResult<'MyFunc'> | NonStreamingHookResult<'MyFunc'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.MyFunc, props);
  }

  return useBamlAction(Actions.MyFunc, props);
}
/**
 * A specialized hook for the NestedAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - c: number | string | boolean | number | string[] | Record<string, string[]>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number | string | boolean | number | string[] | Record<string, string[]>
 * - **Streaming Partial:** (((number | null) | (string | null) | (boolean | null) | (number | null) | null) | (string | null)[] | (Record<string, (string | null)[]> | null))
 * - **Streaming Final:** number | string | boolean | number | string[] | Record<string, string[]>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useNestedAlias();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useNestedAlias({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useNestedAlias(
  props: StreamingProps<'NestedAlias'>
): StreamingHookResult<'NestedAlias'>;

export function useNestedAlias(
  props?: NonStreamingProps<'NestedAlias'>
): NonStreamingHookResult<'NestedAlias'>;

export function useNestedAlias(
  props: HookProps<'NestedAlias'> = {}
): StreamingHookResult<'NestedAlias'> | NonStreamingHookResult<'NestedAlias'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.NestedAlias, props);
  }

  return useBamlAction(Actions.NestedAlias, props);
}
/**
 * A specialized hook for the NullLiteralClassHello BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - s: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassForNullLiteral
 * - **Streaming Partial:** partial_types.ClassForNullLiteral
 * - **Streaming Final:** ClassForNullLiteral
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useNullLiteralClassHello();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useNullLiteralClassHello({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useNullLiteralClassHello(
  props: StreamingProps<'NullLiteralClassHello'>
): StreamingHookResult<'NullLiteralClassHello'>;

export function useNullLiteralClassHello(
  props?: NonStreamingProps<'NullLiteralClassHello'>
): NonStreamingHookResult<'NullLiteralClassHello'>;

export function useNullLiteralClassHello(
  props: HookProps<'NullLiteralClassHello'> = {}
): StreamingHookResult<'NullLiteralClassHello'> | NonStreamingHookResult<'NullLiteralClassHello'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.NullLiteralClassHello, props);
  }

  return useBamlAction(Actions.NullLiteralClassHello, props);
}
/**
 * A specialized hook for the OptionalTest_Function BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (OptionalTest_ReturnType | null)[]
 * - **Streaming Partial:** ((partial_types.OptionalTest_ReturnType | null) | null)[]
 * - **Streaming Final:** (OptionalTest_ReturnType | null)[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useOptionalTest_Function();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useOptionalTest_Function({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useOptionalTest_Function(
  props: StreamingProps<'OptionalTest_Function'>
): StreamingHookResult<'OptionalTest_Function'>;

export function useOptionalTest_Function(
  props?: NonStreamingProps<'OptionalTest_Function'>
): NonStreamingHookResult<'OptionalTest_Function'>;

export function useOptionalTest_Function(
  props: HookProps<'OptionalTest_Function'> = {}
): StreamingHookResult<'OptionalTest_Function'> | NonStreamingHookResult<'OptionalTest_Function'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.OptionalTest_Function, props);
  }

  return useBamlAction(Actions.OptionalTest_Function, props);
}
/**
 * A specialized hook for the PredictAge BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - name: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** FooAny
 * - **Streaming Partial:** partial_types.FooAny
 * - **Streaming Final:** FooAny
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePredictAge();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePredictAge({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePredictAge(
  props: StreamingProps<'PredictAge'>
): StreamingHookResult<'PredictAge'>;

export function usePredictAge(
  props?: NonStreamingProps<'PredictAge'>
): NonStreamingHookResult<'PredictAge'>;

export function usePredictAge(
  props: HookProps<'PredictAge'> = {}
): StreamingHookResult<'PredictAge'> | NonStreamingHookResult<'PredictAge'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PredictAge, props);
  }

  return useBamlAction(Actions.PredictAge, props);
}
/**
 * A specialized hook for the PredictAgeBare BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<number,"too_big">
 * - **Streaming Partial:** Checked<number,"too_big">
 * - **Streaming Final:** Checked<number,"too_big">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePredictAgeBare();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePredictAgeBare({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePredictAgeBare(
  props: StreamingProps<'PredictAgeBare'>
): StreamingHookResult<'PredictAgeBare'>;

export function usePredictAgeBare(
  props?: NonStreamingProps<'PredictAgeBare'>
): NonStreamingHookResult<'PredictAgeBare'>;

export function usePredictAgeBare(
  props: HookProps<'PredictAgeBare'> = {}
): StreamingHookResult<'PredictAgeBare'> | NonStreamingHookResult<'PredictAgeBare'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PredictAgeBare, props);
  }

  return useBamlAction(Actions.PredictAgeBare, props);
}
/**
 * A specialized hook for the PrimitiveAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - p: number | string | boolean | number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number | string | boolean | number
 * - **Streaming Partial:** ((number | null) | (string | null) | (boolean | null) | (number | null))
 * - **Streaming Final:** number | string | boolean | number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePrimitiveAlias();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePrimitiveAlias({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePrimitiveAlias(
  props: StreamingProps<'PrimitiveAlias'>
): StreamingHookResult<'PrimitiveAlias'>;

export function usePrimitiveAlias(
  props?: NonStreamingProps<'PrimitiveAlias'>
): NonStreamingHookResult<'PrimitiveAlias'>;

export function usePrimitiveAlias(
  props: HookProps<'PrimitiveAlias'> = {}
): StreamingHookResult<'PrimitiveAlias'> | NonStreamingHookResult<'PrimitiveAlias'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PrimitiveAlias, props);
  }

  return useBamlAction(Actions.PrimitiveAlias, props);
}
/**
 * A specialized hook for the PromptTestClaude BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestClaude();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePromptTestClaude({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestClaude(
  props: StreamingProps<'PromptTestClaude'>
): StreamingHookResult<'PromptTestClaude'>;

export function usePromptTestClaude(
  props?: NonStreamingProps<'PromptTestClaude'>
): NonStreamingHookResult<'PromptTestClaude'>;

export function usePromptTestClaude(
  props: HookProps<'PromptTestClaude'> = {}
): StreamingHookResult<'PromptTestClaude'> | NonStreamingHookResult<'PromptTestClaude'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PromptTestClaude, props);
  }

  return useBamlAction(Actions.PromptTestClaude, props);
}
/**
 * A specialized hook for the PromptTestClaudeChat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestClaudeChat();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePromptTestClaudeChat({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestClaudeChat(
  props: StreamingProps<'PromptTestClaudeChat'>
): StreamingHookResult<'PromptTestClaudeChat'>;

export function usePromptTestClaudeChat(
  props?: NonStreamingProps<'PromptTestClaudeChat'>
): NonStreamingHookResult<'PromptTestClaudeChat'>;

export function usePromptTestClaudeChat(
  props: HookProps<'PromptTestClaudeChat'> = {}
): StreamingHookResult<'PromptTestClaudeChat'> | NonStreamingHookResult<'PromptTestClaudeChat'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PromptTestClaudeChat, props);
  }

  return useBamlAction(Actions.PromptTestClaudeChat, props);
}
/**
 * A specialized hook for the PromptTestClaudeChatNoSystem BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestClaudeChatNoSystem();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePromptTestClaudeChatNoSystem({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestClaudeChatNoSystem(
  props: StreamingProps<'PromptTestClaudeChatNoSystem'>
): StreamingHookResult<'PromptTestClaudeChatNoSystem'>;

export function usePromptTestClaudeChatNoSystem(
  props?: NonStreamingProps<'PromptTestClaudeChatNoSystem'>
): NonStreamingHookResult<'PromptTestClaudeChatNoSystem'>;

export function usePromptTestClaudeChatNoSystem(
  props: HookProps<'PromptTestClaudeChatNoSystem'> = {}
): StreamingHookResult<'PromptTestClaudeChatNoSystem'> | NonStreamingHookResult<'PromptTestClaudeChatNoSystem'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PromptTestClaudeChatNoSystem, props);
  }

  return useBamlAction(Actions.PromptTestClaudeChatNoSystem, props);
}
/**
 * A specialized hook for the PromptTestOpenAI BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestOpenAI();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePromptTestOpenAI({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestOpenAI(
  props: StreamingProps<'PromptTestOpenAI'>
): StreamingHookResult<'PromptTestOpenAI'>;

export function usePromptTestOpenAI(
  props?: NonStreamingProps<'PromptTestOpenAI'>
): NonStreamingHookResult<'PromptTestOpenAI'>;

export function usePromptTestOpenAI(
  props: HookProps<'PromptTestOpenAI'> = {}
): StreamingHookResult<'PromptTestOpenAI'> | NonStreamingHookResult<'PromptTestOpenAI'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PromptTestOpenAI, props);
  }

  return useBamlAction(Actions.PromptTestOpenAI, props);
}
/**
 * A specialized hook for the PromptTestOpenAIChat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestOpenAIChat();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePromptTestOpenAIChat({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestOpenAIChat(
  props: StreamingProps<'PromptTestOpenAIChat'>
): StreamingHookResult<'PromptTestOpenAIChat'>;

export function usePromptTestOpenAIChat(
  props?: NonStreamingProps<'PromptTestOpenAIChat'>
): NonStreamingHookResult<'PromptTestOpenAIChat'>;

export function usePromptTestOpenAIChat(
  props: HookProps<'PromptTestOpenAIChat'> = {}
): StreamingHookResult<'PromptTestOpenAIChat'> | NonStreamingHookResult<'PromptTestOpenAIChat'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PromptTestOpenAIChat, props);
  }

  return useBamlAction(Actions.PromptTestOpenAIChat, props);
}
/**
 * A specialized hook for the PromptTestOpenAIChatNoSystem BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestOpenAIChatNoSystem();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePromptTestOpenAIChatNoSystem({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestOpenAIChatNoSystem(
  props: StreamingProps<'PromptTestOpenAIChatNoSystem'>
): StreamingHookResult<'PromptTestOpenAIChatNoSystem'>;

export function usePromptTestOpenAIChatNoSystem(
  props?: NonStreamingProps<'PromptTestOpenAIChatNoSystem'>
): NonStreamingHookResult<'PromptTestOpenAIChatNoSystem'>;

export function usePromptTestOpenAIChatNoSystem(
  props: HookProps<'PromptTestOpenAIChatNoSystem'> = {}
): StreamingHookResult<'PromptTestOpenAIChatNoSystem'> | NonStreamingHookResult<'PromptTestOpenAIChatNoSystem'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PromptTestOpenAIChatNoSystem, props);
  }

  return useBamlAction(Actions.PromptTestOpenAIChatNoSystem, props);
}
/**
 * A specialized hook for the PromptTestStreaming BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestStreaming();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = usePromptTestStreaming({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestStreaming(
  props: StreamingProps<'PromptTestStreaming'>
): StreamingHookResult<'PromptTestStreaming'>;

export function usePromptTestStreaming(
  props?: NonStreamingProps<'PromptTestStreaming'>
): NonStreamingHookResult<'PromptTestStreaming'>;

export function usePromptTestStreaming(
  props: HookProps<'PromptTestStreaming'> = {}
): StreamingHookResult<'PromptTestStreaming'> | NonStreamingHookResult<'PromptTestStreaming'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.PromptTestStreaming, props);
  }

  return useBamlAction(Actions.PromptTestStreaming, props);
}
/**
 * A specialized hook for the RecursiveAliasCycle BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecAliasOne
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecAliasOne
 * - **Streaming Partial:** RecAliasOne
 * - **Streaming Final:** RecAliasOne
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useRecursiveAliasCycle();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useRecursiveAliasCycle({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useRecursiveAliasCycle(
  props: StreamingProps<'RecursiveAliasCycle'>
): StreamingHookResult<'RecursiveAliasCycle'>;

export function useRecursiveAliasCycle(
  props?: NonStreamingProps<'RecursiveAliasCycle'>
): NonStreamingHookResult<'RecursiveAliasCycle'>;

export function useRecursiveAliasCycle(
  props: HookProps<'RecursiveAliasCycle'> = {}
): StreamingHookResult<'RecursiveAliasCycle'> | NonStreamingHookResult<'RecursiveAliasCycle'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.RecursiveAliasCycle, props);
  }

  return useBamlAction(Actions.RecursiveAliasCycle, props);
}
/**
 * A specialized hook for the RecursiveClassWithAliasIndirection BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - cls: NodeWithAliasIndirection
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** NodeWithAliasIndirection
 * - **Streaming Partial:** partial_types.NodeWithAliasIndirection
 * - **Streaming Final:** NodeWithAliasIndirection
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useRecursiveClassWithAliasIndirection();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useRecursiveClassWithAliasIndirection({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useRecursiveClassWithAliasIndirection(
  props: StreamingProps<'RecursiveClassWithAliasIndirection'>
): StreamingHookResult<'RecursiveClassWithAliasIndirection'>;

export function useRecursiveClassWithAliasIndirection(
  props?: NonStreamingProps<'RecursiveClassWithAliasIndirection'>
): NonStreamingHookResult<'RecursiveClassWithAliasIndirection'>;

export function useRecursiveClassWithAliasIndirection(
  props: HookProps<'RecursiveClassWithAliasIndirection'> = {}
): StreamingHookResult<'RecursiveClassWithAliasIndirection'> | NonStreamingHookResult<'RecursiveClassWithAliasIndirection'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.RecursiveClassWithAliasIndirection, props);
  }

  return useBamlAction(Actions.RecursiveClassWithAliasIndirection, props);
}
/**
 * A specialized hook for the ReturnAliasWithMergedAttributes BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<number,"gt_ten">
 * - **Streaming Partial:** Checked<number,"gt_ten">
 * - **Streaming Final:** Checked<number,"gt_ten">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnAliasWithMergedAttributes();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useReturnAliasWithMergedAttributes({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnAliasWithMergedAttributes(
  props: StreamingProps<'ReturnAliasWithMergedAttributes'>
): StreamingHookResult<'ReturnAliasWithMergedAttributes'>;

export function useReturnAliasWithMergedAttributes(
  props?: NonStreamingProps<'ReturnAliasWithMergedAttributes'>
): NonStreamingHookResult<'ReturnAliasWithMergedAttributes'>;

export function useReturnAliasWithMergedAttributes(
  props: HookProps<'ReturnAliasWithMergedAttributes'> = {}
): StreamingHookResult<'ReturnAliasWithMergedAttributes'> | NonStreamingHookResult<'ReturnAliasWithMergedAttributes'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ReturnAliasWithMergedAttributes, props);
  }

  return useBamlAction(Actions.ReturnAliasWithMergedAttributes, props);
}
/**
 * A specialized hook for the ReturnFailingAssert BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnFailingAssert();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useReturnFailingAssert({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnFailingAssert(
  props: StreamingProps<'ReturnFailingAssert'>
): StreamingHookResult<'ReturnFailingAssert'>;

export function useReturnFailingAssert(
  props?: NonStreamingProps<'ReturnFailingAssert'>
): NonStreamingHookResult<'ReturnFailingAssert'>;

export function useReturnFailingAssert(
  props: HookProps<'ReturnFailingAssert'> = {}
): StreamingHookResult<'ReturnFailingAssert'> | NonStreamingHookResult<'ReturnFailingAssert'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ReturnFailingAssert, props);
  }

  return useBamlAction(Actions.ReturnFailingAssert, props);
}
/**
 * A specialized hook for the ReturnJsonEntry BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - s: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** JsonTemplate
 * - **Streaming Partial:** JsonTemplate
 * - **Streaming Final:** JsonTemplate
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnJsonEntry();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useReturnJsonEntry({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnJsonEntry(
  props: StreamingProps<'ReturnJsonEntry'>
): StreamingHookResult<'ReturnJsonEntry'>;

export function useReturnJsonEntry(
  props?: NonStreamingProps<'ReturnJsonEntry'>
): NonStreamingHookResult<'ReturnJsonEntry'>;

export function useReturnJsonEntry(
  props: HookProps<'ReturnJsonEntry'> = {}
): StreamingHookResult<'ReturnJsonEntry'> | NonStreamingHookResult<'ReturnJsonEntry'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ReturnJsonEntry, props);
  }

  return useBamlAction(Actions.ReturnJsonEntry, props);
}
/**
 * A specialized hook for the ReturnMalformedConstraints BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - a: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** MalformedConstraints
 * - **Streaming Partial:** partial_types.MalformedConstraints
 * - **Streaming Final:** MalformedConstraints
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnMalformedConstraints();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useReturnMalformedConstraints({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnMalformedConstraints(
  props: StreamingProps<'ReturnMalformedConstraints'>
): StreamingHookResult<'ReturnMalformedConstraints'>;

export function useReturnMalformedConstraints(
  props?: NonStreamingProps<'ReturnMalformedConstraints'>
): NonStreamingHookResult<'ReturnMalformedConstraints'>;

export function useReturnMalformedConstraints(
  props: HookProps<'ReturnMalformedConstraints'> = {}
): StreamingHookResult<'ReturnMalformedConstraints'> | NonStreamingHookResult<'ReturnMalformedConstraints'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.ReturnMalformedConstraints, props);
  }

  return useBamlAction(Actions.ReturnMalformedConstraints, props);
}
/**
 * A specialized hook for the SchemaDescriptions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Schema
 * - **Streaming Partial:** partial_types.Schema
 * - **Streaming Final:** Schema
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useSchemaDescriptions();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useSchemaDescriptions({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSchemaDescriptions(
  props: StreamingProps<'SchemaDescriptions'>
): StreamingHookResult<'SchemaDescriptions'>;

export function useSchemaDescriptions(
  props?: NonStreamingProps<'SchemaDescriptions'>
): NonStreamingHookResult<'SchemaDescriptions'>;

export function useSchemaDescriptions(
  props: HookProps<'SchemaDescriptions'> = {}
): StreamingHookResult<'SchemaDescriptions'> | NonStreamingHookResult<'SchemaDescriptions'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.SchemaDescriptions, props);
  }

  return useBamlAction(Actions.SchemaDescriptions, props);
}
/**
 * A specialized hook for the SimpleRecursiveListAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecursiveListAlias
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecursiveListAlias
 * - **Streaming Partial:** RecursiveListAlias
 * - **Streaming Final:** RecursiveListAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useSimpleRecursiveListAlias();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useSimpleRecursiveListAlias({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSimpleRecursiveListAlias(
  props: StreamingProps<'SimpleRecursiveListAlias'>
): StreamingHookResult<'SimpleRecursiveListAlias'>;

export function useSimpleRecursiveListAlias(
  props?: NonStreamingProps<'SimpleRecursiveListAlias'>
): NonStreamingHookResult<'SimpleRecursiveListAlias'>;

export function useSimpleRecursiveListAlias(
  props: HookProps<'SimpleRecursiveListAlias'> = {}
): StreamingHookResult<'SimpleRecursiveListAlias'> | NonStreamingHookResult<'SimpleRecursiveListAlias'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.SimpleRecursiveListAlias, props);
  }

  return useBamlAction(Actions.SimpleRecursiveListAlias, props);
}
/**
 * A specialized hook for the SimpleRecursiveMapAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecursiveMapAlias
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecursiveMapAlias
 * - **Streaming Partial:** RecursiveMapAlias
 * - **Streaming Final:** RecursiveMapAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useSimpleRecursiveMapAlias();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useSimpleRecursiveMapAlias({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSimpleRecursiveMapAlias(
  props: StreamingProps<'SimpleRecursiveMapAlias'>
): StreamingHookResult<'SimpleRecursiveMapAlias'>;

export function useSimpleRecursiveMapAlias(
  props?: NonStreamingProps<'SimpleRecursiveMapAlias'>
): NonStreamingHookResult<'SimpleRecursiveMapAlias'>;

export function useSimpleRecursiveMapAlias(
  props: HookProps<'SimpleRecursiveMapAlias'> = {}
): StreamingHookResult<'SimpleRecursiveMapAlias'> | NonStreamingHookResult<'SimpleRecursiveMapAlias'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.SimpleRecursiveMapAlias, props);
  }

  return useBamlAction(Actions.SimpleRecursiveMapAlias, props);
}
/**
 * A specialized hook for the StreamBigNumbers BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** BigNumbers
 * - **Streaming Partial:** partial_types.BigNumbers
 * - **Streaming Final:** BigNumbers
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamBigNumbers();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useStreamBigNumbers({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamBigNumbers(
  props: StreamingProps<'StreamBigNumbers'>
): StreamingHookResult<'StreamBigNumbers'>;

export function useStreamBigNumbers(
  props?: NonStreamingProps<'StreamBigNumbers'>
): NonStreamingHookResult<'StreamBigNumbers'>;

export function useStreamBigNumbers(
  props: HookProps<'StreamBigNumbers'> = {}
): StreamingHookResult<'StreamBigNumbers'> | NonStreamingHookResult<'StreamBigNumbers'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.StreamBigNumbers, props);
  }

  return useBamlAction(Actions.StreamBigNumbers, props);
}
/**
 * A specialized hook for the StreamFailingAssertion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - theme: string
 *
 * - length: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TwoStoriesOneTitle
 * - **Streaming Partial:** partial_types.TwoStoriesOneTitle
 * - **Streaming Final:** TwoStoriesOneTitle
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamFailingAssertion();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useStreamFailingAssertion({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamFailingAssertion(
  props: StreamingProps<'StreamFailingAssertion'>
): StreamingHookResult<'StreamFailingAssertion'>;

export function useStreamFailingAssertion(
  props?: NonStreamingProps<'StreamFailingAssertion'>
): NonStreamingHookResult<'StreamFailingAssertion'>;

export function useStreamFailingAssertion(
  props: HookProps<'StreamFailingAssertion'> = {}
): StreamingHookResult<'StreamFailingAssertion'> | NonStreamingHookResult<'StreamFailingAssertion'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.StreamFailingAssertion, props);
  }

  return useBamlAction(Actions.StreamFailingAssertion, props);
}
/**
 * A specialized hook for the StreamOneBigNumber BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamOneBigNumber();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useStreamOneBigNumber({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamOneBigNumber(
  props: StreamingProps<'StreamOneBigNumber'>
): StreamingHookResult<'StreamOneBigNumber'>;

export function useStreamOneBigNumber(
  props?: NonStreamingProps<'StreamOneBigNumber'>
): NonStreamingHookResult<'StreamOneBigNumber'>;

export function useStreamOneBigNumber(
  props: HookProps<'StreamOneBigNumber'> = {}
): StreamingHookResult<'StreamOneBigNumber'> | NonStreamingHookResult<'StreamOneBigNumber'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.StreamOneBigNumber, props);
  }

  return useBamlAction(Actions.StreamOneBigNumber, props);
}
/**
 * A specialized hook for the StreamUnionIntegers BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (number | string)[]
 * - **Streaming Partial:** ((number | null) | (string | null) | null)[]
 * - **Streaming Final:** (number | string)[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamUnionIntegers();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useStreamUnionIntegers({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamUnionIntegers(
  props: StreamingProps<'StreamUnionIntegers'>
): StreamingHookResult<'StreamUnionIntegers'>;

export function useStreamUnionIntegers(
  props?: NonStreamingProps<'StreamUnionIntegers'>
): NonStreamingHookResult<'StreamUnionIntegers'>;

export function useStreamUnionIntegers(
  props: HookProps<'StreamUnionIntegers'> = {}
): StreamingHookResult<'StreamUnionIntegers'> | NonStreamingHookResult<'StreamUnionIntegers'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.StreamUnionIntegers, props);
  }

  return useBamlAction(Actions.StreamUnionIntegers, props);
}
/**
 * A specialized hook for the StreamingCompoundNumbers BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 * - yapping: boolean
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** CompoundBigNumbers
 * - **Streaming Partial:** partial_types.CompoundBigNumbers
 * - **Streaming Final:** CompoundBigNumbers
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamingCompoundNumbers();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useStreamingCompoundNumbers({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamingCompoundNumbers(
  props: StreamingProps<'StreamingCompoundNumbers'>
): StreamingHookResult<'StreamingCompoundNumbers'>;

export function useStreamingCompoundNumbers(
  props?: NonStreamingProps<'StreamingCompoundNumbers'>
): NonStreamingHookResult<'StreamingCompoundNumbers'>;

export function useStreamingCompoundNumbers(
  props: HookProps<'StreamingCompoundNumbers'> = {}
): StreamingHookResult<'StreamingCompoundNumbers'> | NonStreamingHookResult<'StreamingCompoundNumbers'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.StreamingCompoundNumbers, props);
  }

  return useBamlAction(Actions.StreamingCompoundNumbers, props);
}
/**
 * A specialized hook for the TakeRecAliasDep BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecursiveAliasDependency
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecursiveAliasDependency
 * - **Streaming Partial:** partial_types.RecursiveAliasDependency
 * - **Streaming Final:** RecursiveAliasDependency
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTakeRecAliasDep();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTakeRecAliasDep({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTakeRecAliasDep(
  props: StreamingProps<'TakeRecAliasDep'>
): StreamingHookResult<'TakeRecAliasDep'>;

export function useTakeRecAliasDep(
  props?: NonStreamingProps<'TakeRecAliasDep'>
): NonStreamingHookResult<'TakeRecAliasDep'>;

export function useTakeRecAliasDep(
  props: HookProps<'TakeRecAliasDep'> = {}
): StreamingHookResult<'TakeRecAliasDep'> | NonStreamingHookResult<'TakeRecAliasDep'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TakeRecAliasDep, props);
  }

  return useBamlAction(Actions.TakeRecAliasDep, props);
}
/**
 * A specialized hook for the TestAnthropic BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAnthropic();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAnthropic({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAnthropic(
  props: StreamingProps<'TestAnthropic'>
): StreamingHookResult<'TestAnthropic'>;

export function useTestAnthropic(
  props?: NonStreamingProps<'TestAnthropic'>
): NonStreamingHookResult<'TestAnthropic'>;

export function useTestAnthropic(
  props: HookProps<'TestAnthropic'> = {}
): StreamingHookResult<'TestAnthropic'> | NonStreamingHookResult<'TestAnthropic'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAnthropic, props);
  }

  return useBamlAction(Actions.TestAnthropic, props);
}
/**
 * A specialized hook for the TestAnthropicShorthand BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAnthropicShorthand();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAnthropicShorthand({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAnthropicShorthand(
  props: StreamingProps<'TestAnthropicShorthand'>
): StreamingHookResult<'TestAnthropicShorthand'>;

export function useTestAnthropicShorthand(
  props?: NonStreamingProps<'TestAnthropicShorthand'>
): NonStreamingHookResult<'TestAnthropicShorthand'>;

export function useTestAnthropicShorthand(
  props: HookProps<'TestAnthropicShorthand'> = {}
): StreamingHookResult<'TestAnthropicShorthand'> | NonStreamingHookResult<'TestAnthropicShorthand'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAnthropicShorthand, props);
  }

  return useBamlAction(Actions.TestAnthropicShorthand, props);
}
/**
 * A specialized hook for the TestAws BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAws();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAws({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAws(
  props: StreamingProps<'TestAws'>
): StreamingHookResult<'TestAws'>;

export function useTestAws(
  props?: NonStreamingProps<'TestAws'>
): NonStreamingHookResult<'TestAws'>;

export function useTestAws(
  props: HookProps<'TestAws'> = {}
): StreamingHookResult<'TestAws'> | NonStreamingHookResult<'TestAws'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAws, props);
  }

  return useBamlAction(Actions.TestAws, props);
}
/**
 * A specialized hook for the TestAwsInvalidAccessKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidAccessKey();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAwsInvalidAccessKey({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidAccessKey(
  props: StreamingProps<'TestAwsInvalidAccessKey'>
): StreamingHookResult<'TestAwsInvalidAccessKey'>;

export function useTestAwsInvalidAccessKey(
  props?: NonStreamingProps<'TestAwsInvalidAccessKey'>
): NonStreamingHookResult<'TestAwsInvalidAccessKey'>;

export function useTestAwsInvalidAccessKey(
  props: HookProps<'TestAwsInvalidAccessKey'> = {}
): StreamingHookResult<'TestAwsInvalidAccessKey'> | NonStreamingHookResult<'TestAwsInvalidAccessKey'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAwsInvalidAccessKey, props);
  }

  return useBamlAction(Actions.TestAwsInvalidAccessKey, props);
}
/**
 * A specialized hook for the TestAwsInvalidProfile BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidProfile();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAwsInvalidProfile({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidProfile(
  props: StreamingProps<'TestAwsInvalidProfile'>
): StreamingHookResult<'TestAwsInvalidProfile'>;

export function useTestAwsInvalidProfile(
  props?: NonStreamingProps<'TestAwsInvalidProfile'>
): NonStreamingHookResult<'TestAwsInvalidProfile'>;

export function useTestAwsInvalidProfile(
  props: HookProps<'TestAwsInvalidProfile'> = {}
): StreamingHookResult<'TestAwsInvalidProfile'> | NonStreamingHookResult<'TestAwsInvalidProfile'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAwsInvalidProfile, props);
  }

  return useBamlAction(Actions.TestAwsInvalidProfile, props);
}
/**
 * A specialized hook for the TestAwsInvalidRegion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidRegion();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAwsInvalidRegion({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidRegion(
  props: StreamingProps<'TestAwsInvalidRegion'>
): StreamingHookResult<'TestAwsInvalidRegion'>;

export function useTestAwsInvalidRegion(
  props?: NonStreamingProps<'TestAwsInvalidRegion'>
): NonStreamingHookResult<'TestAwsInvalidRegion'>;

export function useTestAwsInvalidRegion(
  props: HookProps<'TestAwsInvalidRegion'> = {}
): StreamingHookResult<'TestAwsInvalidRegion'> | NonStreamingHookResult<'TestAwsInvalidRegion'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAwsInvalidRegion, props);
  }

  return useBamlAction(Actions.TestAwsInvalidRegion, props);
}
/**
 * A specialized hook for the TestAwsInvalidSessionToken BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidSessionToken();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAwsInvalidSessionToken({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidSessionToken(
  props: StreamingProps<'TestAwsInvalidSessionToken'>
): StreamingHookResult<'TestAwsInvalidSessionToken'>;

export function useTestAwsInvalidSessionToken(
  props?: NonStreamingProps<'TestAwsInvalidSessionToken'>
): NonStreamingHookResult<'TestAwsInvalidSessionToken'>;

export function useTestAwsInvalidSessionToken(
  props: HookProps<'TestAwsInvalidSessionToken'> = {}
): StreamingHookResult<'TestAwsInvalidSessionToken'> | NonStreamingHookResult<'TestAwsInvalidSessionToken'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAwsInvalidSessionToken, props);
  }

  return useBamlAction(Actions.TestAwsInvalidSessionToken, props);
}
/**
 * A specialized hook for the TestAzure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzure();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzure({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzure(
  props: StreamingProps<'TestAzure'>
): StreamingHookResult<'TestAzure'>;

export function useTestAzure(
  props?: NonStreamingProps<'TestAzure'>
): NonStreamingHookResult<'TestAzure'>;

export function useTestAzure(
  props: HookProps<'TestAzure'> = {}
): StreamingHookResult<'TestAzure'> | NonStreamingHookResult<'TestAzure'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzure, props);
  }

  return useBamlAction(Actions.TestAzure, props);
}
/**
 * A specialized hook for the TestAzureFailure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureFailure();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzureFailure({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureFailure(
  props: StreamingProps<'TestAzureFailure'>
): StreamingHookResult<'TestAzureFailure'>;

export function useTestAzureFailure(
  props?: NonStreamingProps<'TestAzureFailure'>
): NonStreamingHookResult<'TestAzureFailure'>;

export function useTestAzureFailure(
  props: HookProps<'TestAzureFailure'> = {}
): StreamingHookResult<'TestAzureFailure'> | NonStreamingHookResult<'TestAzureFailure'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzureFailure, props);
  }

  return useBamlAction(Actions.TestAzureFailure, props);
}
/**
 * A specialized hook for the TestAzureO1NoMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO1NoMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzureO1NoMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO1NoMaxTokens(
  props: StreamingProps<'TestAzureO1NoMaxTokens'>
): StreamingHookResult<'TestAzureO1NoMaxTokens'>;

export function useTestAzureO1NoMaxTokens(
  props?: NonStreamingProps<'TestAzureO1NoMaxTokens'>
): NonStreamingHookResult<'TestAzureO1NoMaxTokens'>;

export function useTestAzureO1NoMaxTokens(
  props: HookProps<'TestAzureO1NoMaxTokens'> = {}
): StreamingHookResult<'TestAzureO1NoMaxTokens'> | NonStreamingHookResult<'TestAzureO1NoMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzureO1NoMaxTokens, props);
  }

  return useBamlAction(Actions.TestAzureO1NoMaxTokens, props);
}
/**
 * A specialized hook for the TestAzureO1WithMaxCompletionTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO1WithMaxCompletionTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzureO1WithMaxCompletionTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO1WithMaxCompletionTokens(
  props: StreamingProps<'TestAzureO1WithMaxCompletionTokens'>
): StreamingHookResult<'TestAzureO1WithMaxCompletionTokens'>;

export function useTestAzureO1WithMaxCompletionTokens(
  props?: NonStreamingProps<'TestAzureO1WithMaxCompletionTokens'>
): NonStreamingHookResult<'TestAzureO1WithMaxCompletionTokens'>;

export function useTestAzureO1WithMaxCompletionTokens(
  props: HookProps<'TestAzureO1WithMaxCompletionTokens'> = {}
): StreamingHookResult<'TestAzureO1WithMaxCompletionTokens'> | NonStreamingHookResult<'TestAzureO1WithMaxCompletionTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzureO1WithMaxCompletionTokens, props);
  }

  return useBamlAction(Actions.TestAzureO1WithMaxCompletionTokens, props);
}
/**
 * A specialized hook for the TestAzureO1WithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO1WithMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzureO1WithMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO1WithMaxTokens(
  props: StreamingProps<'TestAzureO1WithMaxTokens'>
): StreamingHookResult<'TestAzureO1WithMaxTokens'>;

export function useTestAzureO1WithMaxTokens(
  props?: NonStreamingProps<'TestAzureO1WithMaxTokens'>
): NonStreamingHookResult<'TestAzureO1WithMaxTokens'>;

export function useTestAzureO1WithMaxTokens(
  props: HookProps<'TestAzureO1WithMaxTokens'> = {}
): StreamingHookResult<'TestAzureO1WithMaxTokens'> | NonStreamingHookResult<'TestAzureO1WithMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzureO1WithMaxTokens, props);
  }

  return useBamlAction(Actions.TestAzureO1WithMaxTokens, props);
}
/**
 * A specialized hook for the TestAzureO3NoMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO3NoMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzureO3NoMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO3NoMaxTokens(
  props: StreamingProps<'TestAzureO3NoMaxTokens'>
): StreamingHookResult<'TestAzureO3NoMaxTokens'>;

export function useTestAzureO3NoMaxTokens(
  props?: NonStreamingProps<'TestAzureO3NoMaxTokens'>
): NonStreamingHookResult<'TestAzureO3NoMaxTokens'>;

export function useTestAzureO3NoMaxTokens(
  props: HookProps<'TestAzureO3NoMaxTokens'> = {}
): StreamingHookResult<'TestAzureO3NoMaxTokens'> | NonStreamingHookResult<'TestAzureO3NoMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzureO3NoMaxTokens, props);
  }

  return useBamlAction(Actions.TestAzureO3NoMaxTokens, props);
}
/**
 * A specialized hook for the TestAzureO3WithMaxCompletionTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO3WithMaxCompletionTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzureO3WithMaxCompletionTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO3WithMaxCompletionTokens(
  props: StreamingProps<'TestAzureO3WithMaxCompletionTokens'>
): StreamingHookResult<'TestAzureO3WithMaxCompletionTokens'>;

export function useTestAzureO3WithMaxCompletionTokens(
  props?: NonStreamingProps<'TestAzureO3WithMaxCompletionTokens'>
): NonStreamingHookResult<'TestAzureO3WithMaxCompletionTokens'>;

export function useTestAzureO3WithMaxCompletionTokens(
  props: HookProps<'TestAzureO3WithMaxCompletionTokens'> = {}
): StreamingHookResult<'TestAzureO3WithMaxCompletionTokens'> | NonStreamingHookResult<'TestAzureO3WithMaxCompletionTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzureO3WithMaxCompletionTokens, props);
  }

  return useBamlAction(Actions.TestAzureO3WithMaxCompletionTokens, props);
}
/**
 * A specialized hook for the TestAzureWithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureWithMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestAzureWithMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureWithMaxTokens(
  props: StreamingProps<'TestAzureWithMaxTokens'>
): StreamingHookResult<'TestAzureWithMaxTokens'>;

export function useTestAzureWithMaxTokens(
  props?: NonStreamingProps<'TestAzureWithMaxTokens'>
): NonStreamingHookResult<'TestAzureWithMaxTokens'>;

export function useTestAzureWithMaxTokens(
  props: HookProps<'TestAzureWithMaxTokens'> = {}
): StreamingHookResult<'TestAzureWithMaxTokens'> | NonStreamingHookResult<'TestAzureWithMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestAzureWithMaxTokens, props);
  }

  return useBamlAction(Actions.TestAzureWithMaxTokens, props);
}
/**
 * A specialized hook for the TestCaching BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 * - not_cached: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestCaching();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestCaching({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestCaching(
  props: StreamingProps<'TestCaching'>
): StreamingHookResult<'TestCaching'>;

export function useTestCaching(
  props?: NonStreamingProps<'TestCaching'>
): NonStreamingHookResult<'TestCaching'>;

export function useTestCaching(
  props: HookProps<'TestCaching'> = {}
): StreamingHookResult<'TestCaching'> | NonStreamingHookResult<'TestCaching'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestCaching, props);
  }

  return useBamlAction(Actions.TestCaching, props);
}
/**
 * A specialized hook for the TestFallbackClient BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFallbackClient();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFallbackClient({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFallbackClient(
  props: StreamingProps<'TestFallbackClient'>
): StreamingHookResult<'TestFallbackClient'>;

export function useTestFallbackClient(
  props?: NonStreamingProps<'TestFallbackClient'>
): NonStreamingHookResult<'TestFallbackClient'>;

export function useTestFallbackClient(
  props: HookProps<'TestFallbackClient'> = {}
): StreamingHookResult<'TestFallbackClient'> | NonStreamingHookResult<'TestFallbackClient'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFallbackClient, props);
  }

  return useBamlAction(Actions.TestFallbackClient, props);
}
/**
 * A specialized hook for the TestFallbackToShorthand BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFallbackToShorthand();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFallbackToShorthand({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFallbackToShorthand(
  props: StreamingProps<'TestFallbackToShorthand'>
): StreamingHookResult<'TestFallbackToShorthand'>;

export function useTestFallbackToShorthand(
  props?: NonStreamingProps<'TestFallbackToShorthand'>
): NonStreamingHookResult<'TestFallbackToShorthand'>;

export function useTestFallbackToShorthand(
  props: HookProps<'TestFallbackToShorthand'> = {}
): StreamingHookResult<'TestFallbackToShorthand'> | NonStreamingHookResult<'TestFallbackToShorthand'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFallbackToShorthand, props);
  }

  return useBamlAction(Actions.TestFallbackToShorthand, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myBool: boolean
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleBool();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleBool({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleBool(
  props: StreamingProps<'TestFnNamedArgsSingleBool'>
): StreamingHookResult<'TestFnNamedArgsSingleBool'>;

export function useTestFnNamedArgsSingleBool(
  props?: NonStreamingProps<'TestFnNamedArgsSingleBool'>
): NonStreamingHookResult<'TestFnNamedArgsSingleBool'>;

export function useTestFnNamedArgsSingleBool(
  props: HookProps<'TestFnNamedArgsSingleBool'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleBool'> | NonStreamingHookResult<'TestFnNamedArgsSingleBool'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleBool, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleBool, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleClass();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleClass({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleClass(
  props: StreamingProps<'TestFnNamedArgsSingleClass'>
): StreamingHookResult<'TestFnNamedArgsSingleClass'>;

export function useTestFnNamedArgsSingleClass(
  props?: NonStreamingProps<'TestFnNamedArgsSingleClass'>
): NonStreamingHookResult<'TestFnNamedArgsSingleClass'>;

export function useTestFnNamedArgsSingleClass(
  props: HookProps<'TestFnNamedArgsSingleClass'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleClass'> | NonStreamingHookResult<'TestFnNamedArgsSingleClass'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleClass, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleClass, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleEnumList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleEnumList[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleEnumList();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleEnumList({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleEnumList(
  props: StreamingProps<'TestFnNamedArgsSingleEnumList'>
): StreamingHookResult<'TestFnNamedArgsSingleEnumList'>;

export function useTestFnNamedArgsSingleEnumList(
  props?: NonStreamingProps<'TestFnNamedArgsSingleEnumList'>
): NonStreamingHookResult<'TestFnNamedArgsSingleEnumList'>;

export function useTestFnNamedArgsSingleEnumList(
  props: HookProps<'TestFnNamedArgsSingleEnumList'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleEnumList'> | NonStreamingHookResult<'TestFnNamedArgsSingleEnumList'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleEnumList, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleEnumList, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleFloat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myFloat: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleFloat();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleFloat({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleFloat(
  props: StreamingProps<'TestFnNamedArgsSingleFloat'>
): StreamingHookResult<'TestFnNamedArgsSingleFloat'>;

export function useTestFnNamedArgsSingleFloat(
  props?: NonStreamingProps<'TestFnNamedArgsSingleFloat'>
): NonStreamingHookResult<'TestFnNamedArgsSingleFloat'>;

export function useTestFnNamedArgsSingleFloat(
  props: HookProps<'TestFnNamedArgsSingleFloat'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleFloat'> | NonStreamingHookResult<'TestFnNamedArgsSingleFloat'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleFloat, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleFloat, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myInt: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleInt();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleInt({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleInt(
  props: StreamingProps<'TestFnNamedArgsSingleInt'>
): StreamingHookResult<'TestFnNamedArgsSingleInt'>;

export function useTestFnNamedArgsSingleInt(
  props?: NonStreamingProps<'TestFnNamedArgsSingleInt'>
): NonStreamingHookResult<'TestFnNamedArgsSingleInt'>;

export function useTestFnNamedArgsSingleInt(
  props: HookProps<'TestFnNamedArgsSingleInt'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleInt'> | NonStreamingHookResult<'TestFnNamedArgsSingleInt'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleInt, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleInt, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myMap: Record<string, StringToClassEntry>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, StringToClassEntry>
 * - **Streaming Partial:** (Record<string, (partial_types.StringToClassEntry | null)> )
 * - **Streaming Final:** Record<string, StringToClassEntry>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleMapStringToClass();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleMapStringToClass({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToClass(
  props: StreamingProps<'TestFnNamedArgsSingleMapStringToClass'>
): StreamingHookResult<'TestFnNamedArgsSingleMapStringToClass'>;

export function useTestFnNamedArgsSingleMapStringToClass(
  props?: NonStreamingProps<'TestFnNamedArgsSingleMapStringToClass'>
): NonStreamingHookResult<'TestFnNamedArgsSingleMapStringToClass'>;

export function useTestFnNamedArgsSingleMapStringToClass(
  props: HookProps<'TestFnNamedArgsSingleMapStringToClass'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleMapStringToClass'> | NonStreamingHookResult<'TestFnNamedArgsSingleMapStringToClass'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleMapStringToClass, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleMapStringToClass, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToMap BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myMap: Record<string, Record<string, string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, Record<string, string>>
 * - **Streaming Partial:** (Record<string, (Record<string, (string | null)> | null)> )
 * - **Streaming Final:** Record<string, Record<string, string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleMapStringToMap();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleMapStringToMap({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToMap(
  props: StreamingProps<'TestFnNamedArgsSingleMapStringToMap'>
): StreamingHookResult<'TestFnNamedArgsSingleMapStringToMap'>;

export function useTestFnNamedArgsSingleMapStringToMap(
  props?: NonStreamingProps<'TestFnNamedArgsSingleMapStringToMap'>
): NonStreamingHookResult<'TestFnNamedArgsSingleMapStringToMap'>;

export function useTestFnNamedArgsSingleMapStringToMap(
  props: HookProps<'TestFnNamedArgsSingleMapStringToMap'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleMapStringToMap'> | NonStreamingHookResult<'TestFnNamedArgsSingleMapStringToMap'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleMapStringToMap, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleMapStringToMap, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myMap: Record<string, string>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, string>
 * - **Streaming Partial:** (Record<string, (string | null)> )
 * - **Streaming Final:** Record<string, string>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleMapStringToString();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleMapStringToString({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToString(
  props: StreamingProps<'TestFnNamedArgsSingleMapStringToString'>
): StreamingHookResult<'TestFnNamedArgsSingleMapStringToString'>;

export function useTestFnNamedArgsSingleMapStringToString(
  props?: NonStreamingProps<'TestFnNamedArgsSingleMapStringToString'>
): NonStreamingHookResult<'TestFnNamedArgsSingleMapStringToString'>;

export function useTestFnNamedArgsSingleMapStringToString(
  props: HookProps<'TestFnNamedArgsSingleMapStringToString'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleMapStringToString'> | NonStreamingHookResult<'TestFnNamedArgsSingleMapStringToString'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleMapStringToString, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleMapStringToString, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myString: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleString();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleString({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleString(
  props: StreamingProps<'TestFnNamedArgsSingleString'>
): StreamingHookResult<'TestFnNamedArgsSingleString'>;

export function useTestFnNamedArgsSingleString(
  props?: NonStreamingProps<'TestFnNamedArgsSingleString'>
): NonStreamingHookResult<'TestFnNamedArgsSingleString'>;

export function useTestFnNamedArgsSingleString(
  props: HookProps<'TestFnNamedArgsSingleString'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleString'> | NonStreamingHookResult<'TestFnNamedArgsSingleString'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleString, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleString, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleStringArray BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myStringArray: string[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleStringArray();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleStringArray({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleStringArray(
  props: StreamingProps<'TestFnNamedArgsSingleStringArray'>
): StreamingHookResult<'TestFnNamedArgsSingleStringArray'>;

export function useTestFnNamedArgsSingleStringArray(
  props?: NonStreamingProps<'TestFnNamedArgsSingleStringArray'>
): NonStreamingHookResult<'TestFnNamedArgsSingleStringArray'>;

export function useTestFnNamedArgsSingleStringArray(
  props: HookProps<'TestFnNamedArgsSingleStringArray'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleStringArray'> | NonStreamingHookResult<'TestFnNamedArgsSingleStringArray'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleStringArray, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleStringArray, props);
}
/**
 * A specialized hook for the TestFnNamedArgsSingleStringList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: string[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleStringList();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestFnNamedArgsSingleStringList({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleStringList(
  props: StreamingProps<'TestFnNamedArgsSingleStringList'>
): StreamingHookResult<'TestFnNamedArgsSingleStringList'>;

export function useTestFnNamedArgsSingleStringList(
  props?: NonStreamingProps<'TestFnNamedArgsSingleStringList'>
): NonStreamingHookResult<'TestFnNamedArgsSingleStringList'>;

export function useTestFnNamedArgsSingleStringList(
  props: HookProps<'TestFnNamedArgsSingleStringList'> = {}
): StreamingHookResult<'TestFnNamedArgsSingleStringList'> | NonStreamingHookResult<'TestFnNamedArgsSingleStringList'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleStringList, props);
  }

  return useBamlAction(Actions.TestFnNamedArgsSingleStringList, props);
}
/**
 * A specialized hook for the TestGemini BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGemini();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestGemini({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGemini(
  props: StreamingProps<'TestGemini'>
): StreamingHookResult<'TestGemini'>;

export function useTestGemini(
  props?: NonStreamingProps<'TestGemini'>
): NonStreamingHookResult<'TestGemini'>;

export function useTestGemini(
  props: HookProps<'TestGemini'> = {}
): StreamingHookResult<'TestGemini'> | NonStreamingHookResult<'TestGemini'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestGemini, props);
  }

  return useBamlAction(Actions.TestGemini, props);
}
/**
 * A specialized hook for the TestGeminiOpenAiGeneric BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGeminiOpenAiGeneric();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestGeminiOpenAiGeneric({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGeminiOpenAiGeneric(
  props: StreamingProps<'TestGeminiOpenAiGeneric'>
): StreamingHookResult<'TestGeminiOpenAiGeneric'>;

export function useTestGeminiOpenAiGeneric(
  props?: NonStreamingProps<'TestGeminiOpenAiGeneric'>
): NonStreamingHookResult<'TestGeminiOpenAiGeneric'>;

export function useTestGeminiOpenAiGeneric(
  props: HookProps<'TestGeminiOpenAiGeneric'> = {}
): StreamingHookResult<'TestGeminiOpenAiGeneric'> | NonStreamingHookResult<'TestGeminiOpenAiGeneric'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestGeminiOpenAiGeneric, props);
  }

  return useBamlAction(Actions.TestGeminiOpenAiGeneric, props);
}
/**
 * A specialized hook for the TestGeminiSystem BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGeminiSystem();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestGeminiSystem({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGeminiSystem(
  props: StreamingProps<'TestGeminiSystem'>
): StreamingHookResult<'TestGeminiSystem'>;

export function useTestGeminiSystem(
  props?: NonStreamingProps<'TestGeminiSystem'>
): NonStreamingHookResult<'TestGeminiSystem'>;

export function useTestGeminiSystem(
  props: HookProps<'TestGeminiSystem'> = {}
): StreamingHookResult<'TestGeminiSystem'> | NonStreamingHookResult<'TestGeminiSystem'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestGeminiSystem, props);
  }

  return useBamlAction(Actions.TestGeminiSystem, props);
}
/**
 * A specialized hook for the TestGeminiSystemAsChat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGeminiSystemAsChat();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestGeminiSystemAsChat({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGeminiSystemAsChat(
  props: StreamingProps<'TestGeminiSystemAsChat'>
): StreamingHookResult<'TestGeminiSystemAsChat'>;

export function useTestGeminiSystemAsChat(
  props?: NonStreamingProps<'TestGeminiSystemAsChat'>
): NonStreamingHookResult<'TestGeminiSystemAsChat'>;

export function useTestGeminiSystemAsChat(
  props: HookProps<'TestGeminiSystemAsChat'> = {}
): StreamingHookResult<'TestGeminiSystemAsChat'> | NonStreamingHookResult<'TestGeminiSystemAsChat'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestGeminiSystemAsChat, props);
  }

  return useBamlAction(Actions.TestGeminiSystemAsChat, props);
}
/**
 * A specialized hook for the TestImageInput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestImageInput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestImageInput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestImageInput(
  props: StreamingProps<'TestImageInput'>
): StreamingHookResult<'TestImageInput'>;

export function useTestImageInput(
  props?: NonStreamingProps<'TestImageInput'>
): NonStreamingHookResult<'TestImageInput'>;

export function useTestImageInput(
  props: HookProps<'TestImageInput'> = {}
): StreamingHookResult<'TestImageInput'> | NonStreamingHookResult<'TestImageInput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestImageInput, props);
  }

  return useBamlAction(Actions.TestImageInput, props);
}
/**
 * A specialized hook for the TestImageInputAnthropic BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestImageInputAnthropic();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestImageInputAnthropic({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestImageInputAnthropic(
  props: StreamingProps<'TestImageInputAnthropic'>
): StreamingHookResult<'TestImageInputAnthropic'>;

export function useTestImageInputAnthropic(
  props?: NonStreamingProps<'TestImageInputAnthropic'>
): NonStreamingHookResult<'TestImageInputAnthropic'>;

export function useTestImageInputAnthropic(
  props: HookProps<'TestImageInputAnthropic'> = {}
): StreamingHookResult<'TestImageInputAnthropic'> | NonStreamingHookResult<'TestImageInputAnthropic'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestImageInputAnthropic, props);
  }

  return useBamlAction(Actions.TestImageInputAnthropic, props);
}
/**
 * A specialized hook for the TestImageListInput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - imgs: Image[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestImageListInput();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestImageListInput({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestImageListInput(
  props: StreamingProps<'TestImageListInput'>
): StreamingHookResult<'TestImageListInput'>;

export function useTestImageListInput(
  props?: NonStreamingProps<'TestImageListInput'>
): NonStreamingHookResult<'TestImageListInput'>;

export function useTestImageListInput(
  props: HookProps<'TestImageListInput'> = {}
): StreamingHookResult<'TestImageListInput'> | NonStreamingHookResult<'TestImageListInput'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestImageListInput, props);
  }

  return useBamlAction(Actions.TestImageListInput, props);
}
/**
 * A specialized hook for the TestMemory BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestMemoryOutput
 * - **Streaming Partial:** partial_types.TestMemoryOutput
 * - **Streaming Final:** TestMemoryOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestMemory();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestMemory({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestMemory(
  props: StreamingProps<'TestMemory'>
): StreamingHookResult<'TestMemory'>;

export function useTestMemory(
  props?: NonStreamingProps<'TestMemory'>
): NonStreamingHookResult<'TestMemory'>;

export function useTestMemory(
  props: HookProps<'TestMemory'> = {}
): StreamingHookResult<'TestMemory'> | NonStreamingHookResult<'TestMemory'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestMemory, props);
  }

  return useBamlAction(Actions.TestMemory, props);
}
/**
 * A specialized hook for the TestMulticlassNamedArgs BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleClass
 *
 * - myArg2: NamedArgsSingleClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestMulticlassNamedArgs();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestMulticlassNamedArgs({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestMulticlassNamedArgs(
  props: StreamingProps<'TestMulticlassNamedArgs'>
): StreamingHookResult<'TestMulticlassNamedArgs'>;

export function useTestMulticlassNamedArgs(
  props?: NonStreamingProps<'TestMulticlassNamedArgs'>
): NonStreamingHookResult<'TestMulticlassNamedArgs'>;

export function useTestMulticlassNamedArgs(
  props: HookProps<'TestMulticlassNamedArgs'> = {}
): StreamingHookResult<'TestMulticlassNamedArgs'> | NonStreamingHookResult<'TestMulticlassNamedArgs'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestMulticlassNamedArgs, props);
  }

  return useBamlAction(Actions.TestMulticlassNamedArgs, props);
}
/**
 * A specialized hook for the TestNamedArgsLiteralBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myBool: true
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestNamedArgsLiteralBool();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestNamedArgsLiteralBool({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestNamedArgsLiteralBool(
  props: StreamingProps<'TestNamedArgsLiteralBool'>
): StreamingHookResult<'TestNamedArgsLiteralBool'>;

export function useTestNamedArgsLiteralBool(
  props?: NonStreamingProps<'TestNamedArgsLiteralBool'>
): NonStreamingHookResult<'TestNamedArgsLiteralBool'>;

export function useTestNamedArgsLiteralBool(
  props: HookProps<'TestNamedArgsLiteralBool'> = {}
): StreamingHookResult<'TestNamedArgsLiteralBool'> | NonStreamingHookResult<'TestNamedArgsLiteralBool'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestNamedArgsLiteralBool, props);
  }

  return useBamlAction(Actions.TestNamedArgsLiteralBool, props);
}
/**
 * A specialized hook for the TestNamedArgsLiteralInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myInt: 1
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestNamedArgsLiteralInt();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestNamedArgsLiteralInt({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestNamedArgsLiteralInt(
  props: StreamingProps<'TestNamedArgsLiteralInt'>
): StreamingHookResult<'TestNamedArgsLiteralInt'>;

export function useTestNamedArgsLiteralInt(
  props?: NonStreamingProps<'TestNamedArgsLiteralInt'>
): NonStreamingHookResult<'TestNamedArgsLiteralInt'>;

export function useTestNamedArgsLiteralInt(
  props: HookProps<'TestNamedArgsLiteralInt'> = {}
): StreamingHookResult<'TestNamedArgsLiteralInt'> | NonStreamingHookResult<'TestNamedArgsLiteralInt'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestNamedArgsLiteralInt, props);
  }

  return useBamlAction(Actions.TestNamedArgsLiteralInt, props);
}
/**
 * A specialized hook for the TestNamedArgsLiteralString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myString: "My String"
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestNamedArgsLiteralString();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestNamedArgsLiteralString({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestNamedArgsLiteralString(
  props: StreamingProps<'TestNamedArgsLiteralString'>
): StreamingHookResult<'TestNamedArgsLiteralString'>;

export function useTestNamedArgsLiteralString(
  props?: NonStreamingProps<'TestNamedArgsLiteralString'>
): NonStreamingHookResult<'TestNamedArgsLiteralString'>;

export function useTestNamedArgsLiteralString(
  props: HookProps<'TestNamedArgsLiteralString'> = {}
): StreamingHookResult<'TestNamedArgsLiteralString'> | NonStreamingHookResult<'TestNamedArgsLiteralString'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestNamedArgsLiteralString, props);
  }

  return useBamlAction(Actions.TestNamedArgsLiteralString, props);
}
/**
 * A specialized hook for the TestOllama BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOllama();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOllama({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOllama(
  props: StreamingProps<'TestOllama'>
): StreamingHookResult<'TestOllama'>;

export function useTestOllama(
  props?: NonStreamingProps<'TestOllama'>
): NonStreamingHookResult<'TestOllama'>;

export function useTestOllama(
  props: HookProps<'TestOllama'> = {}
): StreamingHookResult<'TestOllama'> | NonStreamingHookResult<'TestOllama'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOllama, props);
  }

  return useBamlAction(Actions.TestOllama, props);
}
/**
 * A specialized hook for the TestOpenAI BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAI();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAI({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAI(
  props: StreamingProps<'TestOpenAI'>
): StreamingHookResult<'TestOpenAI'>;

export function useTestOpenAI(
  props?: NonStreamingProps<'TestOpenAI'>
): NonStreamingHookResult<'TestOpenAI'>;

export function useTestOpenAI(
  props: HookProps<'TestOpenAI'> = {}
): StreamingHookResult<'TestOpenAI'> | NonStreamingHookResult<'TestOpenAI'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAI, props);
  }

  return useBamlAction(Actions.TestOpenAI, props);
}
/**
 * A specialized hook for the TestOpenAILegacyProvider BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAILegacyProvider();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAILegacyProvider({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAILegacyProvider(
  props: StreamingProps<'TestOpenAILegacyProvider'>
): StreamingHookResult<'TestOpenAILegacyProvider'>;

export function useTestOpenAILegacyProvider(
  props?: NonStreamingProps<'TestOpenAILegacyProvider'>
): NonStreamingHookResult<'TestOpenAILegacyProvider'>;

export function useTestOpenAILegacyProvider(
  props: HookProps<'TestOpenAILegacyProvider'> = {}
): StreamingHookResult<'TestOpenAILegacyProvider'> | NonStreamingHookResult<'TestOpenAILegacyProvider'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAILegacyProvider, props);
  }

  return useBamlAction(Actions.TestOpenAILegacyProvider, props);
}
/**
 * A specialized hook for the TestOpenAIO1NoMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIO1NoMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAIO1NoMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIO1NoMaxTokens(
  props: StreamingProps<'TestOpenAIO1NoMaxTokens'>
): StreamingHookResult<'TestOpenAIO1NoMaxTokens'>;

export function useTestOpenAIO1NoMaxTokens(
  props?: NonStreamingProps<'TestOpenAIO1NoMaxTokens'>
): NonStreamingHookResult<'TestOpenAIO1NoMaxTokens'>;

export function useTestOpenAIO1NoMaxTokens(
  props: HookProps<'TestOpenAIO1NoMaxTokens'> = {}
): StreamingHookResult<'TestOpenAIO1NoMaxTokens'> | NonStreamingHookResult<'TestOpenAIO1NoMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAIO1NoMaxTokens, props);
  }

  return useBamlAction(Actions.TestOpenAIO1NoMaxTokens, props);
}
/**
 * A specialized hook for the TestOpenAIO1WithMaxCompletionTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIO1WithMaxCompletionTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAIO1WithMaxCompletionTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIO1WithMaxCompletionTokens(
  props: StreamingProps<'TestOpenAIO1WithMaxCompletionTokens'>
): StreamingHookResult<'TestOpenAIO1WithMaxCompletionTokens'>;

export function useTestOpenAIO1WithMaxCompletionTokens(
  props?: NonStreamingProps<'TestOpenAIO1WithMaxCompletionTokens'>
): NonStreamingHookResult<'TestOpenAIO1WithMaxCompletionTokens'>;

export function useTestOpenAIO1WithMaxCompletionTokens(
  props: HookProps<'TestOpenAIO1WithMaxCompletionTokens'> = {}
): StreamingHookResult<'TestOpenAIO1WithMaxCompletionTokens'> | NonStreamingHookResult<'TestOpenAIO1WithMaxCompletionTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAIO1WithMaxCompletionTokens, props);
  }

  return useBamlAction(Actions.TestOpenAIO1WithMaxCompletionTokens, props);
}
/**
 * A specialized hook for the TestOpenAIO1WithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIO1WithMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAIO1WithMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIO1WithMaxTokens(
  props: StreamingProps<'TestOpenAIO1WithMaxTokens'>
): StreamingHookResult<'TestOpenAIO1WithMaxTokens'>;

export function useTestOpenAIO1WithMaxTokens(
  props?: NonStreamingProps<'TestOpenAIO1WithMaxTokens'>
): NonStreamingHookResult<'TestOpenAIO1WithMaxTokens'>;

export function useTestOpenAIO1WithMaxTokens(
  props: HookProps<'TestOpenAIO1WithMaxTokens'> = {}
): StreamingHookResult<'TestOpenAIO1WithMaxTokens'> | NonStreamingHookResult<'TestOpenAIO1WithMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAIO1WithMaxTokens, props);
  }

  return useBamlAction(Actions.TestOpenAIO1WithMaxTokens, props);
}
/**
 * A specialized hook for the TestOpenAIShorthand BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIShorthand();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAIShorthand({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIShorthand(
  props: StreamingProps<'TestOpenAIShorthand'>
): StreamingHookResult<'TestOpenAIShorthand'>;

export function useTestOpenAIShorthand(
  props?: NonStreamingProps<'TestOpenAIShorthand'>
): NonStreamingHookResult<'TestOpenAIShorthand'>;

export function useTestOpenAIShorthand(
  props: HookProps<'TestOpenAIShorthand'> = {}
): StreamingHookResult<'TestOpenAIShorthand'> | NonStreamingHookResult<'TestOpenAIShorthand'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAIShorthand, props);
  }

  return useBamlAction(Actions.TestOpenAIShorthand, props);
}
/**
 * A specialized hook for the TestOpenAIWithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIWithMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAIWithMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIWithMaxTokens(
  props: StreamingProps<'TestOpenAIWithMaxTokens'>
): StreamingHookResult<'TestOpenAIWithMaxTokens'>;

export function useTestOpenAIWithMaxTokens(
  props?: NonStreamingProps<'TestOpenAIWithMaxTokens'>
): NonStreamingHookResult<'TestOpenAIWithMaxTokens'>;

export function useTestOpenAIWithMaxTokens(
  props: HookProps<'TestOpenAIWithMaxTokens'> = {}
): StreamingHookResult<'TestOpenAIWithMaxTokens'> | NonStreamingHookResult<'TestOpenAIWithMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAIWithMaxTokens, props);
  }

  return useBamlAction(Actions.TestOpenAIWithMaxTokens, props);
}
/**
 * A specialized hook for the TestOpenAIWithNullMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIWithNullMaxTokens();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestOpenAIWithNullMaxTokens({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIWithNullMaxTokens(
  props: StreamingProps<'TestOpenAIWithNullMaxTokens'>
): StreamingHookResult<'TestOpenAIWithNullMaxTokens'>;

export function useTestOpenAIWithNullMaxTokens(
  props?: NonStreamingProps<'TestOpenAIWithNullMaxTokens'>
): NonStreamingHookResult<'TestOpenAIWithNullMaxTokens'>;

export function useTestOpenAIWithNullMaxTokens(
  props: HookProps<'TestOpenAIWithNullMaxTokens'> = {}
): StreamingHookResult<'TestOpenAIWithNullMaxTokens'> | NonStreamingHookResult<'TestOpenAIWithNullMaxTokens'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestOpenAIWithNullMaxTokens, props);
  }

  return useBamlAction(Actions.TestOpenAIWithNullMaxTokens, props);
}
/**
 * A specialized hook for the TestRetryConstant BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestRetryConstant();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestRetryConstant({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestRetryConstant(
  props: StreamingProps<'TestRetryConstant'>
): StreamingHookResult<'TestRetryConstant'>;

export function useTestRetryConstant(
  props?: NonStreamingProps<'TestRetryConstant'>
): NonStreamingHookResult<'TestRetryConstant'>;

export function useTestRetryConstant(
  props: HookProps<'TestRetryConstant'> = {}
): StreamingHookResult<'TestRetryConstant'> | NonStreamingHookResult<'TestRetryConstant'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestRetryConstant, props);
  }

  return useBamlAction(Actions.TestRetryConstant, props);
}
/**
 * A specialized hook for the TestRetryExponential BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestRetryExponential();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestRetryExponential({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestRetryExponential(
  props: StreamingProps<'TestRetryExponential'>
): StreamingHookResult<'TestRetryExponential'>;

export function useTestRetryExponential(
  props?: NonStreamingProps<'TestRetryExponential'>
): NonStreamingHookResult<'TestRetryExponential'>;

export function useTestRetryExponential(
  props: HookProps<'TestRetryExponential'> = {}
): StreamingHookResult<'TestRetryExponential'> | NonStreamingHookResult<'TestRetryExponential'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestRetryExponential, props);
  }

  return useBamlAction(Actions.TestRetryExponential, props);
}
/**
 * A specialized hook for the TestSingleFallbackClient BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestSingleFallbackClient();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestSingleFallbackClient({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestSingleFallbackClient(
  props: StreamingProps<'TestSingleFallbackClient'>
): StreamingHookResult<'TestSingleFallbackClient'>;

export function useTestSingleFallbackClient(
  props?: NonStreamingProps<'TestSingleFallbackClient'>
): NonStreamingHookResult<'TestSingleFallbackClient'>;

export function useTestSingleFallbackClient(
  props: HookProps<'TestSingleFallbackClient'> = {}
): StreamingHookResult<'TestSingleFallbackClient'> | NonStreamingHookResult<'TestSingleFallbackClient'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestSingleFallbackClient, props);
  }

  return useBamlAction(Actions.TestSingleFallbackClient, props);
}
/**
 * A specialized hook for the TestUniverseQuestion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - question: UniverseQuestionInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** UniverseQuestion
 * - **Streaming Partial:** partial_types.UniverseQuestion
 * - **Streaming Final:** UniverseQuestion
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestUniverseQuestion();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestUniverseQuestion({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestUniverseQuestion(
  props: StreamingProps<'TestUniverseQuestion'>
): StreamingHookResult<'TestUniverseQuestion'>;

export function useTestUniverseQuestion(
  props?: NonStreamingProps<'TestUniverseQuestion'>
): NonStreamingHookResult<'TestUniverseQuestion'>;

export function useTestUniverseQuestion(
  props: HookProps<'TestUniverseQuestion'> = {}
): StreamingHookResult<'TestUniverseQuestion'> | NonStreamingHookResult<'TestUniverseQuestion'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestUniverseQuestion, props);
  }

  return useBamlAction(Actions.TestUniverseQuestion, props);
}
/**
 * A specialized hook for the TestVertex BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestVertex();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestVertex({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestVertex(
  props: StreamingProps<'TestVertex'>
): StreamingHookResult<'TestVertex'>;

export function useTestVertex(
  props?: NonStreamingProps<'TestVertex'>
): NonStreamingHookResult<'TestVertex'>;

export function useTestVertex(
  props: HookProps<'TestVertex'> = {}
): StreamingHookResult<'TestVertex'> | NonStreamingHookResult<'TestVertex'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestVertex, props);
  }

  return useBamlAction(Actions.TestVertex, props);
}
/**
 * A specialized hook for the TestVertexWithSystemInstructions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestVertexWithSystemInstructions();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useTestVertexWithSystemInstructions({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestVertexWithSystemInstructions(
  props: StreamingProps<'TestVertexWithSystemInstructions'>
): StreamingHookResult<'TestVertexWithSystemInstructions'>;

export function useTestVertexWithSystemInstructions(
  props?: NonStreamingProps<'TestVertexWithSystemInstructions'>
): NonStreamingHookResult<'TestVertexWithSystemInstructions'>;

export function useTestVertexWithSystemInstructions(
  props: HookProps<'TestVertexWithSystemInstructions'> = {}
): StreamingHookResult<'TestVertexWithSystemInstructions'> | NonStreamingHookResult<'TestVertexWithSystemInstructions'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.TestVertexWithSystemInstructions, props);
  }

  return useBamlAction(Actions.TestVertexWithSystemInstructions, props);
}
/**
 * A specialized hook for the UnionTest_Function BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string | boolean
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** UnionTest_ReturnType
 * - **Streaming Partial:** partial_types.UnionTest_ReturnType
 * - **Streaming Final:** UnionTest_ReturnType
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUnionTest_Function();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useUnionTest_Function({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUnionTest_Function(
  props: StreamingProps<'UnionTest_Function'>
): StreamingHookResult<'UnionTest_Function'>;

export function useUnionTest_Function(
  props?: NonStreamingProps<'UnionTest_Function'>
): NonStreamingHookResult<'UnionTest_Function'>;

export function useUnionTest_Function(
  props: HookProps<'UnionTest_Function'> = {}
): StreamingHookResult<'UnionTest_Function'> | NonStreamingHookResult<'UnionTest_Function'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.UnionTest_Function, props);
  }

  return useBamlAction(Actions.UnionTest_Function, props);
}
/**
 * A specialized hook for the UseBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: BlockConstraintForParam
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUseBlockConstraint();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useUseBlockConstraint({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUseBlockConstraint(
  props: StreamingProps<'UseBlockConstraint'>
): StreamingHookResult<'UseBlockConstraint'>;

export function useUseBlockConstraint(
  props?: NonStreamingProps<'UseBlockConstraint'>
): NonStreamingHookResult<'UseBlockConstraint'>;

export function useUseBlockConstraint(
  props: HookProps<'UseBlockConstraint'> = {}
): StreamingHookResult<'UseBlockConstraint'> | NonStreamingHookResult<'UseBlockConstraint'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.UseBlockConstraint, props);
  }

  return useBamlAction(Actions.UseBlockConstraint, props);
}
/**
 * A specialized hook for the UseMalformedConstraints BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - a: MalformedConstraints2
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUseMalformedConstraints();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useUseMalformedConstraints({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUseMalformedConstraints(
  props: StreamingProps<'UseMalformedConstraints'>
): StreamingHookResult<'UseMalformedConstraints'>;

export function useUseMalformedConstraints(
  props?: NonStreamingProps<'UseMalformedConstraints'>
): NonStreamingHookResult<'UseMalformedConstraints'>;

export function useUseMalformedConstraints(
  props: HookProps<'UseMalformedConstraints'> = {}
): StreamingHookResult<'UseMalformedConstraints'> | NonStreamingHookResult<'UseMalformedConstraints'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.UseMalformedConstraints, props);
  }

  return useBamlAction(Actions.UseMalformedConstraints, props);
}
/**
 * A specialized hook for the UseNestedBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: NestedBlockConstraintForParam
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUseNestedBlockConstraint();
 *
 * // Streaming usage:
 * const { data, partialData, isPending, error, mutate } = useUseNestedBlockConstraint({
 *   stream: true,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUseNestedBlockConstraint(
  props: StreamingProps<'UseNestedBlockConstraint'>
): StreamingHookResult<'UseNestedBlockConstraint'>;

export function useUseNestedBlockConstraint(
  props?: NonStreamingProps<'UseNestedBlockConstraint'>
): NonStreamingHookResult<'UseNestedBlockConstraint'>;

export function useUseNestedBlockConstraint(
  props: HookProps<'UseNestedBlockConstraint'> = {}
): StreamingHookResult<'UseNestedBlockConstraint'> | NonStreamingHookResult<'UseNestedBlockConstraint'> {
  if (props.stream) {
    return useBamlAction(StreamingActions.UseNestedBlockConstraint, props);
  }

  return useBamlAction(Actions.UseNestedBlockConstraint, props);
}
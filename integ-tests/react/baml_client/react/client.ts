/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use client'

import { useCallback, useMemo, useReducer } from 'react';
import type { BamlStream } from '@boundaryml/baml';
import {
  AaaSamOutputFormatAction,
  AliasThatPointsToRecursiveTypeAction,
  AliasWithMultipleAttrsAction,
  AliasedInputClassAction,
  AliasedInputClass2Action,
  AliasedInputClassNestedAction,
  AliasedInputEnumAction,
  AliasedInputListAction,
  AllowedOptionalsAction,
  AudioInputAction,
  BuildLinkedListAction,
  BuildTreeAction,
  ClassThatPointsToRecursiveClassThroughAliasAction,
  ClassifyDynEnumTwoAction,
  ClassifyMessageAction,
  ClassifyMessage2Action,
  ClassifyMessage3Action,
  CompletionAction,
  CustomTaskAction,
  DescribeImageAction,
  DescribeImage2Action,
  DescribeImage3Action,
  DescribeImage4Action,
  DifferentiateUnionsAction,
  DummyOutputFunctionAction,
  DynamicFuncAction,
  DynamicInputOutputAction,
  DynamicListInputOutputAction,
  ExpectFailureAction,
  ExtractContactInfoAction,
  ExtractHobbyAction,
  ExtractNamesAction,
  ExtractPeopleAction,
  ExtractReceiptInfoAction,
  ExtractResumeAction,
  ExtractResume2Action,
  FnClassOptionalOutputAction,
  FnClassOptionalOutput2Action,
  FnEnumListOutputAction,
  FnEnumOutputAction,
  FnLiteralClassInputOutputAction,
  FnLiteralUnionClassInputOutputAction,
  FnNamedArgsSingleStringOptionalAction,
  FnOutputBoolAction,
  FnOutputClassAction,
  FnOutputClassListAction,
  FnOutputClassNestedAction,
  FnOutputClassWithEnumAction,
  FnOutputIntAction,
  FnOutputLiteralBoolAction,
  FnOutputLiteralIntAction,
  FnOutputLiteralStringAction,
  FnOutputStringListAction,
  FnTestAliasedEnumOutputAction,
  FnTestClassAliasAction,
  FnTestNamedArgsSingleEnumAction,
  GetDataTypeAction,
  GetOrderInfoAction,
  GetQueryAction,
  InOutEnumMapKeyAction,
  InOutLiteralStringUnionMapKeyAction,
  InOutSingleLiteralStringMapKeyAction,
  JsonTypeAliasCycleAction,
  LiteralUnionsTestAction,
  MakeBlockConstraintAction,
  MakeNestedBlockConstraintAction,
  MapAliasAction,
  MergeAliasAttributesAction,
  MyFuncAction,
  NestedAliasAction,
  OptionalTest_FunctionAction,
  PredictAgeAction,
  PredictAgeBareAction,
  PrimitiveAliasAction,
  PromptTestClaudeAction,
  PromptTestClaudeChatAction,
  PromptTestClaudeChatNoSystemAction,
  PromptTestOpenAIAction,
  PromptTestOpenAIChatAction,
  PromptTestOpenAIChatNoSystemAction,
  PromptTestStreamingAction,
  RecursiveAliasCycleAction,
  RecursiveClassWithAliasIndirectionAction,
  ReturnAliasWithMergedAttributesAction,
  ReturnFailingAssertAction,
  ReturnMalformedConstraintsAction,
  SchemaDescriptionsAction,
  SimpleRecursiveListAliasAction,
  SimpleRecursiveMapAliasAction,
  StreamBigNumbersAction,
  StreamFailingAssertionAction,
  StreamOneBigNumberAction,
  StreamUnionIntegersAction,
  StreamingCompoundNumbersAction,
  TestAnthropicAction,
  TestAnthropicShorthandAction,
  TestAwsAction,
  TestAwsInvalidAccessKeyAction,
  TestAwsInvalidProfileAction,
  TestAwsInvalidRegionAction,
  TestAwsInvalidSessionTokenAction,
  TestAzureAction,
  TestAzureFailureAction,
  TestCachingAction,
  TestFallbackClientAction,
  TestFallbackToShorthandAction,
  TestFnNamedArgsSingleBoolAction,
  TestFnNamedArgsSingleClassAction,
  TestFnNamedArgsSingleEnumListAction,
  TestFnNamedArgsSingleFloatAction,
  TestFnNamedArgsSingleIntAction,
  TestFnNamedArgsSingleMapStringToClassAction,
  TestFnNamedArgsSingleMapStringToMapAction,
  TestFnNamedArgsSingleMapStringToStringAction,
  TestFnNamedArgsSingleStringAction,
  TestFnNamedArgsSingleStringArrayAction,
  TestFnNamedArgsSingleStringListAction,
  TestGeminiAction,
  TestImageInputAction,
  TestImageInputAnthropicAction,
  TestImageListInputAction,
  TestMulticlassNamedArgsAction,
  TestNamedArgsLiteralBoolAction,
  TestNamedArgsLiteralIntAction,
  TestNamedArgsLiteralStringAction,
  TestOllamaAction,
  TestOpenAILegacyProviderAction,
  TestOpenAIShorthandAction,
  TestRetryConstantAction,
  TestRetryExponentialAction,
  TestSingleFallbackClientAction,
  TestVertexAction,
  UnionTest_FunctionAction,
  UseBlockConstraintAction,
  UseMalformedConstraintsAction,
  UseNestedBlockConstraintAction,
} from './server';

/**
 * A React hook for making BAML function calls with support for both streaming and non-streaming modes.
 * This hook handles all the complexity of managing state, streaming responses, and error handling.
 *
 * @template TPartial The type of incremental/streaming responses before completion
 * @template TFinal The type of the final, complete response
 * @template TParams The expected parameters for the BAML function
 *
 * @param serverAction The BAML server function to execute
 * @param options Configuration for streaming, callbacks, and error handling
 *
 * @returns A state object for managing the async operation lifecycle
 *
 * @example
 * ```tsx
 * // Non-streaming: Wait for complete response
 * const {
 *   data,           // The complete, final response when ready
 *   isLoading,      // True while waiting for the response
 *   isSuccess,      // True if the operation completed successfully
 *   error,          // Error object if something went wrong
 *   mutate         // Call this to start the operation
 * } = useLLM(extractResume, {
 *   onFinal: (data) => console.log('Processing complete:', data),
 * });
 *
 * // Streaming: Get incremental updates
 * const {
 *   data,           // The complete response once finished
 *   partialData,    // Incremental response chunks as they arrive
 *   isLoading,      // True while the stream is still open
 *   isSuccess,      // True after stream closes successfully
 *   error,          // Error if stream fails or operation errors
 *   mutate         // Call this to start streaming
 * } = useLLM(extractResume, {
 *   stream: true,
 *   onPartial: (chunk) => console.log('Got partial response:', chunk),
 *   onFinal: (data) => console.log('Stream complete:', data),
 * });
 *
 * // Start processing
 * await mutate({
 *   text: "Resume content to analyze",
 *   options: { ... }
 * });
 * ```
 */

/**
 * Base options for configuring the BAML function call.
 * @template TFinal The type of the complete, final response
 */
export interface useLLMBaseOptions<TFinal> {
  /**
   * Called when processing completes successfully.
   * Use this to handle the final result, e.g. updating UI or triggering next steps.
   */
  onFinal?: (data: TFinal) => void;
  /**
   * Called if the operation fails.
   * Use this to handle errors gracefully, e.g. showing error messages or retrying.
   */
  onError?: (error: Error) => void;
}

/**
 * Configuration for streaming mode, which provides incremental updates.
 * Use this when you want to show partial results as they become available.
 *
 * @template TPartial Type of the incremental response chunks
 * @template TFinal Type of the complete, final response
 */
export interface useLLMStreamingOptions<TPartial, TFinal>
  extends useLLMBaseOptions<TFinal> {
  /**
   * Called each time a new chunk of data arrives.
   * Use this to progressively update UI, e.g. showing typing animations
   * or incrementally displaying content.
   */
  onPartial?: (data: TPartial) => void;
  /**
   * Set to true to enable streaming mode.
   * This allows handling partial results before completion.
   */
  stream: true;
}

/**
 * Options interface for non-streaming mode of the useLLM hook.
 * @template TFinal The type of the final response data
 */
export interface useLLMNonStreamingOptions<TFinal>
  extends useLLMBaseOptions<TFinal> {
  /** Must be false or undefined for non-streaming mode */
  stream?: false;
}

/**
 * Union type of all possible options for the useLLM hook.
 * @template TPartial The type of partial/intermediate response data
 * @template TFinal The type of the final response data
 */
export type useLLMOptions<TPartial, TFinal> =
  | useLLMStreamingOptions<TPartial, TFinal>
  | useLLMNonStreamingOptions<TFinal>;

/**
 * Type definition for a streaming server action.
 * @template TPartial The type of partial/intermediate response data
 * @template TFinal The type of the final response data
 * @template TParams Tuple type of function parameters
 */
export type StreamingServerAction<
  TPartial,
  TFinal,
  TParams extends unknown[],
> = (...args: TParams) => Promise<{
  object: ReadableStream<{ partial: TPartial } | { final: TFinal }>;
}>;

/**
 * Type definition for a non-streaming server action.
 * @template TFinal The type of the final response data
 * @template TParams Tuple type of function parameters
 */
export type NonStreamingServerAction<TFinal, TParams extends unknown[]> = (
  ...args: TParams
) => Promise<TFinal>;

/**
 * The complete state and controls for a BAML operation.
 * Contains everything needed to track progress and handle results.
 */
interface BaseReturnType<TFinal, TParams extends unknown[]> {
  /**
   * The complete, final result of the operation.
   * Only available after successful completion (when isSuccess is true).
   * Null during loading or if an error occurred.
   */
  data: TFinal | null;
  /**
   * Error details if the operation failed.
   * Check this when isError is true to handle the failure.
   */
  error: Error | null;
  /**
   * True if the operation failed.
   * Use this to conditionally render error states or retry options.
   */
  isError: boolean;
  /**
   * True while the operation is in progress.
   * Use this to show loading states, spinners, or disable controls.
   */
  isLoading: boolean;
  /**
   * True if the operation completed successfully.
   * Check this before accessing the final data.
   */
  isSuccess: boolean;
  /**
   * The current phase of the operation:
   * - idle: Initial state, ready to start
   * - loading: Operation in progress
   * - success: Completed successfully
   * - error: Failed with an error
   */
  status: "idle" | "loading" | "success" | "error";
  /**
   * Call this function to start the operation.
   * Returns a promise that resolves with the final result or null if it failed.
   */
  mutate: (...args: TParams) => Promise<TFinal | null>;
}

/**
 * Additional state available in streaming mode.
 * Use this to handle incremental updates during processing.
 */
export type StreamingReturnType<
  TPartial,
  TFinal,
  TParams extends unknown[],
> = BaseReturnType<TFinal, TParams> & {
  /**
   * The most recent partial result from the stream.
   * Updates continuously while streaming, showing interim progress.
   * Use this to implement real-time UI updates, typing effects,
   * or progress indicators.
   */
  partialData: TPartial | null;
};

/**
 * Return type for non-streaming mode, extends base return type.
 * @template TFinal The type of the final response data
 * @template TParams Tuple type of function parameters
 */
export type NonStreamingReturnType<
  TFinal,
  TParams extends unknown[],
> = BaseReturnType<TFinal, TParams> & {
  /** Not available in non-streaming mode */
  partialData: never;
};

/**
 * Conditional return type based on the options provided.
 * Returns StreamingReturnType if streaming is enabled, otherwise NonStreamingReturnType.
 */
type useLLMReturn<TPartial, TFinal, TParams extends unknown[], TOptions> =
  TOptions extends useLLMStreamingOptions<TPartial, TFinal>
    ? StreamingReturnType<TPartial, TFinal, TParams>
    : NonStreamingReturnType<TFinal, TParams>;

/**
 * State interface for the LLM reducer.
 * @template TPartial The type of partial/intermediate response data
 * @template TFinal The type of the final response data
 */
interface LLMState<TPartial, TFinal> {
  /** Whether the request is currently loading */
  isLoading: boolean;
  /** Whether the request completed successfully */
  isSuccess: boolean;
  /** Any error that occurred during the operation */
  error: Error | null;
  /** The final result of the operation */
  data: TFinal | null;
  /** The latest partial/intermediate result (only in streaming mode) */
  partialData: TPartial | null;
}

/**
 * Action types for the LLM reducer.
 * @template TPartial The type of partial/intermediate response data
 * @template TFinal The type of the final response data
 */
type LLMAction<TPartial, TFinal> =
  | { type: 'START_REQUEST' }
  | { type: 'SET_ERROR'; payload: Error }
  | { type: 'SET_PARTIAL'; payload: TPartial }
  | { type: 'SET_FINAL'; payload: TFinal }
  | { type: 'RESET' };

/**
 * Reducer function to manage LLM request state.
 * Handles state transitions for loading, success, error, and data updates.
 */
function llmReducer<TPartial, TFinal>(
  state: LLMState<TPartial, TFinal>,
  action: LLMAction<TPartial, TFinal>
): LLMState<TPartial, TFinal> {
  switch (action.type) {
    case 'START_REQUEST':
      return {
        isLoading: true,
        isSuccess: false,
        error: null,
        data: null,
        partialData: null,
      };
    case 'SET_ERROR':
      return {
        ...state,
        isLoading: false,
        error: action.payload,
      };
    case 'SET_PARTIAL':
      return {
        ...state,
        partialData: action.payload,
      };
    case 'SET_FINAL':
      return {
        ...state,
        isLoading: false,
        isSuccess: true,
        data: action.payload,
      };
    case 'RESET':
      return {
        isLoading: false,
        isSuccess: false,
        error: null,
        data: null,
        partialData: null,
      };
    default:
      return state;
  }
}

/**
 * A React hook for making BAML function calls with support for both streaming and non-streaming modes.
 * Provides a unified interface for handling loading states, errors, and data updates.
 *
 * @template TPartial The type of partial/intermediate response data
 * @template TFinal The type of the final response data
 * @template TParams Tuple type of function parameters
 *
 * @param serverAction The server action function to execute
 * @param options Configuration options for the hook
 *
 * @returns An object containing the current state of the operation and a mutate function to trigger it
 *
 * @example
 * ```tsx
 * // Non-streaming usage
 * const {
 *   data,           // The final result (TFinal | null)
 *   isLoading,      // Whether the request is in progress
 *   isSuccess,      // Whether the request completed successfully
 *   error,          // Any error that occurred
 *   mutate         // Function to trigger the request
 * } = useLLM(extractResume, {
 *   onFinal: (data) => console.log('Final:', data),
 * });
 *
 * // Streaming usage
 * const {
 *   data,           // The final result (TFinal | null)
 *   partialData,    // The latest partial result (TPartial | null)
 *   isLoading,      // Whether the request is in progress
 *   isSuccess,      // Whether the request completed successfully
 *   error,          // Any error that occurred
 *   mutate         // Function to trigger the request
 * } = useLLM(extractResume, {
 *   stream: true,
 *   onPartial: (data) => console.log('Partial:', data),
 *   onFinal: (data) => console.log('Final:', data),
 * });
 *
 * // Trigger the request
 * await mutate({ text: "Some text to process" });
 * ```
 */
export function useLLM<TPartial, TFinal, TParams extends unknown[]>(
  serverAction:
    | StreamingServerAction<TPartial, TFinal, TParams>
    | NonStreamingServerAction<TFinal, TParams>,
  options: useLLMOptions<TPartial, TFinal> = {},
): useLLMReturn<TPartial, TFinal, TParams, typeof options> {
  const { onFinal, onError } = options;
  const onPartial = (options as useLLMStreamingOptions<TPartial, TFinal>).onPartial;
  const isStreaming = options.stream === true;

  const [state, dispatch] = useReducer(llmReducer<TPartial, TFinal>, {
    isLoading: false,
    isSuccess: false,
    error: null,
    data: null,
    partialData: null,
  });

  const mutate = useCallback(
    async (...params: TParams): Promise<TFinal | null> => {
      dispatch({ type: 'START_REQUEST' });

      try {
        if (isStreaming) {
          const streamingAction = serverAction as StreamingServerAction<
            TPartial,
            TFinal,
            TParams
          >;
          const response = await streamingAction(...params);
          const stream = response.object;
          const reader = stream.getReader();
          let done = false;

          while (!done) {
            const result = await reader.read();
            done = result.done;

            if (!done && result.value) {
              const value = result.value;
              if ("partial" in value) {
                dispatch({ type: 'SET_PARTIAL', payload: value.partial });
                onPartial?.(value.partial);
              } else if ("final" in value) {
                dispatch({ type: 'SET_FINAL', payload: value.final });
                onFinal?.(value.final);
                return value.final;
              }
            }
          }
          return null;
        }

        const nonStreamingAction = serverAction as NonStreamingServerAction<
          TFinal,
          TParams
        >;
        const response = await nonStreamingAction(...params);
        dispatch({ type: 'SET_FINAL', payload: response });
        onFinal?.(response);
        return response;
      } catch (error_) {
        const error = error_ instanceof Error ? error_ : new Error(String(error_));
        dispatch({ type: 'SET_ERROR', payload: error });
        onError?.(error);
        return null;
      }
    },
    [serverAction, isStreaming, onPartial, onFinal, onError],
  );

  const status = useMemo<"idle" | "loading" | "success" | "error">(() => {
    if (state.isLoading) return "loading";
    if (state.error) return "error";
    if (state.isSuccess) return "success";
    return "idle";
  }, [state.isLoading, state.error, state.isSuccess]);

  const result = {
    data: state.data,
    error: state.error,
    isError: state.error !== null,
    isLoading: state.isLoading,
    isSuccess: state.isSuccess,
    mutate,
    status,
  } as const;

  if (isStreaming) {
    return {
      ...result,
      partialData: state.partialData,
    } as StreamingReturnType<TPartial, TFinal, TParams>;
  }

  return result as NonStreamingReturnType<TFinal, TParams>;
}
/**
 * A specialized hook for the AaaSamOutputFormat BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - recipe: string
 *
 *
 * Return Type:
 * - Non-streaming: Recipe
 * - Streaming Partial: RecursivePartialNull<Recipe>
 * - Streaming Final: Recipe
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAaaSamOutputFormat();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Recipe
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Recipe | null
 *   partialData, // Type: RecursivePartialNull<Recipe> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAaaSamOutputFormat({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Recipe>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Recipe
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       recipe: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       recipe: firstValue as string,
 *     }),
 *     mutate({
 *       recipe: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAaaSamOutputFormat(
    props?: useLLMOptions<RecursivePartialNull<Recipe>, Recipe>
): useLLMReturn<
    RecursivePartialNull<Recipe>,
    Recipe,
    [params: {
        recipe: string
    }],
    typeof props
> {
    return useLLM(AaaSamOutputFormatAction, props);
}

/**
 * A specialized hook for the AliasThatPointsToRecursiveType BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - list: LinkedListAliasNode
 *
 *
 * Return Type:
 * - Non-streaming: LinkedListAliasNode
 * - Streaming Partial: RecursivePartialNull<LinkedListAliasNode>
 * - Streaming Final: LinkedListAliasNode
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAliasThatPointsToRecursiveType();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to LinkedListAliasNode
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: LinkedListAliasNode | null
 *   partialData, // Type: RecursivePartialNull<LinkedListAliasNode> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAliasThatPointsToRecursiveType({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<LinkedListAliasNode>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: LinkedListAliasNode
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       list: someValue as LinkedListAliasNode,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       list: firstValue as LinkedListAliasNode,
 *     }),
 *     mutate({
 *       list: secondValue as LinkedListAliasNode,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAliasThatPointsToRecursiveType(
    props?: useLLMOptions<RecursivePartialNull<LinkedListAliasNode>, LinkedListAliasNode>
): useLLMReturn<
    RecursivePartialNull<LinkedListAliasNode>,
    LinkedListAliasNode,
    [params: {
        list: LinkedListAliasNode
    }],
    typeof props
> {
    return useLLM(AliasThatPointsToRecursiveTypeAction, props);
}

/**
 * A specialized hook for the AliasWithMultipleAttrs BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"gt_ten">
 * - Streaming Partial: RecursivePartialNull<Checked<number,"gt_ten">>
 * - Streaming Final: Checked<number,"gt_ten">
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAliasWithMultipleAttrs();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Checked<number,"gt_ten">
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Checked<number,"gt_ten"> | null
 *   partialData, // Type: RecursivePartialNull<Checked<number,"gt_ten">> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAliasWithMultipleAttrs({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Checked<number,"gt_ten">>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Checked<number,"gt_ten">
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       money: someValue as Checked<number,"gt_ten">,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       money: firstValue as Checked<number,"gt_ten">,
 *     }),
 *     mutate({
 *       money: secondValue as Checked<number,"gt_ten">,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAliasWithMultipleAttrs(
    props?: useLLMOptions<RecursivePartialNull<Checked<number,"gt_ten">>, Checked<number,"gt_ten">>
): useLLMReturn<
    RecursivePartialNull<Checked<number,"gt_ten">>,
    Checked<number,"gt_ten">,
    [params: {
        money: Checked<number,"gt_ten">
    }],
    typeof props
> {
    return useLLM(AliasWithMultipleAttrsAction, props);
}

/**
 * A specialized hook for the AliasedInputClass BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: InputClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAliasedInputClass();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAliasedInputClass({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as InputClass,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as InputClass,
 *     }),
 *     mutate({
 *       input: secondValue as InputClass,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAliasedInputClass(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: InputClass
    }],
    typeof props
> {
    return useLLM(AliasedInputClassAction, props);
}

/**
 * A specialized hook for the AliasedInputClass2 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: InputClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAliasedInputClass2();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAliasedInputClass2({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as InputClass,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as InputClass,
 *     }),
 *     mutate({
 *       input: secondValue as InputClass,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAliasedInputClass2(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: InputClass
    }],
    typeof props
> {
    return useLLM(AliasedInputClass2Action, props);
}

/**
 * A specialized hook for the AliasedInputClassNested BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: InputClassNested
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAliasedInputClassNested();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAliasedInputClassNested({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as InputClassNested,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as InputClassNested,
 *     }),
 *     mutate({
 *       input: secondValue as InputClassNested,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAliasedInputClassNested(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: InputClassNested
    }],
    typeof props
> {
    return useLLM(AliasedInputClassNestedAction, props);
}

/**
 * A specialized hook for the AliasedInputEnum BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: AliasedEnum
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAliasedInputEnum();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAliasedInputEnum({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as AliasedEnum,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as AliasedEnum,
 *     }),
 *     mutate({
 *       input: secondValue as AliasedEnum,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAliasedInputEnum(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: AliasedEnum
    }],
    typeof props
> {
    return useLLM(AliasedInputEnumAction, props);
}

/**
 * A specialized hook for the AliasedInputList BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: AliasedEnum[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAliasedInputList();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAliasedInputList({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as AliasedEnum[],  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as AliasedEnum[],
 *     }),
 *     mutate({
 *       input: secondValue as AliasedEnum[],
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAliasedInputList(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: AliasedEnum[]
    }],
    typeof props
> {
    return useLLM(AliasedInputListAction, props);
}

/**
 * A specialized hook for the AllowedOptionals BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - optionals: OptionalListAndMap
 *
 *
 * Return Type:
 * - Non-streaming: OptionalListAndMap
 * - Streaming Partial: RecursivePartialNull<OptionalListAndMap>
 * - Streaming Final: OptionalListAndMap
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAllowedOptionals();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to OptionalListAndMap
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: OptionalListAndMap | null
 *   partialData, // Type: RecursivePartialNull<OptionalListAndMap> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAllowedOptionals({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<OptionalListAndMap>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: OptionalListAndMap
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       optionals: someValue as OptionalListAndMap,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       optionals: firstValue as OptionalListAndMap,
 *     }),
 *     mutate({
 *       optionals: secondValue as OptionalListAndMap,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAllowedOptionals(
    props?: useLLMOptions<RecursivePartialNull<OptionalListAndMap>, OptionalListAndMap>
): useLLMReturn<
    RecursivePartialNull<OptionalListAndMap>,
    OptionalListAndMap,
    [params: {
        optionals: OptionalListAndMap
    }],
    typeof props
> {
    return useLLM(AllowedOptionalsAction, props);
}

/**
 * A specialized hook for the AudioInput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - aud: Audio
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useAudioInput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useAudioInput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       aud: someValue as Audio,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       aud: firstValue as Audio,
 *     }),
 *     mutate({
 *       aud: secondValue as Audio,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useAudioInput(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        aud: Audio
    }],
    typeof props
> {
    return useLLM(AudioInputAction, props);
}

/**
 * A specialized hook for the BuildLinkedList BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: number[]
 *
 *
 * Return Type:
 * - Non-streaming: LinkedList
 * - Streaming Partial: RecursivePartialNull<LinkedList>
 * - Streaming Final: LinkedList
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useBuildLinkedList();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to LinkedList
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: LinkedList | null
 *   partialData, // Type: RecursivePartialNull<LinkedList> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useBuildLinkedList({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<LinkedList>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: LinkedList
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as number[],  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as number[],
 *     }),
 *     mutate({
 *       input: secondValue as number[],
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useBuildLinkedList(
    props?: useLLMOptions<RecursivePartialNull<LinkedList>, LinkedList>
): useLLMReturn<
    RecursivePartialNull<LinkedList>,
    LinkedList,
    [params: {
        input: number[]
    }],
    typeof props
> {
    return useLLM(BuildLinkedListAction, props);
}

/**
 * A specialized hook for the BuildTree BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: BinaryNode
 *
 *
 * Return Type:
 * - Non-streaming: Tree
 * - Streaming Partial: RecursivePartialNull<Tree>
 * - Streaming Final: Tree
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useBuildTree();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Tree
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Tree | null
 *   partialData, // Type: RecursivePartialNull<Tree> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useBuildTree({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Tree>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Tree
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as BinaryNode,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as BinaryNode,
 *     }),
 *     mutate({
 *       input: secondValue as BinaryNode,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useBuildTree(
    props?: useLLMOptions<RecursivePartialNull<Tree>, Tree>
): useLLMReturn<
    RecursivePartialNull<Tree>,
    Tree,
    [params: {
        input: BinaryNode
    }],
    typeof props
> {
    return useLLM(BuildTreeAction, props);
}

/**
 * A specialized hook for the ClassThatPointsToRecursiveClassThroughAlias BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - cls: ClassToRecAlias
 *
 *
 * Return Type:
 * - Non-streaming: ClassToRecAlias
 * - Streaming Partial: RecursivePartialNull<ClassToRecAlias>
 * - Streaming Final: ClassToRecAlias
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useClassThatPointsToRecursiveClassThroughAlias();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to ClassToRecAlias
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: ClassToRecAlias | null
 *   partialData, // Type: RecursivePartialNull<ClassToRecAlias> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useClassThatPointsToRecursiveClassThroughAlias({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<ClassToRecAlias>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: ClassToRecAlias
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       cls: someValue as ClassToRecAlias,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       cls: firstValue as ClassToRecAlias,
 *     }),
 *     mutate({
 *       cls: secondValue as ClassToRecAlias,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useClassThatPointsToRecursiveClassThroughAlias(
    props?: useLLMOptions<RecursivePartialNull<ClassToRecAlias>, ClassToRecAlias>
): useLLMReturn<
    RecursivePartialNull<ClassToRecAlias>,
    ClassToRecAlias,
    [params: {
        cls: ClassToRecAlias
    }],
    typeof props
> {
    return useLLM(ClassThatPointsToRecursiveClassThroughAliasAction, props);
}

/**
 * A specialized hook for the ClassifyDynEnumTwo BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: (string | DynEnumTwo)
 * - Streaming Partial: RecursivePartialNull<(string | DynEnumTwo)>
 * - Streaming Final: (string | DynEnumTwo)
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useClassifyDynEnumTwo();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to (string | DynEnumTwo)
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: (string | DynEnumTwo) | null
 *   partialData, // Type: RecursivePartialNull<(string | DynEnumTwo)> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useClassifyDynEnumTwo({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<(string | DynEnumTwo)>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: (string | DynEnumTwo)
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useClassifyDynEnumTwo(
    props?: useLLMOptions<RecursivePartialNull<(string | DynEnumTwo)>, (string | DynEnumTwo)>
): useLLMReturn<
    RecursivePartialNull<(string | DynEnumTwo)>,
    (string | DynEnumTwo),
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(ClassifyDynEnumTwoAction, props);
}

/**
 * A specialized hook for the ClassifyMessage BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming Partial: RecursivePartialNull<Category>
 * - Streaming Final: Category
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useClassifyMessage();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Category
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Category | null
 *   partialData, // Type: RecursivePartialNull<Category> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useClassifyMessage({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Category>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Category
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useClassifyMessage(
    props?: useLLMOptions<RecursivePartialNull<Category>, Category>
): useLLMReturn<
    RecursivePartialNull<Category>,
    Category,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(ClassifyMessageAction, props);
}

/**
 * A specialized hook for the ClassifyMessage2 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming Partial: RecursivePartialNull<Category>
 * - Streaming Final: Category
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useClassifyMessage2();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Category
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Category | null
 *   partialData, // Type: RecursivePartialNull<Category> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useClassifyMessage2({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Category>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Category
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useClassifyMessage2(
    props?: useLLMOptions<RecursivePartialNull<Category>, Category>
): useLLMReturn<
    RecursivePartialNull<Category>,
    Category,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(ClassifyMessage2Action, props);
}

/**
 * A specialized hook for the ClassifyMessage3 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Category
 * - Streaming Partial: RecursivePartialNull<Category>
 * - Streaming Final: Category
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useClassifyMessage3();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Category
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Category | null
 *   partialData, // Type: RecursivePartialNull<Category> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useClassifyMessage3({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Category>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Category
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useClassifyMessage3(
    props?: useLLMOptions<RecursivePartialNull<Category>, Category>
): useLLMReturn<
    RecursivePartialNull<Category>,
    Category,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(ClassifyMessage3Action, props);
}

/**
 * A specialized hook for the Completion BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - prefix: string
 *
 * - suffix: string
 *
 * - language: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useCompletion();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useCompletion({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       prefix: someValue as string,  // Replace someValue with your data
 *       suffix: someValue as string,  // Replace someValue with your data
 *       language: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       prefix: firstValue as string,
 *       suffix: firstValue as string,
 *       language: firstValue as string,
 *     }),
 *     mutate({
 *       prefix: secondValue as string,
 *       suffix: secondValue as string,
 *       language: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useCompletion(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        prefix: string,
        suffix: string,
        language: string
    }],
    typeof props
> {
    return useLLM(CompletionAction, props);
}

/**
 * A specialized hook for the CustomTask BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: BookOrder | FlightConfirmation | GroceryReceipt
 * - Streaming Partial: RecursivePartialNull<BookOrder | FlightConfirmation | GroceryReceipt>
 * - Streaming Final: BookOrder | FlightConfirmation | GroceryReceipt
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useCustomTask();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to BookOrder | FlightConfirmation | GroceryReceipt
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: BookOrder | FlightConfirmation | GroceryReceipt | null
 *   partialData, // Type: RecursivePartialNull<BookOrder | FlightConfirmation | GroceryReceipt> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useCustomTask({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<BookOrder | FlightConfirmation | GroceryReceipt>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: BookOrder | FlightConfirmation | GroceryReceipt
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useCustomTask(
    props?: useLLMOptions<RecursivePartialNull<BookOrder | FlightConfirmation | GroceryReceipt>, BookOrder | FlightConfirmation | GroceryReceipt>
): useLLMReturn<
    RecursivePartialNull<BookOrder | FlightConfirmation | GroceryReceipt>,
    BookOrder | FlightConfirmation | GroceryReceipt,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(CustomTaskAction, props);
}

/**
 * A specialized hook for the DescribeImage BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDescribeImage();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDescribeImage({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       img: someValue as Image,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       img: firstValue as Image,
 *     }),
 *     mutate({
 *       img: secondValue as Image,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDescribeImage(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        img: Image
    }],
    typeof props
> {
    return useLLM(DescribeImageAction, props);
}

/**
 * A specialized hook for the DescribeImage2 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDescribeImage2();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDescribeImage2({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       classWithImage: someValue as ClassWithImage,  // Replace someValue with your data
 *       img2: someValue as Image,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       classWithImage: firstValue as ClassWithImage,
 *       img2: firstValue as Image,
 *     }),
 *     mutate({
 *       classWithImage: secondValue as ClassWithImage,
 *       img2: secondValue as Image,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDescribeImage2(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        classWithImage: ClassWithImage,
        img2: Image
    }],
    typeof props
> {
    return useLLM(DescribeImage2Action, props);
}

/**
 * A specialized hook for the DescribeImage3 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDescribeImage3();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDescribeImage3({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       classWithImage: someValue as ClassWithImage,  // Replace someValue with your data
 *       img2: someValue as Image,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       classWithImage: firstValue as ClassWithImage,
 *       img2: firstValue as Image,
 *     }),
 *     mutate({
 *       classWithImage: secondValue as ClassWithImage,
 *       img2: secondValue as Image,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDescribeImage3(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        classWithImage: ClassWithImage,
        img2: Image
    }],
    typeof props
> {
    return useLLM(DescribeImage3Action, props);
}

/**
 * A specialized hook for the DescribeImage4 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDescribeImage4();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDescribeImage4({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       classWithImage: someValue as ClassWithImage,  // Replace someValue with your data
 *       img2: someValue as Image,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       classWithImage: firstValue as ClassWithImage,
 *       img2: firstValue as Image,
 *     }),
 *     mutate({
 *       classWithImage: secondValue as ClassWithImage,
 *       img2: secondValue as Image,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDescribeImage4(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        classWithImage: ClassWithImage,
        img2: Image
    }],
    typeof props
> {
    return useLLM(DescribeImage4Action, props);
}

/**
 * A specialized hook for the DifferentiateUnions BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: OriginalA | OriginalB
 * - Streaming Partial: RecursivePartialNull<OriginalA | OriginalB>
 * - Streaming Final: OriginalA | OriginalB
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDifferentiateUnions();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to OriginalA | OriginalB
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: OriginalA | OriginalB | null
 *   partialData, // Type: RecursivePartialNull<OriginalA | OriginalB> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDifferentiateUnions({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<OriginalA | OriginalB>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: OriginalA | OriginalB
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDifferentiateUnions(
    props?: useLLMOptions<RecursivePartialNull<OriginalA | OriginalB>, OriginalA | OriginalB>
): useLLMReturn<
    RecursivePartialNull<OriginalA | OriginalB>,
    OriginalA | OriginalB,
    [params: {
    }],
    typeof props
> {
    return useLLM(DifferentiateUnionsAction, props);
}

/**
 * A specialized hook for the DummyOutputFunction BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: DummyOutput
 * - Streaming Partial: RecursivePartialNull<DummyOutput>
 * - Streaming Final: DummyOutput
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDummyOutputFunction();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to DummyOutput
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: DummyOutput | null
 *   partialData, // Type: RecursivePartialNull<DummyOutput> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDummyOutputFunction({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<DummyOutput>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: DummyOutput
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDummyOutputFunction(
    props?: useLLMOptions<RecursivePartialNull<DummyOutput>, DummyOutput>
): useLLMReturn<
    RecursivePartialNull<DummyOutput>,
    DummyOutput,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(DummyOutputFunctionAction, props);
}

/**
 * A specialized hook for the DynamicFunc BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: DynamicClassOne
 *
 *
 * Return Type:
 * - Non-streaming: DynamicClassTwo
 * - Streaming Partial: RecursivePartialNull<DynamicClassTwo>
 * - Streaming Final: DynamicClassTwo
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDynamicFunc();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to DynamicClassTwo
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: DynamicClassTwo | null
 *   partialData, // Type: RecursivePartialNull<DynamicClassTwo> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDynamicFunc({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<DynamicClassTwo>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: DynamicClassTwo
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as DynamicClassOne,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as DynamicClassOne,
 *     }),
 *     mutate({
 *       input: secondValue as DynamicClassOne,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDynamicFunc(
    props?: useLLMOptions<RecursivePartialNull<DynamicClassTwo>, DynamicClassTwo>
): useLLMReturn<
    RecursivePartialNull<DynamicClassTwo>,
    DynamicClassTwo,
    [params: {
        input: DynamicClassOne
    }],
    typeof props
> {
    return useLLM(DynamicFuncAction, props);
}

/**
 * A specialized hook for the DynamicInputOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: DynInputOutput
 *
 *
 * Return Type:
 * - Non-streaming: DynInputOutput
 * - Streaming Partial: RecursivePartialNull<DynInputOutput>
 * - Streaming Final: DynInputOutput
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDynamicInputOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to DynInputOutput
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: DynInputOutput | null
 *   partialData, // Type: RecursivePartialNull<DynInputOutput> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDynamicInputOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<DynInputOutput>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: DynInputOutput
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as DynInputOutput,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as DynInputOutput,
 *     }),
 *     mutate({
 *       input: secondValue as DynInputOutput,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDynamicInputOutput(
    props?: useLLMOptions<RecursivePartialNull<DynInputOutput>, DynInputOutput>
): useLLMReturn<
    RecursivePartialNull<DynInputOutput>,
    DynInputOutput,
    [params: {
        input: DynInputOutput
    }],
    typeof props
> {
    return useLLM(DynamicInputOutputAction, props);
}

/**
 * A specialized hook for the DynamicListInputOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: DynInputOutput[]
 *
 *
 * Return Type:
 * - Non-streaming: DynInputOutput[]
 * - Streaming Partial: RecursivePartialNull<DynInputOutput[]>
 * - Streaming Final: DynInputOutput[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useDynamicListInputOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to DynInputOutput[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: DynInputOutput[] | null
 *   partialData, // Type: RecursivePartialNull<DynInputOutput[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useDynamicListInputOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<DynInputOutput[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: DynInputOutput[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as DynInputOutput[],  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as DynInputOutput[],
 *     }),
 *     mutate({
 *       input: secondValue as DynInputOutput[],
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useDynamicListInputOutput(
    props?: useLLMOptions<RecursivePartialNull<DynInputOutput[]>, DynInputOutput[]>
): useLLMReturn<
    RecursivePartialNull<DynInputOutput[]>,
    DynInputOutput[],
    [params: {
        input: DynInputOutput[]
    }],
    typeof props
> {
    return useLLM(DynamicListInputOutputAction, props);
}

/**
 * A specialized hook for the ExpectFailure BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExpectFailure();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExpectFailure({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExpectFailure(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
    }],
    typeof props
> {
    return useLLM(ExpectFailureAction, props);
}

/**
 * A specialized hook for the ExtractContactInfo BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - document: string
 *
 *
 * Return Type:
 * - Non-streaming: ContactInfo
 * - Streaming Partial: RecursivePartialNull<ContactInfo>
 * - Streaming Final: ContactInfo
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExtractContactInfo();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to ContactInfo
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: ContactInfo | null
 *   partialData, // Type: RecursivePartialNull<ContactInfo> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExtractContactInfo({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<ContactInfo>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: ContactInfo
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       document: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       document: firstValue as string,
 *     }),
 *     mutate({
 *       document: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExtractContactInfo(
    props?: useLLMOptions<RecursivePartialNull<ContactInfo>, ContactInfo>
): useLLMReturn<
    RecursivePartialNull<ContactInfo>,
    ContactInfo,
    [params: {
        document: string
    }],
    typeof props
> {
    return useLLM(ExtractContactInfoAction, props);
}

/**
 * A specialized hook for the ExtractHobby BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: (string | Hobby)[]
 * - Streaming Partial: RecursivePartialNull<(string | Hobby)[]>
 * - Streaming Final: (string | Hobby)[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExtractHobby();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to (string | Hobby)[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: (string | Hobby)[] | null
 *   partialData, // Type: RecursivePartialNull<(string | Hobby)[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExtractHobby({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<(string | Hobby)[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: (string | Hobby)[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       text: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       text: firstValue as string,
 *     }),
 *     mutate({
 *       text: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExtractHobby(
    props?: useLLMOptions<RecursivePartialNull<(string | Hobby)[]>, (string | Hobby)[]>
): useLLMReturn<
    RecursivePartialNull<(string | Hobby)[]>,
    (string | Hobby)[],
    [params: {
        text: string
    }],
    typeof props
> {
    return useLLM(ExtractHobbyAction, props);
}

/**
 * A specialized hook for the ExtractNames BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string[]
 * - Streaming Partial: RecursivePartialNull<string[]>
 * - Streaming Final: string[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExtractNames();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string[] | null
 *   partialData, // Type: RecursivePartialNull<string[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExtractNames({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExtractNames(
    props?: useLLMOptions<RecursivePartialNull<string[]>, string[]>
): useLLMReturn<
    RecursivePartialNull<string[]>,
    string[],
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(ExtractNamesAction, props);
}

/**
 * A specialized hook for the ExtractPeople BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: Person[]
 * - Streaming Partial: RecursivePartialNull<Person[]>
 * - Streaming Final: Person[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExtractPeople();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Person[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Person[] | null
 *   partialData, // Type: RecursivePartialNull<Person[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExtractPeople({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Person[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Person[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       text: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       text: firstValue as string,
 *     }),
 *     mutate({
 *       text: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExtractPeople(
    props?: useLLMOptions<RecursivePartialNull<Person[]>, Person[]>
): useLLMReturn<
    RecursivePartialNull<Person[]>,
    Person[],
    [params: {
        text: string
    }],
    typeof props
> {
    return useLLM(ExtractPeopleAction, props);
}

/**
 * A specialized hook for the ExtractReceiptInfo BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - email: string
 *
 * - reason: "curiosity" | "personal_finance"
 *
 *
 * Return Type:
 * - Non-streaming: ReceiptInfo
 * - Streaming Partial: RecursivePartialNull<ReceiptInfo>
 * - Streaming Final: ReceiptInfo
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExtractReceiptInfo();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to ReceiptInfo
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: ReceiptInfo | null
 *   partialData, // Type: RecursivePartialNull<ReceiptInfo> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExtractReceiptInfo({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<ReceiptInfo>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: ReceiptInfo
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       email: someValue as string,  // Replace someValue with your data
 *       reason: someValue as "curiosity" | "personal_finance",  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       email: firstValue as string,
 *       reason: firstValue as "curiosity" | "personal_finance",
 *     }),
 *     mutate({
 *       email: secondValue as string,
 *       reason: secondValue as "curiosity" | "personal_finance",
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExtractReceiptInfo(
    props?: useLLMOptions<RecursivePartialNull<ReceiptInfo>, ReceiptInfo>
): useLLMReturn<
    RecursivePartialNull<ReceiptInfo>,
    ReceiptInfo,
    [params: {
        email: string,
        reason: "curiosity" | "personal_finance"
    }],
    typeof props
> {
    return useLLM(ExtractReceiptInfoAction, props);
}

/**
 * A specialized hook for the ExtractResume BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - resume: string
 *
 * - img (optional): Image | null
 *
 *
 * Return Type:
 * - Non-streaming: Resume
 * - Streaming Partial: RecursivePartialNull<Resume>
 * - Streaming Final: Resume
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExtractResume();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Resume
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Resume | null
 *   partialData, // Type: RecursivePartialNull<Resume> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExtractResume({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Resume>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Resume
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       resume: someValue as string,  // Replace someValue with your data
 *       img: someValue as Image | null,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       resume: firstValue as string,
 *       img: firstValue as Image | null,
 *     }),
 *     mutate({
 *       resume: secondValue as string,
 *       img: secondValue as Image | null,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExtractResume(
    props?: useLLMOptions<RecursivePartialNull<Resume>, Resume>
): useLLMReturn<
    RecursivePartialNull<Resume>,
    Resume,
    [params: {
        resume: string,
        img?: Image | null
    }],
    typeof props
> {
    return useLLM(ExtractResumeAction, props);
}

/**
 * A specialized hook for the ExtractResume2 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - resume: string
 *
 *
 * Return Type:
 * - Non-streaming: Resume
 * - Streaming Partial: RecursivePartialNull<Resume>
 * - Streaming Final: Resume
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useExtractResume2();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Resume
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Resume | null
 *   partialData, // Type: RecursivePartialNull<Resume> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useExtractResume2({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Resume>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Resume
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       resume: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       resume: firstValue as string,
 *     }),
 *     mutate({
 *       resume: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useExtractResume2(
    props?: useLLMOptions<RecursivePartialNull<Resume>, Resume>
): useLLMReturn<
    RecursivePartialNull<Resume>,
    Resume,
    [params: {
        resume: string
    }],
    typeof props
> {
    return useLLM(ExtractResume2Action, props);
}

/**
 * A specialized hook for the FnClassOptionalOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: ClassOptionalOutput | null
 * - Streaming Partial: RecursivePartialNull<ClassOptionalOutput | null>
 * - Streaming Final: ClassOptionalOutput | null
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnClassOptionalOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to ClassOptionalOutput | null
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: ClassOptionalOutput | null | null
 *   partialData, // Type: RecursivePartialNull<ClassOptionalOutput | null> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnClassOptionalOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<ClassOptionalOutput | null>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: ClassOptionalOutput | null
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnClassOptionalOutput(
    props?: useLLMOptions<RecursivePartialNull<ClassOptionalOutput | null>, ClassOptionalOutput | null>
): useLLMReturn<
    RecursivePartialNull<ClassOptionalOutput | null>,
    ClassOptionalOutput | null,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnClassOptionalOutputAction, props);
}

/**
 * A specialized hook for the FnClassOptionalOutput2 BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: ClassOptionalOutput2 | null
 * - Streaming Partial: RecursivePartialNull<ClassOptionalOutput2 | null>
 * - Streaming Final: ClassOptionalOutput2 | null
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnClassOptionalOutput2();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to ClassOptionalOutput2 | null
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: ClassOptionalOutput2 | null | null
 *   partialData, // Type: RecursivePartialNull<ClassOptionalOutput2 | null> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnClassOptionalOutput2({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<ClassOptionalOutput2 | null>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: ClassOptionalOutput2 | null
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnClassOptionalOutput2(
    props?: useLLMOptions<RecursivePartialNull<ClassOptionalOutput2 | null>, ClassOptionalOutput2 | null>
): useLLMReturn<
    RecursivePartialNull<ClassOptionalOutput2 | null>,
    ClassOptionalOutput2 | null,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnClassOptionalOutput2Action, props);
}

/**
 * A specialized hook for the FnEnumListOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: EnumOutput[]
 * - Streaming Partial: RecursivePartialNull<EnumOutput[]>
 * - Streaming Final: EnumOutput[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnEnumListOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to EnumOutput[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: EnumOutput[] | null
 *   partialData, // Type: RecursivePartialNull<EnumOutput[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnEnumListOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<EnumOutput[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: EnumOutput[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnEnumListOutput(
    props?: useLLMOptions<RecursivePartialNull<EnumOutput[]>, EnumOutput[]>
): useLLMReturn<
    RecursivePartialNull<EnumOutput[]>,
    EnumOutput[],
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnEnumListOutputAction, props);
}

/**
 * A specialized hook for the FnEnumOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: EnumOutput
 * - Streaming Partial: RecursivePartialNull<EnumOutput>
 * - Streaming Final: EnumOutput
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnEnumOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to EnumOutput
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: EnumOutput | null
 *   partialData, // Type: RecursivePartialNull<EnumOutput> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnEnumOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<EnumOutput>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: EnumOutput
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnEnumOutput(
    props?: useLLMOptions<RecursivePartialNull<EnumOutput>, EnumOutput>
): useLLMReturn<
    RecursivePartialNull<EnumOutput>,
    EnumOutput,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnEnumOutputAction, props);
}

/**
 * A specialized hook for the FnLiteralClassInputOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: LiteralClassHello
 *
 *
 * Return Type:
 * - Non-streaming: LiteralClassHello
 * - Streaming Partial: RecursivePartialNull<LiteralClassHello>
 * - Streaming Final: LiteralClassHello
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnLiteralClassInputOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to LiteralClassHello
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: LiteralClassHello | null
 *   partialData, // Type: RecursivePartialNull<LiteralClassHello> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnLiteralClassInputOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<LiteralClassHello>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: LiteralClassHello
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as LiteralClassHello,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as LiteralClassHello,
 *     }),
 *     mutate({
 *       input: secondValue as LiteralClassHello,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnLiteralClassInputOutput(
    props?: useLLMOptions<RecursivePartialNull<LiteralClassHello>, LiteralClassHello>
): useLLMReturn<
    RecursivePartialNull<LiteralClassHello>,
    LiteralClassHello,
    [params: {
        input: LiteralClassHello
    }],
    typeof props
> {
    return useLLM(FnLiteralClassInputOutputAction, props);
}

/**
 * A specialized hook for the FnLiteralUnionClassInputOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: LiteralClassOne | LiteralClassTwo
 *
 *
 * Return Type:
 * - Non-streaming: LiteralClassOne | LiteralClassTwo
 * - Streaming Partial: RecursivePartialNull<LiteralClassOne | LiteralClassTwo>
 * - Streaming Final: LiteralClassOne | LiteralClassTwo
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnLiteralUnionClassInputOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to LiteralClassOne | LiteralClassTwo
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: LiteralClassOne | LiteralClassTwo | null
 *   partialData, // Type: RecursivePartialNull<LiteralClassOne | LiteralClassTwo> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnLiteralUnionClassInputOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<LiteralClassOne | LiteralClassTwo>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: LiteralClassOne | LiteralClassTwo
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as LiteralClassOne | LiteralClassTwo,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as LiteralClassOne | LiteralClassTwo,
 *     }),
 *     mutate({
 *       input: secondValue as LiteralClassOne | LiteralClassTwo,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnLiteralUnionClassInputOutput(
    props?: useLLMOptions<RecursivePartialNull<LiteralClassOne | LiteralClassTwo>, LiteralClassOne | LiteralClassTwo>
): useLLMReturn<
    RecursivePartialNull<LiteralClassOne | LiteralClassTwo>,
    LiteralClassOne | LiteralClassTwo,
    [params: {
        input: LiteralClassOne | LiteralClassTwo
    }],
    typeof props
> {
    return useLLM(FnLiteralUnionClassInputOutputAction, props);
}

/**
 * A specialized hook for the FnNamedArgsSingleStringOptional BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myString (optional): string | null
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnNamedArgsSingleStringOptional();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnNamedArgsSingleStringOptional({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myString: someValue as string | null,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myString: firstValue as string | null,
 *     }),
 *     mutate({
 *       myString: secondValue as string | null,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnNamedArgsSingleStringOptional(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myString?: string | null
    }],
    typeof props
> {
    return useLLM(FnNamedArgsSingleStringOptionalAction, props);
}

/**
 * A specialized hook for the FnOutputBool BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: boolean
 * - Streaming Partial: RecursivePartialNull<boolean>
 * - Streaming Final: boolean
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputBool();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to boolean
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: boolean | null
 *   partialData, // Type: RecursivePartialNull<boolean> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputBool({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<boolean>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: boolean
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputBool(
    props?: useLLMOptions<RecursivePartialNull<boolean>, boolean>
): useLLMReturn<
    RecursivePartialNull<boolean>,
    boolean,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputBoolAction, props);
}

/**
 * A specialized hook for the FnOutputClass BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestOutputClass
 * - Streaming Partial: RecursivePartialNull<TestOutputClass>
 * - Streaming Final: TestOutputClass
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputClass();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to TestOutputClass
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: TestOutputClass | null
 *   partialData, // Type: RecursivePartialNull<TestOutputClass> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputClass({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<TestOutputClass>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: TestOutputClass
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputClass(
    props?: useLLMOptions<RecursivePartialNull<TestOutputClass>, TestOutputClass>
): useLLMReturn<
    RecursivePartialNull<TestOutputClass>,
    TestOutputClass,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputClassAction, props);
}

/**
 * A specialized hook for the FnOutputClassList BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestOutputClass[]
 * - Streaming Partial: RecursivePartialNull<TestOutputClass[]>
 * - Streaming Final: TestOutputClass[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputClassList();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to TestOutputClass[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: TestOutputClass[] | null
 *   partialData, // Type: RecursivePartialNull<TestOutputClass[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputClassList({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<TestOutputClass[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: TestOutputClass[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputClassList(
    props?: useLLMOptions<RecursivePartialNull<TestOutputClass[]>, TestOutputClass[]>
): useLLMReturn<
    RecursivePartialNull<TestOutputClass[]>,
    TestOutputClass[],
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputClassListAction, props);
}

/**
 * A specialized hook for the FnOutputClassNested BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassNested
 * - Streaming Partial: RecursivePartialNull<TestClassNested>
 * - Streaming Final: TestClassNested
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputClassNested();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to TestClassNested
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: TestClassNested | null
 *   partialData, // Type: RecursivePartialNull<TestClassNested> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputClassNested({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<TestClassNested>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: TestClassNested
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputClassNested(
    props?: useLLMOptions<RecursivePartialNull<TestClassNested>, TestClassNested>
): useLLMReturn<
    RecursivePartialNull<TestClassNested>,
    TestClassNested,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputClassNestedAction, props);
}

/**
 * A specialized hook for the FnOutputClassWithEnum BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassWithEnum
 * - Streaming Partial: RecursivePartialNull<TestClassWithEnum>
 * - Streaming Final: TestClassWithEnum
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputClassWithEnum();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to TestClassWithEnum
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: TestClassWithEnum | null
 *   partialData, // Type: RecursivePartialNull<TestClassWithEnum> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputClassWithEnum({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<TestClassWithEnum>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: TestClassWithEnum
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputClassWithEnum(
    props?: useLLMOptions<RecursivePartialNull<TestClassWithEnum>, TestClassWithEnum>
): useLLMReturn<
    RecursivePartialNull<TestClassWithEnum>,
    TestClassWithEnum,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputClassWithEnumAction, props);
}

/**
 * A specialized hook for the FnOutputInt BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming Partial: RecursivePartialNull<number>
 * - Streaming Final: number
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputInt();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | null
 *   partialData, // Type: RecursivePartialNull<number> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputInt({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputInt(
    props?: useLLMOptions<RecursivePartialNull<number>, number>
): useLLMReturn<
    RecursivePartialNull<number>,
    number,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputIntAction, props);
}

/**
 * A specialized hook for the FnOutputLiteralBool BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: false
 * - Streaming Partial: RecursivePartialNull<false>
 * - Streaming Final: false
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputLiteralBool();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to false
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: false | null
 *   partialData, // Type: RecursivePartialNull<false> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputLiteralBool({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<false>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: false
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputLiteralBool(
    props?: useLLMOptions<RecursivePartialNull<false>, false>
): useLLMReturn<
    RecursivePartialNull<false>,
    false,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputLiteralBoolAction, props);
}

/**
 * A specialized hook for the FnOutputLiteralInt BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: 5
 * - Streaming Partial: RecursivePartialNull<5>
 * - Streaming Final: 5
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputLiteralInt();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to 5
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: 5 | null
 *   partialData, // Type: RecursivePartialNull<5> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputLiteralInt({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<5>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: 5
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputLiteralInt(
    props?: useLLMOptions<RecursivePartialNull<5>, 5>
): useLLMReturn<
    RecursivePartialNull<5>,
    5,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputLiteralIntAction, props);
}

/**
 * A specialized hook for the FnOutputLiteralString BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: "example output"
 * - Streaming Partial: RecursivePartialNull<"example output">
 * - Streaming Final: "example output"
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputLiteralString();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to "example output"
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: "example output" | null
 *   partialData, // Type: RecursivePartialNull<"example output"> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputLiteralString({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<"example output">
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: "example output"
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputLiteralString(
    props?: useLLMOptions<RecursivePartialNull<"example output">, "example output">
): useLLMReturn<
    RecursivePartialNull<"example output">,
    "example output",
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputLiteralStringAction, props);
}

/**
 * A specialized hook for the FnOutputStringList BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string[]
 * - Streaming Partial: RecursivePartialNull<string[]>
 * - Streaming Final: string[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnOutputStringList();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string[] | null
 *   partialData, // Type: RecursivePartialNull<string[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnOutputStringList({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnOutputStringList(
    props?: useLLMOptions<RecursivePartialNull<string[]>, string[]>
): useLLMReturn<
    RecursivePartialNull<string[]>,
    string[],
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnOutputStringListAction, props);
}

/**
 * A specialized hook for the FnTestAliasedEnumOutput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestEnum
 * - Streaming Partial: RecursivePartialNull<TestEnum>
 * - Streaming Final: TestEnum
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnTestAliasedEnumOutput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to TestEnum
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: TestEnum | null
 *   partialData, // Type: RecursivePartialNull<TestEnum> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnTestAliasedEnumOutput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<TestEnum>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: TestEnum
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnTestAliasedEnumOutput(
    props?: useLLMOptions<RecursivePartialNull<TestEnum>, TestEnum>
): useLLMReturn<
    RecursivePartialNull<TestEnum>,
    TestEnum,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnTestAliasedEnumOutputAction, props);
}

/**
 * A specialized hook for the FnTestClassAlias BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: TestClassAlias
 * - Streaming Partial: RecursivePartialNull<TestClassAlias>
 * - Streaming Final: TestClassAlias
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnTestClassAlias();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to TestClassAlias
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: TestClassAlias | null
 *   partialData, // Type: RecursivePartialNull<TestClassAlias> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnTestClassAlias({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<TestClassAlias>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: TestClassAlias
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnTestClassAlias(
    props?: useLLMOptions<RecursivePartialNull<TestClassAlias>, TestClassAlias>
): useLLMReturn<
    RecursivePartialNull<TestClassAlias>,
    TestClassAlias,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(FnTestClassAliasAction, props);
}

/**
 * A specialized hook for the FnTestNamedArgsSingleEnum BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleEnum
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useFnTestNamedArgsSingleEnum();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useFnTestNamedArgsSingleEnum({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myArg: someValue as NamedArgsSingleEnum,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myArg: firstValue as NamedArgsSingleEnum,
 *     }),
 *     mutate({
 *       myArg: secondValue as NamedArgsSingleEnum,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useFnTestNamedArgsSingleEnum(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myArg: NamedArgsSingleEnum
    }],
    typeof props
> {
    return useLLM(FnTestNamedArgsSingleEnumAction, props);
}

/**
 * A specialized hook for the GetDataType BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - text: string
 *
 *
 * Return Type:
 * - Non-streaming: RaysData
 * - Streaming Partial: RecursivePartialNull<RaysData>
 * - Streaming Final: RaysData
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useGetDataType();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to RaysData
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: RaysData | null
 *   partialData, // Type: RecursivePartialNull<RaysData> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useGetDataType({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<RaysData>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: RaysData
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       text: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       text: firstValue as string,
 *     }),
 *     mutate({
 *       text: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useGetDataType(
    props?: useLLMOptions<RecursivePartialNull<RaysData>, RaysData>
): useLLMReturn<
    RecursivePartialNull<RaysData>,
    RaysData,
    [params: {
        text: string
    }],
    typeof props
> {
    return useLLM(GetDataTypeAction, props);
}

/**
 * A specialized hook for the GetOrderInfo BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - email: Email
 *
 *
 * Return Type:
 * - Non-streaming: OrderInfo
 * - Streaming Partial: RecursivePartialNull<OrderInfo>
 * - Streaming Final: OrderInfo
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useGetOrderInfo();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to OrderInfo
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: OrderInfo | null
 *   partialData, // Type: RecursivePartialNull<OrderInfo> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useGetOrderInfo({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<OrderInfo>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: OrderInfo
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       email: someValue as Email,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       email: firstValue as Email,
 *     }),
 *     mutate({
 *       email: secondValue as Email,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useGetOrderInfo(
    props?: useLLMOptions<RecursivePartialNull<OrderInfo>, OrderInfo>
): useLLMReturn<
    RecursivePartialNull<OrderInfo>,
    OrderInfo,
    [params: {
        email: Email
    }],
    typeof props
> {
    return useLLM(GetOrderInfoAction, props);
}

/**
 * A specialized hook for the GetQuery BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - query: string
 *
 *
 * Return Type:
 * - Non-streaming: SearchParams
 * - Streaming Partial: RecursivePartialNull<SearchParams>
 * - Streaming Final: SearchParams
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useGetQuery();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to SearchParams
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: SearchParams | null
 *   partialData, // Type: RecursivePartialNull<SearchParams> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useGetQuery({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<SearchParams>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: SearchParams
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       query: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       query: firstValue as string,
 *     }),
 *     mutate({
 *       query: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useGetQuery(
    props?: useLLMOptions<RecursivePartialNull<SearchParams>, SearchParams>
): useLLMReturn<
    RecursivePartialNull<SearchParams>,
    SearchParams,
    [params: {
        query: string
    }],
    typeof props
> {
    return useLLM(GetQueryAction, props);
}

/**
 * A specialized hook for the InOutEnumMapKey BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - i1: Partial<Record<MapKey, string>>
 *
 * - i2: Partial<Record<MapKey, string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<MapKey, string>>
 * - Streaming Partial: RecursivePartialNull<Partial<Record<MapKey, string>>>
 * - Streaming Final: Partial<Record<MapKey, string>>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useInOutEnumMapKey();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Partial<Record<MapKey, string>>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Partial<Record<MapKey, string>> | null
 *   partialData, // Type: RecursivePartialNull<Partial<Record<MapKey, string>>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useInOutEnumMapKey({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Partial<Record<MapKey, string>>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Partial<Record<MapKey, string>>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       i1: someValue as Partial<Record<MapKey, string>>,  // Replace someValue with your data
 *       i2: someValue as Partial<Record<MapKey, string>>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       i1: firstValue as Partial<Record<MapKey, string>>,
 *       i2: firstValue as Partial<Record<MapKey, string>>,
 *     }),
 *     mutate({
 *       i1: secondValue as Partial<Record<MapKey, string>>,
 *       i2: secondValue as Partial<Record<MapKey, string>>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useInOutEnumMapKey(
    props?: useLLMOptions<RecursivePartialNull<Partial<Record<MapKey, string>>>, Partial<Record<MapKey, string>>>
): useLLMReturn<
    RecursivePartialNull<Partial<Record<MapKey, string>>>,
    Partial<Record<MapKey, string>>,
    [params: {
        i1: Partial<Record<MapKey, string>>,
        i2: Partial<Record<MapKey, string>>
    }],
    typeof props
> {
    return useLLM(InOutEnumMapKeyAction, props);
}

/**
 * A specialized hook for the InOutLiteralStringUnionMapKey BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - i1: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * - i2: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<"one" | "two" | "three" | "four", string>>
 * - Streaming Partial: RecursivePartialNull<Partial<Record<"one" | "two" | "three" | "four", string>>>
 * - Streaming Final: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useInOutLiteralStringUnionMapKey();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Partial<Record<"one" | "two" | "three" | "four", string>>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Partial<Record<"one" | "two" | "three" | "four", string>> | null
 *   partialData, // Type: RecursivePartialNull<Partial<Record<"one" | "two" | "three" | "four", string>>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useInOutLiteralStringUnionMapKey({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Partial<Record<"one" | "two" | "three" | "four", string>>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Partial<Record<"one" | "two" | "three" | "four", string>>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       i1: someValue as Partial<Record<"one" | "two" | "three" | "four", string>>,  // Replace someValue with your data
 *       i2: someValue as Partial<Record<"one" | "two" | "three" | "four", string>>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       i1: firstValue as Partial<Record<"one" | "two" | "three" | "four", string>>,
 *       i2: firstValue as Partial<Record<"one" | "two" | "three" | "four", string>>,
 *     }),
 *     mutate({
 *       i1: secondValue as Partial<Record<"one" | "two" | "three" | "four", string>>,
 *       i2: secondValue as Partial<Record<"one" | "two" | "three" | "four", string>>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useInOutLiteralStringUnionMapKey(
    props?: useLLMOptions<RecursivePartialNull<Partial<Record<"one" | "two" | "three" | "four", string>>>, Partial<Record<"one" | "two" | "three" | "four", string>>>
): useLLMReturn<
    RecursivePartialNull<Partial<Record<"one" | "two" | "three" | "four", string>>>,
    Partial<Record<"one" | "two" | "three" | "four", string>>,
    [params: {
        i1: Partial<Record<"one" | "two" | "three" | "four", string>>,
        i2: Partial<Record<"one" | "two" | "three" | "four", string>>
    }],
    typeof props
> {
    return useLLM(InOutLiteralStringUnionMapKeyAction, props);
}

/**
 * A specialized hook for the InOutSingleLiteralStringMapKey BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - m: Partial<Record<"key", string>>
 *
 *
 * Return Type:
 * - Non-streaming: Partial<Record<"key", string>>
 * - Streaming Partial: RecursivePartialNull<Partial<Record<"key", string>>>
 * - Streaming Final: Partial<Record<"key", string>>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useInOutSingleLiteralStringMapKey();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Partial<Record<"key", string>>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Partial<Record<"key", string>> | null
 *   partialData, // Type: RecursivePartialNull<Partial<Record<"key", string>>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useInOutSingleLiteralStringMapKey({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Partial<Record<"key", string>>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Partial<Record<"key", string>>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       m: someValue as Partial<Record<"key", string>>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       m: firstValue as Partial<Record<"key", string>>,
 *     }),
 *     mutate({
 *       m: secondValue as Partial<Record<"key", string>>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useInOutSingleLiteralStringMapKey(
    props?: useLLMOptions<RecursivePartialNull<Partial<Record<"key", string>>>, Partial<Record<"key", string>>>
): useLLMReturn<
    RecursivePartialNull<Partial<Record<"key", string>>>,
    Partial<Record<"key", string>>,
    [params: {
        m: Partial<Record<"key", string>>
    }],
    typeof props
> {
    return useLLM(InOutSingleLiteralStringMapKeyAction, props);
}

/**
 * A specialized hook for the JsonTypeAliasCycle BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: JsonValue
 *
 *
 * Return Type:
 * - Non-streaming: JsonValue
 * - Streaming Partial: RecursivePartialNull<JsonValue>
 * - Streaming Final: JsonValue
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useJsonTypeAliasCycle();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to JsonValue
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: JsonValue | null
 *   partialData, // Type: RecursivePartialNull<JsonValue> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useJsonTypeAliasCycle({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<JsonValue>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: JsonValue
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as JsonValue,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as JsonValue,
 *     }),
 *     mutate({
 *       input: secondValue as JsonValue,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useJsonTypeAliasCycle(
    props?: useLLMOptions<RecursivePartialNull<JsonValue>, JsonValue>
): useLLMReturn<
    RecursivePartialNull<JsonValue>,
    JsonValue,
    [params: {
        input: JsonValue
    }],
    typeof props
> {
    return useLLM(JsonTypeAliasCycleAction, props);
}

/**
 * A specialized hook for the LiteralUnionsTest BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: 1 | true | "string output"
 * - Streaming Partial: RecursivePartialNull<1 | true | "string output">
 * - Streaming Final: 1 | true | "string output"
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useLiteralUnionsTest();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to 1 | true | "string output"
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: 1 | true | "string output" | null
 *   partialData, // Type: RecursivePartialNull<1 | true | "string output"> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useLiteralUnionsTest({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<1 | true | "string output">
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: 1 | true | "string output"
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useLiteralUnionsTest(
    props?: useLLMOptions<RecursivePartialNull<1 | true | "string output">, 1 | true | "string output">
): useLLMReturn<
    RecursivePartialNull<1 | true | "string output">,
    1 | true | "string output",
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(LiteralUnionsTestAction, props);
}

/**
 * A specialized hook for the MakeBlockConstraint BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: Checked<BlockConstraint,"cross_field">
 * - Streaming Partial: RecursivePartialNull<Checked<BlockConstraint,"cross_field">>
 * - Streaming Final: Checked<BlockConstraint,"cross_field">
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useMakeBlockConstraint();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Checked<BlockConstraint,"cross_field">
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Checked<BlockConstraint,"cross_field"> | null
 *   partialData, // Type: RecursivePartialNull<Checked<BlockConstraint,"cross_field">> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useMakeBlockConstraint({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Checked<BlockConstraint,"cross_field">>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Checked<BlockConstraint,"cross_field">
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useMakeBlockConstraint(
    props?: useLLMOptions<RecursivePartialNull<Checked<BlockConstraint,"cross_field">>, Checked<BlockConstraint,"cross_field">>
): useLLMReturn<
    RecursivePartialNull<Checked<BlockConstraint,"cross_field">>,
    Checked<BlockConstraint,"cross_field">,
    [params: {
    }],
    typeof props
> {
    return useLLM(MakeBlockConstraintAction, props);
}

/**
 * A specialized hook for the MakeNestedBlockConstraint BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: NestedBlockConstraint
 * - Streaming Partial: RecursivePartialNull<NestedBlockConstraint>
 * - Streaming Final: NestedBlockConstraint
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useMakeNestedBlockConstraint();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to NestedBlockConstraint
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: NestedBlockConstraint | null
 *   partialData, // Type: RecursivePartialNull<NestedBlockConstraint> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useMakeNestedBlockConstraint({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<NestedBlockConstraint>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: NestedBlockConstraint
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useMakeNestedBlockConstraint(
    props?: useLLMOptions<RecursivePartialNull<NestedBlockConstraint>, NestedBlockConstraint>
): useLLMReturn<
    RecursivePartialNull<NestedBlockConstraint>,
    NestedBlockConstraint,
    [params: {
    }],
    typeof props
> {
    return useLLM(MakeNestedBlockConstraintAction, props);
}

/**
 * A specialized hook for the MapAlias BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - m: Record<string, string[]>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, string[]>
 * - Streaming Partial: RecursivePartialNull<Record<string, string[]>>
 * - Streaming Final: Record<string, string[]>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useMapAlias();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Record<string, string[]>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Record<string, string[]> | null
 *   partialData, // Type: RecursivePartialNull<Record<string, string[]>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useMapAlias({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Record<string, string[]>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Record<string, string[]>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       m: someValue as Record<string, string[]>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       m: firstValue as Record<string, string[]>,
 *     }),
 *     mutate({
 *       m: secondValue as Record<string, string[]>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useMapAlias(
    props?: useLLMOptions<RecursivePartialNull<Record<string, string[]>>, Record<string, string[]>>
): useLLMReturn<
    RecursivePartialNull<Record<string, string[]>>,
    Record<string, string[]>,
    [params: {
        m: Record<string, string[]>
    }],
    typeof props
> {
    return useLLM(MapAliasAction, props);
}

/**
 * A specialized hook for the MergeAliasAttributes BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - money: number
 *
 *
 * Return Type:
 * - Non-streaming: MergeAttrs
 * - Streaming Partial: RecursivePartialNull<MergeAttrs>
 * - Streaming Final: MergeAttrs
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useMergeAliasAttributes();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to MergeAttrs
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: MergeAttrs | null
 *   partialData, // Type: RecursivePartialNull<MergeAttrs> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useMergeAliasAttributes({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<MergeAttrs>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: MergeAttrs
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       money: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       money: firstValue as number,
 *     }),
 *     mutate({
 *       money: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useMergeAliasAttributes(
    props?: useLLMOptions<RecursivePartialNull<MergeAttrs>, MergeAttrs>
): useLLMReturn<
    RecursivePartialNull<MergeAttrs>,
    MergeAttrs,
    [params: {
        money: number
    }],
    typeof props
> {
    return useLLM(MergeAliasAttributesAction, props);
}

/**
 * A specialized hook for the MyFunc BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: DynamicOutput
 * - Streaming Partial: RecursivePartialNull<DynamicOutput>
 * - Streaming Final: DynamicOutput
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useMyFunc();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to DynamicOutput
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: DynamicOutput | null
 *   partialData, // Type: RecursivePartialNull<DynamicOutput> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useMyFunc({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<DynamicOutput>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: DynamicOutput
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useMyFunc(
    props?: useLLMOptions<RecursivePartialNull<DynamicOutput>, DynamicOutput>
): useLLMReturn<
    RecursivePartialNull<DynamicOutput>,
    DynamicOutput,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(MyFuncAction, props);
}

/**
 * A specialized hook for the NestedAlias BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - c: number | string | boolean | number | string[] | Record<string, string[]>
 *
 *
 * Return Type:
 * - Non-streaming: number | string | boolean | number | string[] | Record<string, string[]>
 * - Streaming Partial: RecursivePartialNull<number | string | boolean | number | string[] | Record<string, string[]>>
 * - Streaming Final: number | string | boolean | number | string[] | Record<string, string[]>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useNestedAlias();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number | string | boolean | number | string[] | Record<string, string[]>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | string | boolean | number | string[] | Record<string, string[]> | null
 *   partialData, // Type: RecursivePartialNull<number | string | boolean | number | string[] | Record<string, string[]>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useNestedAlias({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number | string | boolean | number | string[] | Record<string, string[]>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number | string | boolean | number | string[] | Record<string, string[]>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       c: someValue as number | string | boolean | number | string[] | Record<string, string[]>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       c: firstValue as number | string | boolean | number | string[] | Record<string, string[]>,
 *     }),
 *     mutate({
 *       c: secondValue as number | string | boolean | number | string[] | Record<string, string[]>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useNestedAlias(
    props?: useLLMOptions<RecursivePartialNull<number | string | boolean | number | string[] | Record<string, string[]>>, number | string | boolean | number | string[] | Record<string, string[]>>
): useLLMReturn<
    RecursivePartialNull<number | string | boolean | number | string[] | Record<string, string[]>>,
    number | string | boolean | number | string[] | Record<string, string[]>,
    [params: {
        c: number | string | boolean | number | string[] | Record<string, string[]>
    }],
    typeof props
> {
    return useLLM(NestedAliasAction, props);
}

/**
 * A specialized hook for the OptionalTest_Function BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: (OptionalTest_ReturnType | null)[]
 * - Streaming Partial: RecursivePartialNull<(OptionalTest_ReturnType | null)[]>
 * - Streaming Final: (OptionalTest_ReturnType | null)[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useOptionalTest_Function();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to (OptionalTest_ReturnType | null)[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: (OptionalTest_ReturnType | null)[] | null
 *   partialData, // Type: RecursivePartialNull<(OptionalTest_ReturnType | null)[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useOptionalTest_Function({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<(OptionalTest_ReturnType | null)[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: (OptionalTest_ReturnType | null)[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useOptionalTest_Function(
    props?: useLLMOptions<RecursivePartialNull<(OptionalTest_ReturnType | null)[]>, (OptionalTest_ReturnType | null)[]>
): useLLMReturn<
    RecursivePartialNull<(OptionalTest_ReturnType | null)[]>,
    (OptionalTest_ReturnType | null)[],
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(OptionalTest_FunctionAction, props);
}

/**
 * A specialized hook for the PredictAge BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - name: string
 *
 *
 * Return Type:
 * - Non-streaming: FooAny
 * - Streaming Partial: RecursivePartialNull<FooAny>
 * - Streaming Final: FooAny
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePredictAge();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to FooAny
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: FooAny | null
 *   partialData, // Type: RecursivePartialNull<FooAny> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePredictAge({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<FooAny>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: FooAny
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       name: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       name: firstValue as string,
 *     }),
 *     mutate({
 *       name: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePredictAge(
    props?: useLLMOptions<RecursivePartialNull<FooAny>, FooAny>
): useLLMReturn<
    RecursivePartialNull<FooAny>,
    FooAny,
    [params: {
        name: string
    }],
    typeof props
> {
    return useLLM(PredictAgeAction, props);
}

/**
 * A specialized hook for the PredictAgeBare BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - inp: string
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"too_big">
 * - Streaming Partial: RecursivePartialNull<Checked<number,"too_big">>
 * - Streaming Final: Checked<number,"too_big">
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePredictAgeBare();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Checked<number,"too_big">
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Checked<number,"too_big"> | null
 *   partialData, // Type: RecursivePartialNull<Checked<number,"too_big">> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePredictAgeBare({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Checked<number,"too_big">>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Checked<number,"too_big">
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       inp: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       inp: firstValue as string,
 *     }),
 *     mutate({
 *       inp: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePredictAgeBare(
    props?: useLLMOptions<RecursivePartialNull<Checked<number,"too_big">>, Checked<number,"too_big">>
): useLLMReturn<
    RecursivePartialNull<Checked<number,"too_big">>,
    Checked<number,"too_big">,
    [params: {
        inp: string
    }],
    typeof props
> {
    return useLLM(PredictAgeBareAction, props);
}

/**
 * A specialized hook for the PrimitiveAlias BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - p: number | string | boolean | number
 *
 *
 * Return Type:
 * - Non-streaming: number | string | boolean | number
 * - Streaming Partial: RecursivePartialNull<number | string | boolean | number>
 * - Streaming Final: number | string | boolean | number
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePrimitiveAlias();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number | string | boolean | number
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | string | boolean | number | null
 *   partialData, // Type: RecursivePartialNull<number | string | boolean | number> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePrimitiveAlias({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number | string | boolean | number>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number | string | boolean | number
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       p: someValue as number | string | boolean | number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       p: firstValue as number | string | boolean | number,
 *     }),
 *     mutate({
 *       p: secondValue as number | string | boolean | number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePrimitiveAlias(
    props?: useLLMOptions<RecursivePartialNull<number | string | boolean | number>, number | string | boolean | number>
): useLLMReturn<
    RecursivePartialNull<number | string | boolean | number>,
    number | string | boolean | number,
    [params: {
        p: number | string | boolean | number
    }],
    typeof props
> {
    return useLLM(PrimitiveAliasAction, props);
}

/**
 * A specialized hook for the PromptTestClaude BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePromptTestClaude();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePromptTestClaude({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePromptTestClaude(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(PromptTestClaudeAction, props);
}

/**
 * A specialized hook for the PromptTestClaudeChat BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePromptTestClaudeChat();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePromptTestClaudeChat({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePromptTestClaudeChat(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(PromptTestClaudeChatAction, props);
}

/**
 * A specialized hook for the PromptTestClaudeChatNoSystem BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePromptTestClaudeChatNoSystem();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePromptTestClaudeChatNoSystem({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePromptTestClaudeChatNoSystem(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(PromptTestClaudeChatNoSystemAction, props);
}

/**
 * A specialized hook for the PromptTestOpenAI BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePromptTestOpenAI();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePromptTestOpenAI({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePromptTestOpenAI(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(PromptTestOpenAIAction, props);
}

/**
 * A specialized hook for the PromptTestOpenAIChat BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePromptTestOpenAIChat();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePromptTestOpenAIChat({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePromptTestOpenAIChat(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(PromptTestOpenAIChatAction, props);
}

/**
 * A specialized hook for the PromptTestOpenAIChatNoSystem BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePromptTestOpenAIChatNoSystem();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePromptTestOpenAIChatNoSystem({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePromptTestOpenAIChatNoSystem(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(PromptTestOpenAIChatNoSystemAction, props);
}

/**
 * A specialized hook for the PromptTestStreaming BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = usePromptTestStreaming();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = usePromptTestStreaming({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function usePromptTestStreaming(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(PromptTestStreamingAction, props);
}

/**
 * A specialized hook for the RecursiveAliasCycle BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: RecAliasOne
 *
 *
 * Return Type:
 * - Non-streaming: RecAliasOne
 * - Streaming Partial: RecursivePartialNull<RecAliasOne>
 * - Streaming Final: RecAliasOne
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useRecursiveAliasCycle();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to RecAliasOne
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: RecAliasOne | null
 *   partialData, // Type: RecursivePartialNull<RecAliasOne> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useRecursiveAliasCycle({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<RecAliasOne>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: RecAliasOne
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as RecAliasOne,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as RecAliasOne,
 *     }),
 *     mutate({
 *       input: secondValue as RecAliasOne,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useRecursiveAliasCycle(
    props?: useLLMOptions<RecursivePartialNull<RecAliasOne>, RecAliasOne>
): useLLMReturn<
    RecursivePartialNull<RecAliasOne>,
    RecAliasOne,
    [params: {
        input: RecAliasOne
    }],
    typeof props
> {
    return useLLM(RecursiveAliasCycleAction, props);
}

/**
 * A specialized hook for the RecursiveClassWithAliasIndirection BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - cls: NodeWithAliasIndirection
 *
 *
 * Return Type:
 * - Non-streaming: NodeWithAliasIndirection
 * - Streaming Partial: RecursivePartialNull<NodeWithAliasIndirection>
 * - Streaming Final: NodeWithAliasIndirection
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useRecursiveClassWithAliasIndirection();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to NodeWithAliasIndirection
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: NodeWithAliasIndirection | null
 *   partialData, // Type: RecursivePartialNull<NodeWithAliasIndirection> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useRecursiveClassWithAliasIndirection({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<NodeWithAliasIndirection>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: NodeWithAliasIndirection
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       cls: someValue as NodeWithAliasIndirection,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       cls: firstValue as NodeWithAliasIndirection,
 *     }),
 *     mutate({
 *       cls: secondValue as NodeWithAliasIndirection,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useRecursiveClassWithAliasIndirection(
    props?: useLLMOptions<RecursivePartialNull<NodeWithAliasIndirection>, NodeWithAliasIndirection>
): useLLMReturn<
    RecursivePartialNull<NodeWithAliasIndirection>,
    NodeWithAliasIndirection,
    [params: {
        cls: NodeWithAliasIndirection
    }],
    typeof props
> {
    return useLLM(RecursiveClassWithAliasIndirectionAction, props);
}

/**
 * A specialized hook for the ReturnAliasWithMergedAttributes BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * Return Type:
 * - Non-streaming: Checked<number,"gt_ten">
 * - Streaming Partial: RecursivePartialNull<Checked<number,"gt_ten">>
 * - Streaming Final: Checked<number,"gt_ten">
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useReturnAliasWithMergedAttributes();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Checked<number,"gt_ten">
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Checked<number,"gt_ten"> | null
 *   partialData, // Type: RecursivePartialNull<Checked<number,"gt_ten">> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useReturnAliasWithMergedAttributes({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Checked<number,"gt_ten">>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Checked<number,"gt_ten">
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       money: someValue as Checked<number,"gt_ten">,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       money: firstValue as Checked<number,"gt_ten">,
 *     }),
 *     mutate({
 *       money: secondValue as Checked<number,"gt_ten">,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useReturnAliasWithMergedAttributes(
    props?: useLLMOptions<RecursivePartialNull<Checked<number,"gt_ten">>, Checked<number,"gt_ten">>
): useLLMReturn<
    RecursivePartialNull<Checked<number,"gt_ten">>,
    Checked<number,"gt_ten">,
    [params: {
        money: Checked<number,"gt_ten">
    }],
    typeof props
> {
    return useLLM(ReturnAliasWithMergedAttributesAction, props);
}

/**
 * A specialized hook for the ReturnFailingAssert BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - inp: number
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming Partial: RecursivePartialNull<number>
 * - Streaming Final: number
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useReturnFailingAssert();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | null
 *   partialData, // Type: RecursivePartialNull<number> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useReturnFailingAssert({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       inp: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       inp: firstValue as number,
 *     }),
 *     mutate({
 *       inp: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useReturnFailingAssert(
    props?: useLLMOptions<RecursivePartialNull<number>, number>
): useLLMReturn<
    RecursivePartialNull<number>,
    number,
    [params: {
        inp: number
    }],
    typeof props
> {
    return useLLM(ReturnFailingAssertAction, props);
}

/**
 * A specialized hook for the ReturnMalformedConstraints BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - a: number
 *
 *
 * Return Type:
 * - Non-streaming: MalformedConstraints
 * - Streaming Partial: RecursivePartialNull<MalformedConstraints>
 * - Streaming Final: MalformedConstraints
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useReturnMalformedConstraints();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to MalformedConstraints
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: MalformedConstraints | null
 *   partialData, // Type: RecursivePartialNull<MalformedConstraints> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useReturnMalformedConstraints({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<MalformedConstraints>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: MalformedConstraints
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       a: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       a: firstValue as number,
 *     }),
 *     mutate({
 *       a: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useReturnMalformedConstraints(
    props?: useLLMOptions<RecursivePartialNull<MalformedConstraints>, MalformedConstraints>
): useLLMReturn<
    RecursivePartialNull<MalformedConstraints>,
    MalformedConstraints,
    [params: {
        a: number
    }],
    typeof props
> {
    return useLLM(ReturnMalformedConstraintsAction, props);
}

/**
 * A specialized hook for the SchemaDescriptions BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: Schema
 * - Streaming Partial: RecursivePartialNull<Schema>
 * - Streaming Final: Schema
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useSchemaDescriptions();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Schema
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Schema | null
 *   partialData, // Type: RecursivePartialNull<Schema> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useSchemaDescriptions({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Schema>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Schema
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useSchemaDescriptions(
    props?: useLLMOptions<RecursivePartialNull<Schema>, Schema>
): useLLMReturn<
    RecursivePartialNull<Schema>,
    Schema,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(SchemaDescriptionsAction, props);
}

/**
 * A specialized hook for the SimpleRecursiveListAlias BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: RecursiveListAlias
 *
 *
 * Return Type:
 * - Non-streaming: RecursiveListAlias
 * - Streaming Partial: RecursivePartialNull<RecursiveListAlias>
 * - Streaming Final: RecursiveListAlias
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useSimpleRecursiveListAlias();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to RecursiveListAlias
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: RecursiveListAlias | null
 *   partialData, // Type: RecursivePartialNull<RecursiveListAlias> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useSimpleRecursiveListAlias({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<RecursiveListAlias>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: RecursiveListAlias
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as RecursiveListAlias,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as RecursiveListAlias,
 *     }),
 *     mutate({
 *       input: secondValue as RecursiveListAlias,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useSimpleRecursiveListAlias(
    props?: useLLMOptions<RecursivePartialNull<RecursiveListAlias>, RecursiveListAlias>
): useLLMReturn<
    RecursivePartialNull<RecursiveListAlias>,
    RecursiveListAlias,
    [params: {
        input: RecursiveListAlias
    }],
    typeof props
> {
    return useLLM(SimpleRecursiveListAliasAction, props);
}

/**
 * A specialized hook for the SimpleRecursiveMapAlias BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: RecursiveMapAlias
 *
 *
 * Return Type:
 * - Non-streaming: RecursiveMapAlias
 * - Streaming Partial: RecursivePartialNull<RecursiveMapAlias>
 * - Streaming Final: RecursiveMapAlias
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useSimpleRecursiveMapAlias();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to RecursiveMapAlias
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: RecursiveMapAlias | null
 *   partialData, // Type: RecursivePartialNull<RecursiveMapAlias> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useSimpleRecursiveMapAlias({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<RecursiveMapAlias>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: RecursiveMapAlias
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as RecursiveMapAlias,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as RecursiveMapAlias,
 *     }),
 *     mutate({
 *       input: secondValue as RecursiveMapAlias,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useSimpleRecursiveMapAlias(
    props?: useLLMOptions<RecursivePartialNull<RecursiveMapAlias>, RecursiveMapAlias>
): useLLMReturn<
    RecursivePartialNull<RecursiveMapAlias>,
    RecursiveMapAlias,
    [params: {
        input: RecursiveMapAlias
    }],
    typeof props
> {
    return useLLM(SimpleRecursiveMapAliasAction, props);
}

/**
 * A specialized hook for the StreamBigNumbers BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: BigNumbers
 * - Streaming Partial: RecursivePartialNull<BigNumbers>
 * - Streaming Final: BigNumbers
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useStreamBigNumbers();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to BigNumbers
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: BigNumbers | null
 *   partialData, // Type: RecursivePartialNull<BigNumbers> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useStreamBigNumbers({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<BigNumbers>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: BigNumbers
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       digits: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       digits: firstValue as number,
 *     }),
 *     mutate({
 *       digits: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useStreamBigNumbers(
    props?: useLLMOptions<RecursivePartialNull<BigNumbers>, BigNumbers>
): useLLMReturn<
    RecursivePartialNull<BigNumbers>,
    BigNumbers,
    [params: {
        digits: number
    }],
    typeof props
> {
    return useLLM(StreamBigNumbersAction, props);
}

/**
 * A specialized hook for the StreamFailingAssertion BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - theme: string
 *
 * - length: number
 *
 *
 * Return Type:
 * - Non-streaming: TwoStoriesOneTitle
 * - Streaming Partial: RecursivePartialNull<TwoStoriesOneTitle>
 * - Streaming Final: TwoStoriesOneTitle
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useStreamFailingAssertion();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to TwoStoriesOneTitle
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: TwoStoriesOneTitle | null
 *   partialData, // Type: RecursivePartialNull<TwoStoriesOneTitle> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useStreamFailingAssertion({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<TwoStoriesOneTitle>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: TwoStoriesOneTitle
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       theme: someValue as string,  // Replace someValue with your data
 *       length: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       theme: firstValue as string,
 *       length: firstValue as number,
 *     }),
 *     mutate({
 *       theme: secondValue as string,
 *       length: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useStreamFailingAssertion(
    props?: useLLMOptions<RecursivePartialNull<TwoStoriesOneTitle>, TwoStoriesOneTitle>
): useLLMReturn<
    RecursivePartialNull<TwoStoriesOneTitle>,
    TwoStoriesOneTitle,
    [params: {
        theme: string,
        length: number
    }],
    typeof props
> {
    return useLLM(StreamFailingAssertionAction, props);
}

/**
 * A specialized hook for the StreamOneBigNumber BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming Partial: RecursivePartialNull<number>
 * - Streaming Final: number
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useStreamOneBigNumber();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | null
 *   partialData, // Type: RecursivePartialNull<number> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useStreamOneBigNumber({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       digits: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       digits: firstValue as number,
 *     }),
 *     mutate({
 *       digits: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useStreamOneBigNumber(
    props?: useLLMOptions<RecursivePartialNull<number>, number>
): useLLMReturn<
    RecursivePartialNull<number>,
    number,
    [params: {
        digits: number
    }],
    typeof props
> {
    return useLLM(StreamOneBigNumberAction, props);
}

/**
 * A specialized hook for the StreamUnionIntegers BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - digits: number
 *
 *
 * Return Type:
 * - Non-streaming: (number | string)[]
 * - Streaming Partial: RecursivePartialNull<(number | string)[]>
 * - Streaming Final: (number | string)[]
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useStreamUnionIntegers();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to (number | string)[]
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: (number | string)[] | null
 *   partialData, // Type: RecursivePartialNull<(number | string)[]> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useStreamUnionIntegers({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<(number | string)[]>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: (number | string)[]
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       digits: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       digits: firstValue as number,
 *     }),
 *     mutate({
 *       digits: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useStreamUnionIntegers(
    props?: useLLMOptions<RecursivePartialNull<(number | string)[]>, (number | string)[]>
): useLLMReturn<
    RecursivePartialNull<(number | string)[]>,
    (number | string)[],
    [params: {
        digits: number
    }],
    typeof props
> {
    return useLLM(StreamUnionIntegersAction, props);
}

/**
 * A specialized hook for the StreamingCompoundNumbers BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - digits: number
 *
 * - yapping: boolean
 *
 *
 * Return Type:
 * - Non-streaming: CompoundBigNumbers
 * - Streaming Partial: RecursivePartialNull<CompoundBigNumbers>
 * - Streaming Final: CompoundBigNumbers
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useStreamingCompoundNumbers();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to CompoundBigNumbers
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: CompoundBigNumbers | null
 *   partialData, // Type: RecursivePartialNull<CompoundBigNumbers> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useStreamingCompoundNumbers({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<CompoundBigNumbers>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: CompoundBigNumbers
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       digits: someValue as number,  // Replace someValue with your data
 *       yapping: someValue as boolean,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       digits: firstValue as number,
 *       yapping: firstValue as boolean,
 *     }),
 *     mutate({
 *       digits: secondValue as number,
 *       yapping: secondValue as boolean,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useStreamingCompoundNumbers(
    props?: useLLMOptions<RecursivePartialNull<CompoundBigNumbers>, CompoundBigNumbers>
): useLLMReturn<
    RecursivePartialNull<CompoundBigNumbers>,
    CompoundBigNumbers,
    [params: {
        digits: number,
        yapping: boolean
    }],
    typeof props
> {
    return useLLM(StreamingCompoundNumbersAction, props);
}

/**
 * A specialized hook for the TestAnthropic BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAnthropic();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAnthropic({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAnthropic(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAnthropicAction, props);
}

/**
 * A specialized hook for the TestAnthropicShorthand BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAnthropicShorthand();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAnthropicShorthand({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAnthropicShorthand(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAnthropicShorthandAction, props);
}

/**
 * A specialized hook for the TestAws BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAws();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAws({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAws(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAwsAction, props);
}

/**
 * A specialized hook for the TestAwsInvalidAccessKey BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAwsInvalidAccessKey();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAwsInvalidAccessKey({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAwsInvalidAccessKey(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAwsInvalidAccessKeyAction, props);
}

/**
 * A specialized hook for the TestAwsInvalidProfile BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAwsInvalidProfile();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAwsInvalidProfile({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAwsInvalidProfile(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAwsInvalidProfileAction, props);
}

/**
 * A specialized hook for the TestAwsInvalidRegion BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAwsInvalidRegion();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAwsInvalidRegion({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAwsInvalidRegion(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAwsInvalidRegionAction, props);
}

/**
 * A specialized hook for the TestAwsInvalidSessionToken BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAwsInvalidSessionToken();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAwsInvalidSessionToken({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAwsInvalidSessionToken(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAwsInvalidSessionTokenAction, props);
}

/**
 * A specialized hook for the TestAzure BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAzure();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAzure({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAzure(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAzureAction, props);
}

/**
 * A specialized hook for the TestAzureFailure BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestAzureFailure();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestAzureFailure({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestAzureFailure(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestAzureFailureAction, props);
}

/**
 * A specialized hook for the TestCaching BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 * - not_cached: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestCaching();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestCaching({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *       not_cached: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *       not_cached: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *       not_cached: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestCaching(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string,
        not_cached: string
    }],
    typeof props
> {
    return useLLM(TestCachingAction, props);
}

/**
 * A specialized hook for the TestFallbackClient BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFallbackClient();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFallbackClient({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFallbackClient(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
    }],
    typeof props
> {
    return useLLM(TestFallbackClientAction, props);
}

/**
 * A specialized hook for the TestFallbackToShorthand BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFallbackToShorthand();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFallbackToShorthand({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFallbackToShorthand(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestFallbackToShorthandAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleBool BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myBool: boolean
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleBool();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleBool({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myBool: someValue as boolean,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myBool: firstValue as boolean,
 *     }),
 *     mutate({
 *       myBool: secondValue as boolean,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleBool(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myBool: boolean
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleBoolAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleClass BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleClass();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleClass({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myArg: someValue as NamedArgsSingleClass,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myArg: firstValue as NamedArgsSingleClass,
 *     }),
 *     mutate({
 *       myArg: secondValue as NamedArgsSingleClass,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleClass(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myArg: NamedArgsSingleClass
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleClassAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleEnumList BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleEnumList[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleEnumList();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleEnumList({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myArg: someValue as NamedArgsSingleEnumList[],  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myArg: firstValue as NamedArgsSingleEnumList[],
 *     }),
 *     mutate({
 *       myArg: secondValue as NamedArgsSingleEnumList[],
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleEnumList(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myArg: NamedArgsSingleEnumList[]
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleEnumListAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleFloat BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myFloat: number
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleFloat();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleFloat({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myFloat: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myFloat: firstValue as number,
 *     }),
 *     mutate({
 *       myFloat: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleFloat(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myFloat: number
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleFloatAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleInt BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myInt: number
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleInt();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleInt({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myInt: someValue as number,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myInt: firstValue as number,
 *     }),
 *     mutate({
 *       myInt: secondValue as number,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleInt(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myInt: number
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleIntAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToClass BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myMap: Record<string, StringToClassEntry>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, StringToClassEntry>
 * - Streaming Partial: RecursivePartialNull<Record<string, StringToClassEntry>>
 * - Streaming Final: Record<string, StringToClassEntry>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleMapStringToClass();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Record<string, StringToClassEntry>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Record<string, StringToClassEntry> | null
 *   partialData, // Type: RecursivePartialNull<Record<string, StringToClassEntry>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleMapStringToClass({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Record<string, StringToClassEntry>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Record<string, StringToClassEntry>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myMap: someValue as Record<string, StringToClassEntry>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myMap: firstValue as Record<string, StringToClassEntry>,
 *     }),
 *     mutate({
 *       myMap: secondValue as Record<string, StringToClassEntry>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToClass(
    props?: useLLMOptions<RecursivePartialNull<Record<string, StringToClassEntry>>, Record<string, StringToClassEntry>>
): useLLMReturn<
    RecursivePartialNull<Record<string, StringToClassEntry>>,
    Record<string, StringToClassEntry>,
    [params: {
        myMap: Record<string, StringToClassEntry>
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleMapStringToClassAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToMap BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myMap: Record<string, Record<string, string>>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, Record<string, string>>
 * - Streaming Partial: RecursivePartialNull<Record<string, Record<string, string>>>
 * - Streaming Final: Record<string, Record<string, string>>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleMapStringToMap();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Record<string, Record<string, string>>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Record<string, Record<string, string>> | null
 *   partialData, // Type: RecursivePartialNull<Record<string, Record<string, string>>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleMapStringToMap({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Record<string, Record<string, string>>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Record<string, Record<string, string>>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myMap: someValue as Record<string, Record<string, string>>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myMap: firstValue as Record<string, Record<string, string>>,
 *     }),
 *     mutate({
 *       myMap: secondValue as Record<string, Record<string, string>>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToMap(
    props?: useLLMOptions<RecursivePartialNull<Record<string, Record<string, string>>>, Record<string, Record<string, string>>>
): useLLMReturn<
    RecursivePartialNull<Record<string, Record<string, string>>>,
    Record<string, Record<string, string>>,
    [params: {
        myMap: Record<string, Record<string, string>>
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleMapStringToMapAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToString BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myMap: Record<string, string>
 *
 *
 * Return Type:
 * - Non-streaming: Record<string, string>
 * - Streaming Partial: RecursivePartialNull<Record<string, string>>
 * - Streaming Final: Record<string, string>
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleMapStringToString();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to Record<string, string>
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: Record<string, string> | null
 *   partialData, // Type: RecursivePartialNull<Record<string, string>> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleMapStringToString({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<Record<string, string>>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: Record<string, string>
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myMap: someValue as Record<string, string>,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myMap: firstValue as Record<string, string>,
 *     }),
 *     mutate({
 *       myMap: secondValue as Record<string, string>,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToString(
    props?: useLLMOptions<RecursivePartialNull<Record<string, string>>, Record<string, string>>
): useLLMReturn<
    RecursivePartialNull<Record<string, string>>,
    Record<string, string>,
    [params: {
        myMap: Record<string, string>
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleMapStringToStringAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleString BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myString: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleString();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleString({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myString: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myString: firstValue as string,
 *     }),
 *     mutate({
 *       myString: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleString(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myString: string
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleStringAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleStringArray BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myStringArray: string[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleStringArray();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleStringArray({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myStringArray: someValue as string[],  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myStringArray: firstValue as string[],
 *     }),
 *     mutate({
 *       myStringArray: secondValue as string[],
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleStringArray(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myStringArray: string[]
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleStringArrayAction, props);
}

/**
 * A specialized hook for the TestFnNamedArgsSingleStringList BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myArg: string[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestFnNamedArgsSingleStringList();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestFnNamedArgsSingleStringList({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myArg: someValue as string[],  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myArg: firstValue as string[],
 *     }),
 *     mutate({
 *       myArg: secondValue as string[],
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestFnNamedArgsSingleStringList(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myArg: string[]
    }],
    typeof props
> {
    return useLLM(TestFnNamedArgsSingleStringListAction, props);
}

/**
 * A specialized hook for the TestGemini BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestGemini();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestGemini({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestGemini(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestGeminiAction, props);
}

/**
 * A specialized hook for the TestImageInput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestImageInput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestImageInput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       img: someValue as Image,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       img: firstValue as Image,
 *     }),
 *     mutate({
 *       img: secondValue as Image,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestImageInput(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        img: Image
    }],
    typeof props
> {
    return useLLM(TestImageInputAction, props);
}

/**
 * A specialized hook for the TestImageInputAnthropic BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - img: Image
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestImageInputAnthropic();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestImageInputAnthropic({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       img: someValue as Image,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       img: firstValue as Image,
 *     }),
 *     mutate({
 *       img: secondValue as Image,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestImageInputAnthropic(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        img: Image
    }],
    typeof props
> {
    return useLLM(TestImageInputAnthropicAction, props);
}

/**
 * A specialized hook for the TestImageListInput BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - imgs: Image[]
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestImageListInput();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestImageListInput({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       imgs: someValue as Image[],  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       imgs: firstValue as Image[],
 *     }),
 *     mutate({
 *       imgs: secondValue as Image[],
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestImageListInput(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        imgs: Image[]
    }],
    typeof props
> {
    return useLLM(TestImageListInputAction, props);
}

/**
 * A specialized hook for the TestMulticlassNamedArgs BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myArg: NamedArgsSingleClass
 *
 * - myArg2: NamedArgsSingleClass
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestMulticlassNamedArgs();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestMulticlassNamedArgs({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myArg: someValue as NamedArgsSingleClass,  // Replace someValue with your data
 *       myArg2: someValue as NamedArgsSingleClass,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myArg: firstValue as NamedArgsSingleClass,
 *       myArg2: firstValue as NamedArgsSingleClass,
 *     }),
 *     mutate({
 *       myArg: secondValue as NamedArgsSingleClass,
 *       myArg2: secondValue as NamedArgsSingleClass,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestMulticlassNamedArgs(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myArg: NamedArgsSingleClass,
        myArg2: NamedArgsSingleClass
    }],
    typeof props
> {
    return useLLM(TestMulticlassNamedArgsAction, props);
}

/**
 * A specialized hook for the TestNamedArgsLiteralBool BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myBool: true
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestNamedArgsLiteralBool();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestNamedArgsLiteralBool({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myBool: someValue as true,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myBool: firstValue as true,
 *     }),
 *     mutate({
 *       myBool: secondValue as true,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestNamedArgsLiteralBool(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myBool: true
    }],
    typeof props
> {
    return useLLM(TestNamedArgsLiteralBoolAction, props);
}

/**
 * A specialized hook for the TestNamedArgsLiteralInt BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myInt: 1
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestNamedArgsLiteralInt();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestNamedArgsLiteralInt({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myInt: someValue as 1,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myInt: firstValue as 1,
 *     }),
 *     mutate({
 *       myInt: secondValue as 1,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestNamedArgsLiteralInt(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myInt: 1
    }],
    typeof props
> {
    return useLLM(TestNamedArgsLiteralIntAction, props);
}

/**
 * A specialized hook for the TestNamedArgsLiteralString BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - myString: "My String"
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestNamedArgsLiteralString();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestNamedArgsLiteralString({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       myString: someValue as "My String",  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       myString: firstValue as "My String",
 *     }),
 *     mutate({
 *       myString: secondValue as "My String",
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestNamedArgsLiteralString(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        myString: "My String"
    }],
    typeof props
> {
    return useLLM(TestNamedArgsLiteralStringAction, props);
}

/**
 * A specialized hook for the TestOllama BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestOllama();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestOllama({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestOllama(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestOllamaAction, props);
}

/**
 * A specialized hook for the TestOpenAILegacyProvider BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestOpenAILegacyProvider();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestOpenAILegacyProvider({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestOpenAILegacyProvider(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestOpenAILegacyProviderAction, props);
}

/**
 * A specialized hook for the TestOpenAIShorthand BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestOpenAIShorthand();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestOpenAIShorthand({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestOpenAIShorthand(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestOpenAIShorthandAction, props);
}

/**
 * A specialized hook for the TestRetryConstant BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestRetryConstant();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestRetryConstant({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestRetryConstant(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
    }],
    typeof props
> {
    return useLLM(TestRetryConstantAction, props);
}

/**
 * A specialized hook for the TestRetryExponential BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestRetryExponential();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestRetryExponential({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestRetryExponential(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
    }],
    typeof props
> {
    return useLLM(TestRetryExponentialAction, props);
}

/**
 * A specialized hook for the TestSingleFallbackClient BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestSingleFallbackClient();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestSingleFallbackClient({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *     }),
 *     mutate({
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestSingleFallbackClient(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
    }],
    typeof props
> {
    return useLLM(TestSingleFallbackClientAction, props);
}

/**
 * A specialized hook for the TestVertex BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string
 *
 *
 * Return Type:
 * - Non-streaming: string
 * - Streaming Partial: RecursivePartialNull<string>
 * - Streaming Final: string
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useTestVertex();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to string
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: string | null
 *   partialData, // Type: RecursivePartialNull<string> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useTestVertex({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<string>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: string
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string,
 *     }),
 *     mutate({
 *       input: secondValue as string,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useTestVertex(
    props?: useLLMOptions<RecursivePartialNull<string>, string>
): useLLMReturn<
    RecursivePartialNull<string>,
    string,
    [params: {
        input: string
    }],
    typeof props
> {
    return useLLM(TestVertexAction, props);
}

/**
 * A specialized hook for the UnionTest_Function BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - input: string | boolean
 *
 *
 * Return Type:
 * - Non-streaming: UnionTest_ReturnType
 * - Streaming Partial: RecursivePartialNull<UnionTest_ReturnType>
 * - Streaming Final: UnionTest_ReturnType
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useUnionTest_Function();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to UnionTest_ReturnType
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: UnionTest_ReturnType | null
 *   partialData, // Type: RecursivePartialNull<UnionTest_ReturnType> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useUnionTest_Function({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<UnionTest_ReturnType>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: UnionTest_ReturnType
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       input: someValue as string | boolean,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       input: firstValue as string | boolean,
 *     }),
 *     mutate({
 *       input: secondValue as string | boolean,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useUnionTest_Function(
    props?: useLLMOptions<RecursivePartialNull<UnionTest_ReturnType>, UnionTest_ReturnType>
): useLLMReturn<
    RecursivePartialNull<UnionTest_ReturnType>,
    UnionTest_ReturnType,
    [params: {
        input: string | boolean
    }],
    typeof props
> {
    return useLLM(UnionTest_FunctionAction, props);
}

/**
 * A specialized hook for the UseBlockConstraint BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - inp: BlockConstraintForParam
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming Partial: RecursivePartialNull<number>
 * - Streaming Final: number
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useUseBlockConstraint();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | null
 *   partialData, // Type: RecursivePartialNull<number> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useUseBlockConstraint({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       inp: someValue as BlockConstraintForParam,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       inp: firstValue as BlockConstraintForParam,
 *     }),
 *     mutate({
 *       inp: secondValue as BlockConstraintForParam,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useUseBlockConstraint(
    props?: useLLMOptions<RecursivePartialNull<number>, number>
): useLLMReturn<
    RecursivePartialNull<number>,
    number,
    [params: {
        inp: BlockConstraintForParam
    }],
    typeof props
> {
    return useLLM(UseBlockConstraintAction, props);
}

/**
 * A specialized hook for the UseMalformedConstraints BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - a: MalformedConstraints2
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming Partial: RecursivePartialNull<number>
 * - Streaming Final: number
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useUseMalformedConstraints();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | null
 *   partialData, // Type: RecursivePartialNull<number> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useUseMalformedConstraints({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       a: someValue as MalformedConstraints2,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       a: firstValue as MalformedConstraints2,
 *     }),
 *     mutate({
 *       a: secondValue as MalformedConstraints2,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useUseMalformedConstraints(
    props?: useLLMOptions<RecursivePartialNull<number>, number>
): useLLMReturn<
    RecursivePartialNull<number>,
    number,
    [params: {
        a: MalformedConstraints2
    }],
    typeof props
> {
    return useLLM(UseMalformedConstraintsAction, props);
}

/**
 * A specialized hook for the UseNestedBlockConstraint BAML function that handles both streaming and non-streaming responses.
 *
 * Input Types:
 *
 * - inp: NestedBlockConstraintForParam
 *
 *
 * Return Type:
 * - Non-streaming: number
 * - Streaming Partial: RecursivePartialNull<number>
 * - Streaming Final: number
 *
 * Common Usage Patterns:
 * 1. Non-streaming (Default)
 *    - Best for: Quick responses, simple UI updates
 *    - Avoid when: Response takes >5s or UI needs progressive updates
 *
 * 2. Streaming
 *    - Best for: Long-running operations, real-time UI feedback
 *    - Required when: Using features like chat interfaces or progress indicators
 *
 * Edge Cases & Gotchas:
 * 1. Error Handling
 *    - Network failures won't trigger onPartial/onFinal
 *    - Always implement onError for graceful degradation
 *    - Check error.message for specific failure reasons
 *
 * 2. Streaming Mode
 *    - partialData may be null even after updates (handle this case!)
 *    - Stream can end without final data (connection loss)
 *    - Partial results may be incomplete/invalid
 *
 * 3. State Management
 *    - data persists after completion (clear if needed)
 *    - isLoading stays true until final/error
 *    - Multiple rapid calls can race (latest wins)
 *
 * @param props Configuration options
 * @returns Hook state and controls
 *
 * @example
 * ```tsx
 * // 1. Basic Usage (Non-streaming)
 * const { data, error, isLoading, mutate } = useUseNestedBlockConstraint();
 *
 * // Handle the response
 * useEffect(() => {
 *   if (data) {
 *     // Type-safe access to number
 *     console.log('Success:', data);
 *   }
 * }, [data]);
 *
 * // 2. Streaming with Progress
 * const {
 *   data,        // Type: number | null
 *   partialData, // Type: RecursivePartialNull<number> | null
 *   isLoading,
 *   error,
 *   mutate
 * } = useUseNestedBlockConstraint({
 *   stream: true,
 *
 *   // Handle partial updates (may be incomplete!)
 *   onPartial: (partial) => {
 *     // Type: RecursivePartialNull<number>
 *     if (partial) {
 *       // Update UI with partial result
 *     }
 *   },
 *
 *   // Handle successful completion
 *   onFinal: (final) => {
 *     // Type: number
 *     // Update UI with complete result
 *   },
 *
 *   // Robust error handling
 *   onError: (error) => {
 *     if (error.message.includes('network')) {
 *       // Handle connection issues
 *     } else if (error.message.includes('timeout')) {
 *       // Handle timeouts
 *     } else {
 *       // Handle other errors
 *     }
 *   }
 * });
 *
 * // 3. Making the Request
 * const handleSubmit = async () => {
 *   try {
 *     const result = await mutate({
 *       // Type-safe parameters:
 *       inp: someValue as NestedBlockConstraintForParam,  // Replace someValue with your data
 *     });
 *
 *     if (result) {
 *       // Success case
 *     }
 *   } catch (e) {
 *     // Handle any synchronous errors
 *   }
 * };
 *
 * // 4. Race Condition Handling
 * const handleMultipleCalls = async () => {
 *   // Only the latest call's results will be reflected in the UI
 *   const results = await Promise.all([
 *     mutate({
 *       inp: firstValue as NestedBlockConstraintForParam,
 *     }),
 *     mutate({
 *       inp: secondValue as NestedBlockConstraintForParam,
 *     })
 *   ]);
 *   // Check results[1] for the final state
 * };
 * ```
 */
export function useUseNestedBlockConstraint(
    props?: useLLMOptions<RecursivePartialNull<number>, number>
): useLLMReturn<
    RecursivePartialNull<number>,
    number,
    [params: {
        inp: NestedBlockConstraintForParam
    }],
    typeof props
> {
    return useLLM(UseNestedBlockConstraintAction, props);
}

/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
import type { BamlStream } from '@boundaryml/baml';
import {
  BaseStreamableValue,
  StreamableValue,
  STREAMABLE_VALUE_TYPE,
  StreamingServerAction,
  StreamFunction,
  StreamHelperResult,
  StreamableController,
  PartialFinalValue,
} from './types';

/**
 * Type guard to check if a value is a StreamableValue
 * @param value The value to check
 * @returns True if the value is a StreamableValue
 */
export function isStreamableValue(value: unknown): value is BaseStreamableValue<unknown> {
  return (
    typeof value === 'object' &&
    value !== null &&
    'type' in value &&
    value.type === STREAMABLE_VALUE_TYPE
  );
}

/**
 * Creates a streamable value with methods to control the stream
 */
export function createStreamableValue<T>(): StreamableController<T> {
  let resolve: ((value: BaseStreamableValue<T>) => void) | undefined;
  let promise = new Promise<BaseStreamableValue<T>>((r) => (resolve = r));
  let current: BaseStreamableValue<T> = {
    type: STREAMABLE_VALUE_TYPE,
    next: promise,
  };

  return {
    done: (finalValue?: T) => {
      if (finalValue) {
        const next: BaseStreamableValue<T> = {
          type: STREAMABLE_VALUE_TYPE,
          curr: finalValue,
        };
        resolve?.(next);
        resolve = undefined;
      } else if (resolve) {
        resolve({
          type: STREAMABLE_VALUE_TYPE,
        });
        resolve = undefined;
      }
    },
    error: (error: Error) => {
      if (resolve) {
        resolve({
          type: STREAMABLE_VALUE_TYPE,
          error,
        });
        resolve = undefined;
      }
    },
    value: current,
    update: (value: T) => {
      const next: BaseStreamableValue<T> = {
        type: STREAMABLE_VALUE_TYPE,
        curr: value,
      };
      const newPromise = new Promise<BaseStreamableValue<T>>((r) => (resolve = r));
      next.next = newPromise;
      resolve?.(next);
      promise = newPromise;
    },
  };
}

/**
 * Helper function to manage and handle a BamlStream.
 * It consumes the stream, updates the streamable value for each partial event,
 * and finalizes the stream when complete.
 *
 * @param bamlStream - The BamlStream to be processed.
 * @returns A promise that resolves with an object containing the BaseStreamableValue.
 */
export async function streamHelper<TPartial, TFinal>(
  bamlStream: BamlStream<TPartial, TFinal>,
): Promise<StreamHelperResult<TPartial, TFinal>> {
  const streamable = createStreamableValue<PartialFinalValue<TPartial, TFinal>>();

  // Asynchronous function to process the BamlStream events
  (async () => {
    try {
      // Iterate through the stream and update the stream value with partial data
      for await (const event of bamlStream) {
        streamable.update({ partial: event });
      }

      // Obtain the final response once all events are processed
      const response = await bamlStream.getFinalResponse();
      streamable.done({ final: response });
    } catch (err) {
      streamable.error(err instanceof Error ? err : new Error(String(err)));
    }
  })();

  return { object: streamable.value };
}

/**
 * `readStreamableValue` takes a streamable value created via the `createStreamableValue().value` API,
 * and returns an async iterator.
 *
 * ```js
 * // Inside your AI action:
 *
 * async function action() {
 *   'use server'
 *   const streamable = createStreamableValue();
 *
 *   streamable.update(1);
 *   streamable.update(2);
 *   streamable.done(3);
 *   return streamable.value;
 * }
 * ```
 *
 * And to read the value:
 *
 * ```js
 * const streamableValue = await action()
 * for await (const v of readStreamableValue(streamableValue)) {
 *   console.log(v)
 * }
 * ```
 *
 * This logs out 1, 2, 3 on console.
 */
export function readStreamableValue<T = unknown>(
  streamableValue: StreamableValue<T>,
): AsyncIterable<T | undefined> {
  if (!isStreamableValue(streamableValue)) {
    throw new Error(
      'Invalid value: this hook only accepts values created via `createStreamableValue`.',
    );
  }

  return {
    [Symbol.asyncIterator]() {
      let row: StreamableValue<T> | Promise<StreamableValue<T>> =
        streamableValue;
      let value = row.curr; // the current value
      let isDone = false;
      let isFirstIteration = true;

      return {
        async next() {
          // the iteration is done already, return the last value:
          if (isDone) return { value, done: true };

          // resolve the promise at the beginning of each iteration:
          row = await row;

          // throw error if any:
          if (row.error !== undefined) {
            throw row.error;
          }

          // if there is a value or a patch, use it:
          if ('curr' in row || row.diff) {
            if (row.diff) {
              // streamable patch (text only):
              if (row.diff[0] === 0) {
                if (typeof value !== 'string') {
                  throw new Error(
                    'Invalid patch: can only append to string types. This is a bug in the AI SDK.',
                  );
                }

                // casting required to remove T & string limitation
                (value as string) = value + row.diff[1];
              }
            } else {
              // replace the value (full new value)
              value = row.curr;
            }

            // The last emitted { done: true } won't be used as the value
            // by the for await...of syntax.
            if (!row.next) {
              isDone = true;
              return { value, done: false };
            }
          }

          // there are no further rows to iterate over:
          if (row.next === undefined) {
            return { value, done: true };
          }

          row = row.next;

          if (isFirstIteration) {
            isFirstIteration = false; // TODO should this be set for every return?

            if (value === undefined) {
              // This is the initial chunk and there isn't an initial value yet.
              // Let's skip this one.
              return this.next();
            }
          }

          return { value, done: false };
        },
      };
    },
  };
}
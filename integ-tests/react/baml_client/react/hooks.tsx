/*************************************************************************************************

Welcome to Baml! To use this generated code, please run one of the following:

$ npm install @boundaryml/baml
$ yarn add @boundaryml/baml
$ pnpm add @boundaryml/baml

*************************************************************************************************/

// This file was generated by BAML: do not edit it. Instead, edit the BAML
// files and re-generate this code.
//
/* eslint-disable */
// tslint:disable
// @ts-nocheck
// biome-ignore format: autogenerated code
'use client'

import { useCallback, useMemo, useReducer, useTransition } from 'react';
import { BamlValidationError, BamlClientFinishReasonError } from "@boundaryml/baml/errors";
import * as Actions from './server';
import * as StreamingActions from './server_streaming'
import { StreamingServerTypes } from './server_streaming_types'

/**
 * Type representing a BAML stream response.
 *
 * @template PartialType The type of the partial response.
 * @template FinalType The type of the final response.
 */
type BamlStreamResponse<PartialType, FinalType> = {
  partial?: PartialType
  final?: FinalType
  error?: Error | BamlValidationError | BamlClientFinishReasonError
}

/**
 * A server action that returns either a ReadableStream of Uint8Array or a final output.
 */
export type ServerAction<Input = any, Output = any> = (
  ...args: Input extends any[] ? Input : [Input]
) => Promise<Output> | ReadableStream<Uint8Array>


/**
 * Type representing all function names except 'stream' and 'stream_types'
 */
export type FunctionNames = keyof typeof Actions

/**
 * Helper type to derive the partial return type for an action.
 */
type PartialReturnType<FunctionName extends FunctionNames> = StreamingServerTypes[FunctionName]


/**
 * Helper type to derive the final return type for an action.
 */
type FinalReturnType<FunctionName extends FunctionNames> = (typeof Actions)[FunctionName] extends (...args: any) => any
  ? Awaited<ReturnType<(typeof Actions)[FunctionName]>>
  : never


/**
 * Configuration options for BAML React hooks.
 */
export type HookInput<FunctionName extends FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = {
  stream?: Options['stream']
  onPartial?: Options['stream'] extends false ? never : (response?: PartialReturnType<FunctionName>) => void
  onFinal?: (response?: FinalReturnType<FunctionName>) => void
  onError?: (error: Error | BamlValidationError | BamlClientFinishReasonError) => void
}

/**
 * Return type for BAML React hooks.
 */
export type HookOutput<FunctionName extends FunctionNames, Options extends { stream?: boolean } = { stream?: true }> = {
  data?: FinalReturnType<FunctionName>
  streamingData?: Options['stream'] extends false ? never : PartialReturnType<FunctionName>
  error?: Error | BamlValidationError | BamlClientFinishReasonError
  isError: boolean
  isPending: boolean
  isSuccess: boolean
  status: 'idle' | 'pending' | 'success' | 'error'
  mutate: (
    ...args: Parameters<(typeof Actions)[FunctionName]>
  ) => Options['stream'] extends false ? Promise<FinalReturnType<FunctionName>> : Promise<ReadableStream<Uint8Array>>
}

/**
 * Type guard to check if the hook props are configured for streaming mode.
 *
 * @template FunctionName - The name of the BAML function.
 * @param props - The hook props.
 * @returns {boolean} True if the props indicate streaming mode.
 */
function isStreamingProps<FunctionName extends FunctionNames>(
  props: HookInput<FunctionName, { stream?: boolean }>,
): props is HookInput<FunctionName, { stream?: true }> {
  return props.stream !== false
}

/**
 * Type guard to check if the hook props are configured for non‑streaming mode.
 *
 * @template FunctionName - The name of the BAML function.
 * @param props - The hook props.
 * @returns {boolean} True if the props indicate non‑streaming mode.
 */
function isNotStreamingProps<FunctionName extends FunctionNames>(
  props: HookInput<FunctionName, { stream?: boolean }>,
): props is HookInput<FunctionName, { stream: false }> {
  return props.stream === false
}

function isBamlError(error?: Error | BamlValidationError | BamlClientFinishReasonError): error is (BamlValidationError | BamlClientFinishReasonError) & { type: string } {
  const errorType = (error as any)?.type;
  return errorType === 'BamlValidationError' || errorType === 'BamlClientFinishReasonError';
}

interface HookState<TPartial, TFinal> {
  isSuccess: boolean;
  error?: Error | BamlValidationError | BamlClientFinishReasonError;
  data?: TFinal;
  streamingData?: TPartial;
}

type HookStateAction<TPartial, TFinal> =
  | { type: 'START_REQUEST' }
  | { type: 'SET_ERROR'; payload: Error | BamlValidationError | BamlClientFinishReasonError }
  | { type: 'SET_PARTIAL'; payload: TPartial }
  | { type: 'SET_FINAL'; payload: TFinal }
  | { type: 'RESET' };

/**
 * Reducer function to manage the hook state transitions.
 *
 * @template TPartial - The type of the partial (streaming) data.
 * @template TFinal - The type of the final (non‑streaming) data.
 * @param state - The current hook state.
 * @param action - The action to apply.
 * @returns The updated state.
 */
function hookReducer<TPartial, TFinal>(
  state: HookState<TPartial, TFinal>,
  action: HookStateAction<TPartial, TFinal>
): HookState<TPartial, TFinal> {
  switch (action.type) {
    case 'START_REQUEST':
      return {
        ...state,
        isSuccess: false,
        error: undefined,
        data: undefined,
        streamingData: undefined,
      };
    case 'SET_ERROR':
      return {
        ...state,
        isSuccess: false,
        error: action.payload,
        data: undefined,
        streamingData: undefined,
      };
    case 'SET_PARTIAL':
      return {
        ...state,
        streamingData: action.payload,
      };
    case 'SET_FINAL':
      return {
        ...state,
        isSuccess: true,
        data: action.payload,
        streamingData: undefined,
      };
    case 'RESET':
      return {
        isSuccess: false,
        error: undefined,
        data: undefined,
        streamingData: undefined,
      };
    default:
      return state;
  }
}

/**
 * Base hook for executing BAML server actions, supporting both streaming and non‑streaming modes.
 *
 * This hook provides a unified interface for handling loading states, partial updates, errors,
 * and final responses. It is designed to be used directly with any BAML server action.
 *
 * Features:
 * - **Streaming Support:** Real‑time partial updates via `streamingData`, progress indicators, and incremental UI updates.
 * - **State Management:** Manages loading state (`isPending`), success/error flags, and final/partial results.
 * - **Error Handling:** Supports type‑safe error handling for BamlValidationError, BamlClientFinishReasonError, and standard errors.
 *
 * @param Action - The server action to invoke.
 * @param props - Configuration props for the hook.
 * @returns An object with the current state and a `mutate` function to trigger the action.
 *
 * @example
 * ```tsx
 * const { data, error, isPending, mutate } = useBamlAction(StreamingActions.TestAws, { stream: true });
 * ```
 */
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props?: HookInput<FunctionName, { stream?: true }>,
): HookOutput<FunctionName, { stream: true }>
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream: false }>,
): HookOutput<FunctionName, { stream: false }>
function useBamlAction<FunctionName extends FunctionNames>(
  action: ServerAction,
  props: HookInput<FunctionName, { stream?: boolean }> = {},
): HookOutput<FunctionName, { stream: true }> | HookOutput<FunctionName, { stream: false }> {
  const { onFinal, onError } = props
  const [isPending, startTransition] = useTransition()

  const [state, dispatch] = useReducer(hookReducer<PartialReturnType<FunctionName>, FinalReturnType<FunctionName>>, {
    isSuccess: false,
    error: undefined,
    data: undefined,
    streamingData: undefined,
  })

  const mutate = useCallback(
    async (...input: Parameters<ServerAction>) => {
      dispatch({ type: 'START_REQUEST' })
      try {
        let response: Awaited<ReturnType<ServerAction>>
        startTransition(async () => {
          response = await action(...input)
          if (isStreamingProps(props) && response instanceof ReadableStream) {
            const reader = response.getReader()
            const decoder = new TextDecoder()
            try {
              while (true) {
                const { value, done } = await reader.read()
                if (done) break
                if (value) {
                  const chunk = decoder.decode(value, { stream: true }).trim()
                  try {
                    const parsed: BamlStreamResponse<
                      PartialReturnType<FunctionName>,
                      FinalReturnType<FunctionName>
                    > = JSON.parse(chunk)
                    if (parsed.error) {
                      let error: Error | BamlValidationError | BamlClientFinishReasonError = new Error('Unknown error')

                      if (isBamlError(parsed.error)) {
                        if (parsed.error?.type === 'BamlValidationError') {
                          error = new BamlValidationError(
                            parsed.error.prompt,
                            parsed.error.raw_output,
                            parsed.error.message,
                          )
                        } else if (parsed.error.type === 'BamlClientFinishReasonError') {
                          error = new BamlClientFinishReasonError(
                            parsed.error.prompt,
                            parsed.error.raw_output,
                            parsed.error.message,
                          )
                        }
                      } else {
                        error = new Error(parsed.error.message)
                      }
                      throw error
                    }
                    if (parsed.partial !== undefined) {
                      dispatch({ type: 'SET_PARTIAL', payload: parsed.partial })
                      if (isStreamingProps(props)) {
                        props.onPartial?.(parsed.partial)
                      }
                    }
                    if (parsed.final !== undefined) {
                      dispatch({ type: 'SET_FINAL', payload: parsed.final })
                      onFinal?.(parsed.final)
                      return
                    }
                  } catch (err: unknown) {
                    dispatch({
                      type: 'SET_ERROR',
                      payload: err as Error | BamlValidationError | BamlClientFinishReasonError,
                    })
                    onError?.(err as Error | BamlValidationError | BamlClientFinishReasonError)
                    break
                  }
                }
              }
            } finally {
              reader.releaseLock()
            }
            return
          }
          // Non‑streaming case
          dispatch({ type: 'SET_FINAL', payload: response })
          onFinal?.(response)
        })
        return response
      } catch (error_: unknown) {
        dispatch({ type: 'SET_ERROR', payload: error_ as Error | BamlValidationError | BamlClientFinishReasonError })
        onError?.(error_ as Error | BamlValidationError | BamlClientFinishReasonError)
        throw error_
      }
    },
    [action, props.stream, onFinal, onError],
  )

  const status = useMemo<'idle' | 'pending' | 'success' | 'error'>(() => {
    if (isPending) return 'pending'
    if (state.error) return 'error'
    if (state.isSuccess) return 'success'
    return 'idle'
  }, [isPending, state.error, state.isSuccess])

  const result = {
    data: state.data,
    error: state.error,
    isError: !!state.error,
    isSuccess: state.isSuccess,
    isPending,
    mutate,
    status,
  }

  return {
    ...result,
    streamingData: isStreamingProps(props) ? state.streamingData : undefined,
  }
}
/**
 * A specialized hook for the AaaSamOutputFormat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - recipe: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Recipe
 * - **Streaming Partial:** partial_types.Recipe
 * - **Streaming Final:** Recipe
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAaaSamOutputFormat({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAaaSamOutputFormat({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAaaSamOutputFormat(props?: HookInput<'AaaSamOutputFormat', { stream?: true }>): HookOutput<'AaaSamOutputFormat', { stream: true }>
export function useAaaSamOutputFormat(props: HookInput<'AaaSamOutputFormat', { stream: false }>): HookOutput<'AaaSamOutputFormat', { stream: false }>
export function useAaaSamOutputFormat(
  props: HookInput<'AaaSamOutputFormat', { stream?: boolean }> = {},
): HookOutput<'AaaSamOutputFormat', { stream: true }> | HookOutput<'AaaSamOutputFormat', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AaaSamOutputFormat, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AaaSamOutputFormat, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AliasThatPointsToRecursiveType BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - list: LinkedListAliasNode
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LinkedListAliasNode
 * - **Streaming Partial:** partial_types.LinkedListAliasNode
 * - **Streaming Final:** LinkedListAliasNode
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasThatPointsToRecursiveType({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAliasThatPointsToRecursiveType({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasThatPointsToRecursiveType(props?: HookInput<'AliasThatPointsToRecursiveType', { stream?: true }>): HookOutput<'AliasThatPointsToRecursiveType', { stream: true }>
export function useAliasThatPointsToRecursiveType(props: HookInput<'AliasThatPointsToRecursiveType', { stream: false }>): HookOutput<'AliasThatPointsToRecursiveType', { stream: false }>
export function useAliasThatPointsToRecursiveType(
  props: HookInput<'AliasThatPointsToRecursiveType', { stream?: boolean }> = {},
): HookOutput<'AliasThatPointsToRecursiveType', { stream: true }> | HookOutput<'AliasThatPointsToRecursiveType', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AliasThatPointsToRecursiveType, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AliasThatPointsToRecursiveType, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AliasWithMultipleAttrs BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<number,"gt_ten">
 * - **Streaming Partial:** Checked<number,"gt_ten">
 * - **Streaming Final:** Checked<number,"gt_ten">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasWithMultipleAttrs({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAliasWithMultipleAttrs({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasWithMultipleAttrs(props?: HookInput<'AliasWithMultipleAttrs', { stream?: true }>): HookOutput<'AliasWithMultipleAttrs', { stream: true }>
export function useAliasWithMultipleAttrs(props: HookInput<'AliasWithMultipleAttrs', { stream: false }>): HookOutput<'AliasWithMultipleAttrs', { stream: false }>
export function useAliasWithMultipleAttrs(
  props: HookInput<'AliasWithMultipleAttrs', { stream?: boolean }> = {},
): HookOutput<'AliasWithMultipleAttrs', { stream: true }> | HookOutput<'AliasWithMultipleAttrs', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AliasWithMultipleAttrs, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AliasWithMultipleAttrs, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AliasedInputClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: InputClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputClass({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAliasedInputClass({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputClass(props?: HookInput<'AliasedInputClass', { stream?: true }>): HookOutput<'AliasedInputClass', { stream: true }>
export function useAliasedInputClass(props: HookInput<'AliasedInputClass', { stream: false }>): HookOutput<'AliasedInputClass', { stream: false }>
export function useAliasedInputClass(
  props: HookInput<'AliasedInputClass', { stream?: boolean }> = {},
): HookOutput<'AliasedInputClass', { stream: true }> | HookOutput<'AliasedInputClass', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AliasedInputClass, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AliasedInputClass, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AliasedInputClass2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: InputClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputClass2({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAliasedInputClass2({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputClass2(props?: HookInput<'AliasedInputClass2', { stream?: true }>): HookOutput<'AliasedInputClass2', { stream: true }>
export function useAliasedInputClass2(props: HookInput<'AliasedInputClass2', { stream: false }>): HookOutput<'AliasedInputClass2', { stream: false }>
export function useAliasedInputClass2(
  props: HookInput<'AliasedInputClass2', { stream?: boolean }> = {},
): HookOutput<'AliasedInputClass2', { stream: true }> | HookOutput<'AliasedInputClass2', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AliasedInputClass2, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AliasedInputClass2, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AliasedInputClassNested BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: InputClassNested
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputClassNested({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAliasedInputClassNested({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputClassNested(props?: HookInput<'AliasedInputClassNested', { stream?: true }>): HookOutput<'AliasedInputClassNested', { stream: true }>
export function useAliasedInputClassNested(props: HookInput<'AliasedInputClassNested', { stream: false }>): HookOutput<'AliasedInputClassNested', { stream: false }>
export function useAliasedInputClassNested(
  props: HookInput<'AliasedInputClassNested', { stream?: boolean }> = {},
): HookOutput<'AliasedInputClassNested', { stream: true }> | HookOutput<'AliasedInputClassNested', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AliasedInputClassNested, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AliasedInputClassNested, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AliasedInputEnum BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: AliasedEnum
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputEnum({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAliasedInputEnum({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputEnum(props?: HookInput<'AliasedInputEnum', { stream?: true }>): HookOutput<'AliasedInputEnum', { stream: true }>
export function useAliasedInputEnum(props: HookInput<'AliasedInputEnum', { stream: false }>): HookOutput<'AliasedInputEnum', { stream: false }>
export function useAliasedInputEnum(
  props: HookInput<'AliasedInputEnum', { stream?: boolean }> = {},
): HookOutput<'AliasedInputEnum', { stream: true }> | HookOutput<'AliasedInputEnum', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AliasedInputEnum, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AliasedInputEnum, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AliasedInputList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: AliasedEnum[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAliasedInputList({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAliasedInputList({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAliasedInputList(props?: HookInput<'AliasedInputList', { stream?: true }>): HookOutput<'AliasedInputList', { stream: true }>
export function useAliasedInputList(props: HookInput<'AliasedInputList', { stream: false }>): HookOutput<'AliasedInputList', { stream: false }>
export function useAliasedInputList(
  props: HookInput<'AliasedInputList', { stream?: boolean }> = {},
): HookOutput<'AliasedInputList', { stream: true }> | HookOutput<'AliasedInputList', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AliasedInputList, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AliasedInputList, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AllowedOptionals BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - optionals: OptionalListAndMap
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** OptionalListAndMap
 * - **Streaming Partial:** partial_types.OptionalListAndMap
 * - **Streaming Final:** OptionalListAndMap
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAllowedOptionals({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAllowedOptionals({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAllowedOptionals(props?: HookInput<'AllowedOptionals', { stream?: true }>): HookOutput<'AllowedOptionals', { stream: true }>
export function useAllowedOptionals(props: HookInput<'AllowedOptionals', { stream: false }>): HookOutput<'AllowedOptionals', { stream: false }>
export function useAllowedOptionals(
  props: HookInput<'AllowedOptionals', { stream?: boolean }> = {},
): HookOutput<'AllowedOptionals', { stream: true }> | HookOutput<'AllowedOptionals', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AllowedOptionals, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AllowedOptionals, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AssertFn BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - a: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAssertFn({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAssertFn({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAssertFn(props?: HookInput<'AssertFn', { stream?: true }>): HookOutput<'AssertFn', { stream: true }>
export function useAssertFn(props: HookInput<'AssertFn', { stream: false }>): HookOutput<'AssertFn', { stream: false }>
export function useAssertFn(
  props: HookInput<'AssertFn', { stream?: boolean }> = {},
): HookOutput<'AssertFn', { stream: true }> | HookOutput<'AssertFn', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AssertFn, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AssertFn, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the AudioInput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - aud: Audio
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useAudioInput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useAudioInput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useAudioInput(props?: HookInput<'AudioInput', { stream?: true }>): HookOutput<'AudioInput', { stream: true }>
export function useAudioInput(props: HookInput<'AudioInput', { stream: false }>): HookOutput<'AudioInput', { stream: false }>
export function useAudioInput(
  props: HookInput<'AudioInput', { stream?: boolean }> = {},
): HookOutput<'AudioInput', { stream: true }> | HookOutput<'AudioInput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.AudioInput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.AudioInput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the BuildLinkedList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: number[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LinkedList
 * - **Streaming Partial:** partial_types.LinkedList
 * - **Streaming Final:** LinkedList
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useBuildLinkedList({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useBuildLinkedList({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useBuildLinkedList(props?: HookInput<'BuildLinkedList', { stream?: true }>): HookOutput<'BuildLinkedList', { stream: true }>
export function useBuildLinkedList(props: HookInput<'BuildLinkedList', { stream: false }>): HookOutput<'BuildLinkedList', { stream: false }>
export function useBuildLinkedList(
  props: HookInput<'BuildLinkedList', { stream?: boolean }> = {},
): HookOutput<'BuildLinkedList', { stream: true }> | HookOutput<'BuildLinkedList', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.BuildLinkedList, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.BuildLinkedList, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the BuildTree BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: BinaryNode
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Tree
 * - **Streaming Partial:** partial_types.Tree
 * - **Streaming Final:** Tree
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useBuildTree({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useBuildTree({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useBuildTree(props?: HookInput<'BuildTree', { stream?: true }>): HookOutput<'BuildTree', { stream: true }>
export function useBuildTree(props: HookInput<'BuildTree', { stream: false }>): HookOutput<'BuildTree', { stream: false }>
export function useBuildTree(
  props: HookInput<'BuildTree', { stream?: boolean }> = {},
): HookOutput<'BuildTree', { stream: true }> | HookOutput<'BuildTree', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.BuildTree, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.BuildTree, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ClassThatPointsToRecursiveClassThroughAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - cls: ClassToRecAlias
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassToRecAlias
 * - **Streaming Partial:** partial_types.ClassToRecAlias
 * - **Streaming Final:** ClassToRecAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassThatPointsToRecursiveClassThroughAlias({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useClassThatPointsToRecursiveClassThroughAlias({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassThatPointsToRecursiveClassThroughAlias(props?: HookInput<'ClassThatPointsToRecursiveClassThroughAlias', { stream?: true }>): HookOutput<'ClassThatPointsToRecursiveClassThroughAlias', { stream: true }>
export function useClassThatPointsToRecursiveClassThroughAlias(props: HookInput<'ClassThatPointsToRecursiveClassThroughAlias', { stream: false }>): HookOutput<'ClassThatPointsToRecursiveClassThroughAlias', { stream: false }>
export function useClassThatPointsToRecursiveClassThroughAlias(
  props: HookInput<'ClassThatPointsToRecursiveClassThroughAlias', { stream?: boolean }> = {},
): HookOutput<'ClassThatPointsToRecursiveClassThroughAlias', { stream: true }> | HookOutput<'ClassThatPointsToRecursiveClassThroughAlias', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ClassThatPointsToRecursiveClassThroughAlias, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ClassThatPointsToRecursiveClassThroughAlias, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ClassifyDynEnumTwo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (string | DynEnumTwo)
 * - **Streaming Partial:** (string | DynEnumTwo)
 * - **Streaming Final:** (string | DynEnumTwo)
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyDynEnumTwo({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useClassifyDynEnumTwo({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyDynEnumTwo(props?: HookInput<'ClassifyDynEnumTwo', { stream?: true }>): HookOutput<'ClassifyDynEnumTwo', { stream: true }>
export function useClassifyDynEnumTwo(props: HookInput<'ClassifyDynEnumTwo', { stream: false }>): HookOutput<'ClassifyDynEnumTwo', { stream: false }>
export function useClassifyDynEnumTwo(
  props: HookInput<'ClassifyDynEnumTwo', { stream?: boolean }> = {},
): HookOutput<'ClassifyDynEnumTwo', { stream: true }> | HookOutput<'ClassifyDynEnumTwo', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ClassifyDynEnumTwo, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ClassifyDynEnumTwo, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ClassifyMessage BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category
 * - **Streaming Partial:** types.Category
 * - **Streaming Final:** Category
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyMessage({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useClassifyMessage({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage(props?: HookInput<'ClassifyMessage', { stream?: true }>): HookOutput<'ClassifyMessage', { stream: true }>
export function useClassifyMessage(props: HookInput<'ClassifyMessage', { stream: false }>): HookOutput<'ClassifyMessage', { stream: false }>
export function useClassifyMessage(
  props: HookInput<'ClassifyMessage', { stream?: boolean }> = {},
): HookOutput<'ClassifyMessage', { stream: true }> | HookOutput<'ClassifyMessage', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ClassifyMessage, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ClassifyMessage, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ClassifyMessage2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category
 * - **Streaming Partial:** types.Category
 * - **Streaming Final:** Category
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyMessage2({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useClassifyMessage2({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage2(props?: HookInput<'ClassifyMessage2', { stream?: true }>): HookOutput<'ClassifyMessage2', { stream: true }>
export function useClassifyMessage2(props: HookInput<'ClassifyMessage2', { stream: false }>): HookOutput<'ClassifyMessage2', { stream: false }>
export function useClassifyMessage2(
  props: HookInput<'ClassifyMessage2', { stream?: boolean }> = {},
): HookOutput<'ClassifyMessage2', { stream: true }> | HookOutput<'ClassifyMessage2', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ClassifyMessage2, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ClassifyMessage2, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ClassifyMessage3 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Category
 * - **Streaming Partial:** types.Category
 * - **Streaming Final:** Category
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useClassifyMessage3({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useClassifyMessage3({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useClassifyMessage3(props?: HookInput<'ClassifyMessage3', { stream?: true }>): HookOutput<'ClassifyMessage3', { stream: true }>
export function useClassifyMessage3(props: HookInput<'ClassifyMessage3', { stream: false }>): HookOutput<'ClassifyMessage3', { stream: false }>
export function useClassifyMessage3(
  props: HookInput<'ClassifyMessage3', { stream?: boolean }> = {},
): HookOutput<'ClassifyMessage3', { stream: true }> | HookOutput<'ClassifyMessage3', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ClassifyMessage3, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ClassifyMessage3, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the Completion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - prefix: string
 *
 * - suffix: string
 *
 * - language: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useCompletion({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useCompletion({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useCompletion(props?: HookInput<'Completion', { stream?: true }>): HookOutput<'Completion', { stream: true }>
export function useCompletion(props: HookInput<'Completion', { stream: false }>): HookOutput<'Completion', { stream: false }>
export function useCompletion(
  props: HookInput<'Completion', { stream?: boolean }> = {},
): HookOutput<'Completion', { stream: true }> | HookOutput<'Completion', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.Completion, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.Completion, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the CustomTask BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** BookOrder | FlightConfirmation | GroceryReceipt
 * - **Streaming Partial:** ((partial_types.BookOrder | null) | (partial_types.FlightConfirmation | null) | (partial_types.GroceryReceipt | null))
 * - **Streaming Final:** BookOrder | FlightConfirmation | GroceryReceipt
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useCustomTask({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useCustomTask({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useCustomTask(props?: HookInput<'CustomTask', { stream?: true }>): HookOutput<'CustomTask', { stream: true }>
export function useCustomTask(props: HookInput<'CustomTask', { stream: false }>): HookOutput<'CustomTask', { stream: false }>
export function useCustomTask(
  props: HookInput<'CustomTask', { stream?: boolean }> = {},
): HookOutput<'CustomTask', { stream: true }> | HookOutput<'CustomTask', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.CustomTask, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.CustomTask, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DescribeImage BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDescribeImage({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage(props?: HookInput<'DescribeImage', { stream?: true }>): HookOutput<'DescribeImage', { stream: true }>
export function useDescribeImage(props: HookInput<'DescribeImage', { stream: false }>): HookOutput<'DescribeImage', { stream: false }>
export function useDescribeImage(
  props: HookInput<'DescribeImage', { stream?: boolean }> = {},
): HookOutput<'DescribeImage', { stream: true }> | HookOutput<'DescribeImage', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DescribeImage, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DescribeImage, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DescribeImage2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage2({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDescribeImage2({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage2(props?: HookInput<'DescribeImage2', { stream?: true }>): HookOutput<'DescribeImage2', { stream: true }>
export function useDescribeImage2(props: HookInput<'DescribeImage2', { stream: false }>): HookOutput<'DescribeImage2', { stream: false }>
export function useDescribeImage2(
  props: HookInput<'DescribeImage2', { stream?: boolean }> = {},
): HookOutput<'DescribeImage2', { stream: true }> | HookOutput<'DescribeImage2', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DescribeImage2, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DescribeImage2, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DescribeImage3 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage3({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDescribeImage3({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage3(props?: HookInput<'DescribeImage3', { stream?: true }>): HookOutput<'DescribeImage3', { stream: true }>
export function useDescribeImage3(props: HookInput<'DescribeImage3', { stream: false }>): HookOutput<'DescribeImage3', { stream: false }>
export function useDescribeImage3(
  props: HookInput<'DescribeImage3', { stream?: boolean }> = {},
): HookOutput<'DescribeImage3', { stream: true }> | HookOutput<'DescribeImage3', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DescribeImage3, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DescribeImage3, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DescribeImage4 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - classWithImage: ClassWithImage
 *
 * - img2: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDescribeImage4({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDescribeImage4({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDescribeImage4(props?: HookInput<'DescribeImage4', { stream?: true }>): HookOutput<'DescribeImage4', { stream: true }>
export function useDescribeImage4(props: HookInput<'DescribeImage4', { stream: false }>): HookOutput<'DescribeImage4', { stream: false }>
export function useDescribeImage4(
  props: HookInput<'DescribeImage4', { stream?: boolean }> = {},
): HookOutput<'DescribeImage4', { stream: true }> | HookOutput<'DescribeImage4', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DescribeImage4, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DescribeImage4, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DifferentiateUnions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** OriginalA | OriginalB
 * - **Streaming Partial:** ((partial_types.OriginalA | null) | (partial_types.OriginalB | null))
 * - **Streaming Final:** OriginalA | OriginalB
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDifferentiateUnions({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDifferentiateUnions({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDifferentiateUnions(props?: HookInput<'DifferentiateUnions', { stream?: true }>): HookOutput<'DifferentiateUnions', { stream: true }>
export function useDifferentiateUnions(props: HookInput<'DifferentiateUnions', { stream: false }>): HookOutput<'DifferentiateUnions', { stream: false }>
export function useDifferentiateUnions(
  props: HookInput<'DifferentiateUnions', { stream?: boolean }> = {},
): HookOutput<'DifferentiateUnions', { stream: true }> | HookOutput<'DifferentiateUnions', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DifferentiateUnions, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DifferentiateUnions, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DummyOutputFunction BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DummyOutput
 * - **Streaming Partial:** partial_types.DummyOutput
 * - **Streaming Final:** DummyOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDummyOutputFunction({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDummyOutputFunction({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDummyOutputFunction(props?: HookInput<'DummyOutputFunction', { stream?: true }>): HookOutput<'DummyOutputFunction', { stream: true }>
export function useDummyOutputFunction(props: HookInput<'DummyOutputFunction', { stream: false }>): HookOutput<'DummyOutputFunction', { stream: false }>
export function useDummyOutputFunction(
  props: HookInput<'DummyOutputFunction', { stream?: boolean }> = {},
): HookOutput<'DummyOutputFunction', { stream: true }> | HookOutput<'DummyOutputFunction', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DummyOutputFunction, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DummyOutputFunction, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DynamicFunc BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: DynamicClassOne
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynamicClassTwo
 * - **Streaming Partial:** partial_types.DynamicClassTwo
 * - **Streaming Final:** DynamicClassTwo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDynamicFunc({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDynamicFunc({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDynamicFunc(props?: HookInput<'DynamicFunc', { stream?: true }>): HookOutput<'DynamicFunc', { stream: true }>
export function useDynamicFunc(props: HookInput<'DynamicFunc', { stream: false }>): HookOutput<'DynamicFunc', { stream: false }>
export function useDynamicFunc(
  props: HookInput<'DynamicFunc', { stream?: boolean }> = {},
): HookOutput<'DynamicFunc', { stream: true }> | HookOutput<'DynamicFunc', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DynamicFunc, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DynamicFunc, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DynamicInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: DynInputOutput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynInputOutput
 * - **Streaming Partial:** partial_types.DynInputOutput
 * - **Streaming Final:** DynInputOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDynamicInputOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDynamicInputOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDynamicInputOutput(props?: HookInput<'DynamicInputOutput', { stream?: true }>): HookOutput<'DynamicInputOutput', { stream: true }>
export function useDynamicInputOutput(props: HookInput<'DynamicInputOutput', { stream: false }>): HookOutput<'DynamicInputOutput', { stream: false }>
export function useDynamicInputOutput(
  props: HookInput<'DynamicInputOutput', { stream?: boolean }> = {},
): HookOutput<'DynamicInputOutput', { stream: true }> | HookOutput<'DynamicInputOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DynamicInputOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DynamicInputOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the DynamicListInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: DynInputOutput[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynInputOutput[]
 * - **Streaming Partial:** (partial_types.DynInputOutput | null)[]
 * - **Streaming Final:** DynInputOutput[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useDynamicListInputOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useDynamicListInputOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useDynamicListInputOutput(props?: HookInput<'DynamicListInputOutput', { stream?: true }>): HookOutput<'DynamicListInputOutput', { stream: true }>
export function useDynamicListInputOutput(props: HookInput<'DynamicListInputOutput', { stream: false }>): HookOutput<'DynamicListInputOutput', { stream: false }>
export function useDynamicListInputOutput(
  props: HookInput<'DynamicListInputOutput', { stream?: boolean }> = {},
): HookOutput<'DynamicListInputOutput', { stream: true }> | HookOutput<'DynamicListInputOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.DynamicListInputOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.DynamicListInputOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExpectFailure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExpectFailure({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExpectFailure({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExpectFailure(props?: HookInput<'ExpectFailure', { stream?: true }>): HookOutput<'ExpectFailure', { stream: true }>
export function useExpectFailure(props: HookInput<'ExpectFailure', { stream: false }>): HookOutput<'ExpectFailure', { stream: false }>
export function useExpectFailure(
  props: HookInput<'ExpectFailure', { stream?: boolean }> = {},
): HookOutput<'ExpectFailure', { stream: true }> | HookOutput<'ExpectFailure', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExpectFailure, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExpectFailure, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExtractContactInfo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - document: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ContactInfo
 * - **Streaming Partial:** partial_types.ContactInfo
 * - **Streaming Final:** ContactInfo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractContactInfo({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExtractContactInfo({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractContactInfo(props?: HookInput<'ExtractContactInfo', { stream?: true }>): HookOutput<'ExtractContactInfo', { stream: true }>
export function useExtractContactInfo(props: HookInput<'ExtractContactInfo', { stream: false }>): HookOutput<'ExtractContactInfo', { stream: false }>
export function useExtractContactInfo(
  props: HookInput<'ExtractContactInfo', { stream?: boolean }> = {},
): HookOutput<'ExtractContactInfo', { stream: true }> | HookOutput<'ExtractContactInfo', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExtractContactInfo, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExtractContactInfo, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExtractHobby BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (string | Hobby)[]
 * - **Streaming Partial:** (string | Hobby | null)[]
 * - **Streaming Final:** (string | Hobby)[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractHobby({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExtractHobby({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractHobby(props?: HookInput<'ExtractHobby', { stream?: true }>): HookOutput<'ExtractHobby', { stream: true }>
export function useExtractHobby(props: HookInput<'ExtractHobby', { stream: false }>): HookOutput<'ExtractHobby', { stream: false }>
export function useExtractHobby(
  props: HookInput<'ExtractHobby', { stream?: boolean }> = {},
): HookOutput<'ExtractHobby', { stream: true }> | HookOutput<'ExtractHobby', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExtractHobby, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExtractHobby, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExtractNames BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string[]
 * - **Streaming Partial:** (string | null)[]
 * - **Streaming Final:** string[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractNames({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExtractNames({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractNames(props?: HookInput<'ExtractNames', { stream?: true }>): HookOutput<'ExtractNames', { stream: true }>
export function useExtractNames(props: HookInput<'ExtractNames', { stream: false }>): HookOutput<'ExtractNames', { stream: false }>
export function useExtractNames(
  props: HookInput<'ExtractNames', { stream?: boolean }> = {},
): HookOutput<'ExtractNames', { stream: true }> | HookOutput<'ExtractNames', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExtractNames, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExtractNames, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExtractPeople BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Person[]
 * - **Streaming Partial:** (partial_types.Person | null)[]
 * - **Streaming Final:** Person[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractPeople({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExtractPeople({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractPeople(props?: HookInput<'ExtractPeople', { stream?: true }>): HookOutput<'ExtractPeople', { stream: true }>
export function useExtractPeople(props: HookInput<'ExtractPeople', { stream: false }>): HookOutput<'ExtractPeople', { stream: false }>
export function useExtractPeople(
  props: HookInput<'ExtractPeople', { stream?: boolean }> = {},
): HookOutput<'ExtractPeople', { stream: true }> | HookOutput<'ExtractPeople', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExtractPeople, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExtractPeople, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExtractReceiptInfo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - email: string
 *
 * - reason: "curiosity" | "personal_finance"
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ReceiptInfo
 * - **Streaming Partial:** partial_types.ReceiptInfo
 * - **Streaming Final:** ReceiptInfo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractReceiptInfo({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExtractReceiptInfo({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractReceiptInfo(props?: HookInput<'ExtractReceiptInfo', { stream?: true }>): HookOutput<'ExtractReceiptInfo', { stream: true }>
export function useExtractReceiptInfo(props: HookInput<'ExtractReceiptInfo', { stream: false }>): HookOutput<'ExtractReceiptInfo', { stream: false }>
export function useExtractReceiptInfo(
  props: HookInput<'ExtractReceiptInfo', { stream?: boolean }> = {},
): HookOutput<'ExtractReceiptInfo', { stream: true }> | HookOutput<'ExtractReceiptInfo', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExtractReceiptInfo, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExtractReceiptInfo, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExtractResume BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - resume: string
 *
 * - img (optional): Image | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Resume
 * - **Streaming Partial:** partial_types.Resume
 * - **Streaming Final:** Resume
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractResume({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExtractResume({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResume(props?: HookInput<'ExtractResume', { stream?: true }>): HookOutput<'ExtractResume', { stream: true }>
export function useExtractResume(props: HookInput<'ExtractResume', { stream: false }>): HookOutput<'ExtractResume', { stream: false }>
export function useExtractResume(
  props: HookInput<'ExtractResume', { stream?: boolean }> = {},
): HookOutput<'ExtractResume', { stream: true }> | HookOutput<'ExtractResume', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExtractResume, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExtractResume, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ExtractResume2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - resume: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Resume
 * - **Streaming Partial:** partial_types.Resume
 * - **Streaming Final:** Resume
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useExtractResume2({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useExtractResume2({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useExtractResume2(props?: HookInput<'ExtractResume2', { stream?: true }>): HookOutput<'ExtractResume2', { stream: true }>
export function useExtractResume2(props: HookInput<'ExtractResume2', { stream: false }>): HookOutput<'ExtractResume2', { stream: false }>
export function useExtractResume2(
  props: HookInput<'ExtractResume2', { stream?: boolean }> = {},
): HookOutput<'ExtractResume2', { stream: true }> | HookOutput<'ExtractResume2', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ExtractResume2, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ExtractResume2, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnClassOptionalOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassOptionalOutput | null
 * - **Streaming Partial:** ((partial_types.ClassOptionalOutput | null) | null)
 * - **Streaming Final:** ClassOptionalOutput | null
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnClassOptionalOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnClassOptionalOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnClassOptionalOutput(props?: HookInput<'FnClassOptionalOutput', { stream?: true }>): HookOutput<'FnClassOptionalOutput', { stream: true }>
export function useFnClassOptionalOutput(props: HookInput<'FnClassOptionalOutput', { stream: false }>): HookOutput<'FnClassOptionalOutput', { stream: false }>
export function useFnClassOptionalOutput(
  props: HookInput<'FnClassOptionalOutput', { stream?: boolean }> = {},
): HookOutput<'FnClassOptionalOutput', { stream: true }> | HookOutput<'FnClassOptionalOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnClassOptionalOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnClassOptionalOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnClassOptionalOutput2 BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassOptionalOutput2 | null
 * - **Streaming Partial:** ((partial_types.ClassOptionalOutput2 | null) | null)
 * - **Streaming Final:** ClassOptionalOutput2 | null
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnClassOptionalOutput2({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnClassOptionalOutput2({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnClassOptionalOutput2(props?: HookInput<'FnClassOptionalOutput2', { stream?: true }>): HookOutput<'FnClassOptionalOutput2', { stream: true }>
export function useFnClassOptionalOutput2(props: HookInput<'FnClassOptionalOutput2', { stream: false }>): HookOutput<'FnClassOptionalOutput2', { stream: false }>
export function useFnClassOptionalOutput2(
  props: HookInput<'FnClassOptionalOutput2', { stream?: boolean }> = {},
): HookOutput<'FnClassOptionalOutput2', { stream: true }> | HookOutput<'FnClassOptionalOutput2', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnClassOptionalOutput2, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnClassOptionalOutput2, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnEnumListOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** EnumOutput[]
 * - **Streaming Partial:** (EnumOutput | null)[]
 * - **Streaming Final:** EnumOutput[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnEnumListOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnEnumListOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnEnumListOutput(props?: HookInput<'FnEnumListOutput', { stream?: true }>): HookOutput<'FnEnumListOutput', { stream: true }>
export function useFnEnumListOutput(props: HookInput<'FnEnumListOutput', { stream: false }>): HookOutput<'FnEnumListOutput', { stream: false }>
export function useFnEnumListOutput(
  props: HookInput<'FnEnumListOutput', { stream?: boolean }> = {},
): HookOutput<'FnEnumListOutput', { stream: true }> | HookOutput<'FnEnumListOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnEnumListOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnEnumListOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnEnumOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** EnumOutput
 * - **Streaming Partial:** types.EnumOutput
 * - **Streaming Final:** EnumOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnEnumOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnEnumOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnEnumOutput(props?: HookInput<'FnEnumOutput', { stream?: true }>): HookOutput<'FnEnumOutput', { stream: true }>
export function useFnEnumOutput(props: HookInput<'FnEnumOutput', { stream: false }>): HookOutput<'FnEnumOutput', { stream: false }>
export function useFnEnumOutput(
  props: HookInput<'FnEnumOutput', { stream?: boolean }> = {},
): HookOutput<'FnEnumOutput', { stream: true }> | HookOutput<'FnEnumOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnEnumOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnEnumOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnLiteralClassInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: LiteralClassHello
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LiteralClassHello
 * - **Streaming Partial:** partial_types.LiteralClassHello
 * - **Streaming Final:** LiteralClassHello
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnLiteralClassInputOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnLiteralClassInputOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnLiteralClassInputOutput(props?: HookInput<'FnLiteralClassInputOutput', { stream?: true }>): HookOutput<'FnLiteralClassInputOutput', { stream: true }>
export function useFnLiteralClassInputOutput(props: HookInput<'FnLiteralClassInputOutput', { stream: false }>): HookOutput<'FnLiteralClassInputOutput', { stream: false }>
export function useFnLiteralClassInputOutput(
  props: HookInput<'FnLiteralClassInputOutput', { stream?: boolean }> = {},
): HookOutput<'FnLiteralClassInputOutput', { stream: true }> | HookOutput<'FnLiteralClassInputOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnLiteralClassInputOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnLiteralClassInputOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnLiteralUnionClassInputOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: LiteralClassOne | LiteralClassTwo
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** LiteralClassOne | LiteralClassTwo
 * - **Streaming Partial:** ((partial_types.LiteralClassOne | null) | (partial_types.LiteralClassTwo | null))
 * - **Streaming Final:** LiteralClassOne | LiteralClassTwo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnLiteralUnionClassInputOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnLiteralUnionClassInputOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnLiteralUnionClassInputOutput(props?: HookInput<'FnLiteralUnionClassInputOutput', { stream?: true }>): HookOutput<'FnLiteralUnionClassInputOutput', { stream: true }>
export function useFnLiteralUnionClassInputOutput(props: HookInput<'FnLiteralUnionClassInputOutput', { stream: false }>): HookOutput<'FnLiteralUnionClassInputOutput', { stream: false }>
export function useFnLiteralUnionClassInputOutput(
  props: HookInput<'FnLiteralUnionClassInputOutput', { stream?: boolean }> = {},
): HookOutput<'FnLiteralUnionClassInputOutput', { stream: true }> | HookOutput<'FnLiteralUnionClassInputOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnLiteralUnionClassInputOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnLiteralUnionClassInputOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnNamedArgsSingleStringOptional BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myString (optional): string | null
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnNamedArgsSingleStringOptional({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnNamedArgsSingleStringOptional({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnNamedArgsSingleStringOptional(props?: HookInput<'FnNamedArgsSingleStringOptional', { stream?: true }>): HookOutput<'FnNamedArgsSingleStringOptional', { stream: true }>
export function useFnNamedArgsSingleStringOptional(props: HookInput<'FnNamedArgsSingleStringOptional', { stream: false }>): HookOutput<'FnNamedArgsSingleStringOptional', { stream: false }>
export function useFnNamedArgsSingleStringOptional(
  props: HookInput<'FnNamedArgsSingleStringOptional', { stream?: boolean }> = {},
): HookOutput<'FnNamedArgsSingleStringOptional', { stream: true }> | HookOutput<'FnNamedArgsSingleStringOptional', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnNamedArgsSingleStringOptional, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnNamedArgsSingleStringOptional, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** boolean
 * - **Streaming Partial:** boolean
 * - **Streaming Final:** boolean
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputBool({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputBool({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputBool(props?: HookInput<'FnOutputBool', { stream?: true }>): HookOutput<'FnOutputBool', { stream: true }>
export function useFnOutputBool(props: HookInput<'FnOutputBool', { stream: false }>): HookOutput<'FnOutputBool', { stream: false }>
export function useFnOutputBool(
  props: HookInput<'FnOutputBool', { stream?: boolean }> = {},
): HookOutput<'FnOutputBool', { stream: true }> | HookOutput<'FnOutputBool', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputBool, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputBool, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestOutputClass
 * - **Streaming Partial:** partial_types.TestOutputClass
 * - **Streaming Final:** TestOutputClass
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClass({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputClass({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClass(props?: HookInput<'FnOutputClass', { stream?: true }>): HookOutput<'FnOutputClass', { stream: true }>
export function useFnOutputClass(props: HookInput<'FnOutputClass', { stream: false }>): HookOutput<'FnOutputClass', { stream: false }>
export function useFnOutputClass(
  props: HookInput<'FnOutputClass', { stream?: boolean }> = {},
): HookOutput<'FnOutputClass', { stream: true }> | HookOutput<'FnOutputClass', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputClass, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputClass, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputClassList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestOutputClass[]
 * - **Streaming Partial:** (partial_types.TestOutputClass | null)[]
 * - **Streaming Final:** TestOutputClass[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClassList({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputClassList({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClassList(props?: HookInput<'FnOutputClassList', { stream?: true }>): HookOutput<'FnOutputClassList', { stream: true }>
export function useFnOutputClassList(props: HookInput<'FnOutputClassList', { stream: false }>): HookOutput<'FnOutputClassList', { stream: false }>
export function useFnOutputClassList(
  props: HookInput<'FnOutputClassList', { stream?: boolean }> = {},
): HookOutput<'FnOutputClassList', { stream: true }> | HookOutput<'FnOutputClassList', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputClassList, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputClassList, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputClassNested BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestClassNested
 * - **Streaming Partial:** partial_types.TestClassNested
 * - **Streaming Final:** TestClassNested
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClassNested({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputClassNested({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClassNested(props?: HookInput<'FnOutputClassNested', { stream?: true }>): HookOutput<'FnOutputClassNested', { stream: true }>
export function useFnOutputClassNested(props: HookInput<'FnOutputClassNested', { stream: false }>): HookOutput<'FnOutputClassNested', { stream: false }>
export function useFnOutputClassNested(
  props: HookInput<'FnOutputClassNested', { stream?: boolean }> = {},
): HookOutput<'FnOutputClassNested', { stream: true }> | HookOutput<'FnOutputClassNested', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputClassNested, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputClassNested, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputClassWithEnum BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestClassWithEnum
 * - **Streaming Partial:** partial_types.TestClassWithEnum
 * - **Streaming Final:** TestClassWithEnum
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputClassWithEnum({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputClassWithEnum({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputClassWithEnum(props?: HookInput<'FnOutputClassWithEnum', { stream?: true }>): HookOutput<'FnOutputClassWithEnum', { stream: true }>
export function useFnOutputClassWithEnum(props: HookInput<'FnOutputClassWithEnum', { stream: false }>): HookOutput<'FnOutputClassWithEnum', { stream: false }>
export function useFnOutputClassWithEnum(
  props: HookInput<'FnOutputClassWithEnum', { stream?: boolean }> = {},
): HookOutput<'FnOutputClassWithEnum', { stream: true }> | HookOutput<'FnOutputClassWithEnum', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputClassWithEnum, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputClassWithEnum, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputInt({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputInt({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputInt(props?: HookInput<'FnOutputInt', { stream?: true }>): HookOutput<'FnOutputInt', { stream: true }>
export function useFnOutputInt(props: HookInput<'FnOutputInt', { stream: false }>): HookOutput<'FnOutputInt', { stream: false }>
export function useFnOutputInt(
  props: HookInput<'FnOutputInt', { stream?: boolean }> = {},
): HookOutput<'FnOutputInt', { stream: true }> | HookOutput<'FnOutputInt', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputInt, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputInt, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputLiteralBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** false
 * - **Streaming Partial:** false
 * - **Streaming Final:** false
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputLiteralBool({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputLiteralBool({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputLiteralBool(props?: HookInput<'FnOutputLiteralBool', { stream?: true }>): HookOutput<'FnOutputLiteralBool', { stream: true }>
export function useFnOutputLiteralBool(props: HookInput<'FnOutputLiteralBool', { stream: false }>): HookOutput<'FnOutputLiteralBool', { stream: false }>
export function useFnOutputLiteralBool(
  props: HookInput<'FnOutputLiteralBool', { stream?: boolean }> = {},
): HookOutput<'FnOutputLiteralBool', { stream: true }> | HookOutput<'FnOutputLiteralBool', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputLiteralBool, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputLiteralBool, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputLiteralInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** 5
 * - **Streaming Partial:** 5
 * - **Streaming Final:** 5
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputLiteralInt({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputLiteralInt({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputLiteralInt(props?: HookInput<'FnOutputLiteralInt', { stream?: true }>): HookOutput<'FnOutputLiteralInt', { stream: true }>
export function useFnOutputLiteralInt(props: HookInput<'FnOutputLiteralInt', { stream: false }>): HookOutput<'FnOutputLiteralInt', { stream: false }>
export function useFnOutputLiteralInt(
  props: HookInput<'FnOutputLiteralInt', { stream?: boolean }> = {},
): HookOutput<'FnOutputLiteralInt', { stream: true }> | HookOutput<'FnOutputLiteralInt', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputLiteralInt, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputLiteralInt, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputLiteralString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** "example output"
 * - **Streaming Partial:** "example output"
 * - **Streaming Final:** "example output"
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputLiteralString({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputLiteralString({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputLiteralString(props?: HookInput<'FnOutputLiteralString', { stream?: true }>): HookOutput<'FnOutputLiteralString', { stream: true }>
export function useFnOutputLiteralString(props: HookInput<'FnOutputLiteralString', { stream: false }>): HookOutput<'FnOutputLiteralString', { stream: false }>
export function useFnOutputLiteralString(
  props: HookInput<'FnOutputLiteralString', { stream?: boolean }> = {},
): HookOutput<'FnOutputLiteralString', { stream: true }> | HookOutput<'FnOutputLiteralString', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputLiteralString, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputLiteralString, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnOutputStringList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string[]
 * - **Streaming Partial:** (string | null)[]
 * - **Streaming Final:** string[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnOutputStringList({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnOutputStringList({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnOutputStringList(props?: HookInput<'FnOutputStringList', { stream?: true }>): HookOutput<'FnOutputStringList', { stream: true }>
export function useFnOutputStringList(props: HookInput<'FnOutputStringList', { stream: false }>): HookOutput<'FnOutputStringList', { stream: false }>
export function useFnOutputStringList(
  props: HookInput<'FnOutputStringList', { stream?: boolean }> = {},
): HookOutput<'FnOutputStringList', { stream: true }> | HookOutput<'FnOutputStringList', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnOutputStringList, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnOutputStringList, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnTestAliasedEnumOutput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestEnum
 * - **Streaming Partial:** types.TestEnum
 * - **Streaming Final:** TestEnum
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnTestAliasedEnumOutput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnTestAliasedEnumOutput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnTestAliasedEnumOutput(props?: HookInput<'FnTestAliasedEnumOutput', { stream?: true }>): HookOutput<'FnTestAliasedEnumOutput', { stream: true }>
export function useFnTestAliasedEnumOutput(props: HookInput<'FnTestAliasedEnumOutput', { stream: false }>): HookOutput<'FnTestAliasedEnumOutput', { stream: false }>
export function useFnTestAliasedEnumOutput(
  props: HookInput<'FnTestAliasedEnumOutput', { stream?: boolean }> = {},
): HookOutput<'FnTestAliasedEnumOutput', { stream: true }> | HookOutput<'FnTestAliasedEnumOutput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnTestAliasedEnumOutput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnTestAliasedEnumOutput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnTestClassAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestClassAlias
 * - **Streaming Partial:** partial_types.TestClassAlias
 * - **Streaming Final:** TestClassAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnTestClassAlias({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnTestClassAlias({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnTestClassAlias(props?: HookInput<'FnTestClassAlias', { stream?: true }>): HookOutput<'FnTestClassAlias', { stream: true }>
export function useFnTestClassAlias(props: HookInput<'FnTestClassAlias', { stream: false }>): HookOutput<'FnTestClassAlias', { stream: false }>
export function useFnTestClassAlias(
  props: HookInput<'FnTestClassAlias', { stream?: boolean }> = {},
): HookOutput<'FnTestClassAlias', { stream: true }> | HookOutput<'FnTestClassAlias', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnTestClassAlias, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnTestClassAlias, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the FnTestNamedArgsSingleEnum BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleEnum
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useFnTestNamedArgsSingleEnum({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useFnTestNamedArgsSingleEnum({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useFnTestNamedArgsSingleEnum(props?: HookInput<'FnTestNamedArgsSingleEnum', { stream?: true }>): HookOutput<'FnTestNamedArgsSingleEnum', { stream: true }>
export function useFnTestNamedArgsSingleEnum(props: HookInput<'FnTestNamedArgsSingleEnum', { stream: false }>): HookOutput<'FnTestNamedArgsSingleEnum', { stream: false }>
export function useFnTestNamedArgsSingleEnum(
  props: HookInput<'FnTestNamedArgsSingleEnum', { stream?: boolean }> = {},
): HookOutput<'FnTestNamedArgsSingleEnum', { stream: true }> | HookOutput<'FnTestNamedArgsSingleEnum', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.FnTestNamedArgsSingleEnum, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.FnTestNamedArgsSingleEnum, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the GetDataType BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - text: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RaysData
 * - **Streaming Partial:** partial_types.RaysData
 * - **Streaming Final:** RaysData
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGetDataType({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useGetDataType({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetDataType(props?: HookInput<'GetDataType', { stream?: true }>): HookOutput<'GetDataType', { stream: true }>
export function useGetDataType(props: HookInput<'GetDataType', { stream: false }>): HookOutput<'GetDataType', { stream: false }>
export function useGetDataType(
  props: HookInput<'GetDataType', { stream?: boolean }> = {},
): HookOutput<'GetDataType', { stream: true }> | HookOutput<'GetDataType', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.GetDataType, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.GetDataType, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the GetOrderInfo BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - email: Email
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** OrderInfo
 * - **Streaming Partial:** partial_types.OrderInfo
 * - **Streaming Final:** OrderInfo
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGetOrderInfo({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useGetOrderInfo({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetOrderInfo(props?: HookInput<'GetOrderInfo', { stream?: true }>): HookOutput<'GetOrderInfo', { stream: true }>
export function useGetOrderInfo(props: HookInput<'GetOrderInfo', { stream: false }>): HookOutput<'GetOrderInfo', { stream: false }>
export function useGetOrderInfo(
  props: HookInput<'GetOrderInfo', { stream?: boolean }> = {},
): HookOutput<'GetOrderInfo', { stream: true }> | HookOutput<'GetOrderInfo', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.GetOrderInfo, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.GetOrderInfo, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the GetQuery BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - query: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SearchParams
 * - **Streaming Partial:** partial_types.SearchParams
 * - **Streaming Final:** SearchParams
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useGetQuery({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useGetQuery({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useGetQuery(props?: HookInput<'GetQuery', { stream?: true }>): HookOutput<'GetQuery', { stream: true }>
export function useGetQuery(props: HookInput<'GetQuery', { stream: false }>): HookOutput<'GetQuery', { stream: false }>
export function useGetQuery(
  props: HookInput<'GetQuery', { stream?: boolean }> = {},
): HookOutput<'GetQuery', { stream: true }> | HookOutput<'GetQuery', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.GetQuery, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.GetQuery, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the InOutEnumMapKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - i1: Partial<Record<types.MapKey, string>>
 *
 * - i2: Partial<Record<types.MapKey, string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Partial<Record<types.MapKey, string>>
 * - **Streaming Partial:** (Record<MapKey, (string | null)> )
 * - **Streaming Final:** Partial<Record<types.MapKey, string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useInOutEnumMapKey({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useInOutEnumMapKey({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useInOutEnumMapKey(props?: HookInput<'InOutEnumMapKey', { stream?: true }>): HookOutput<'InOutEnumMapKey', { stream: true }>
export function useInOutEnumMapKey(props: HookInput<'InOutEnumMapKey', { stream: false }>): HookOutput<'InOutEnumMapKey', { stream: false }>
export function useInOutEnumMapKey(
  props: HookInput<'InOutEnumMapKey', { stream?: boolean }> = {},
): HookOutput<'InOutEnumMapKey', { stream: true }> | HookOutput<'InOutEnumMapKey', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.InOutEnumMapKey, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.InOutEnumMapKey, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the InOutLiteralStringUnionMapKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - i1: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * - i2: Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Partial<Record<"one" | "two" | "three" | "four", string>>
 * - **Streaming Partial:** (Record<"one" | "two" | "three" | "four", (string | null)> )
 * - **Streaming Final:** Partial<Record<"one" | "two" | "three" | "four", string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useInOutLiteralStringUnionMapKey({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useInOutLiteralStringUnionMapKey({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useInOutLiteralStringUnionMapKey(props?: HookInput<'InOutLiteralStringUnionMapKey', { stream?: true }>): HookOutput<'InOutLiteralStringUnionMapKey', { stream: true }>
export function useInOutLiteralStringUnionMapKey(props: HookInput<'InOutLiteralStringUnionMapKey', { stream: false }>): HookOutput<'InOutLiteralStringUnionMapKey', { stream: false }>
export function useInOutLiteralStringUnionMapKey(
  props: HookInput<'InOutLiteralStringUnionMapKey', { stream?: boolean }> = {},
): HookOutput<'InOutLiteralStringUnionMapKey', { stream: true }> | HookOutput<'InOutLiteralStringUnionMapKey', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.InOutLiteralStringUnionMapKey, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.InOutLiteralStringUnionMapKey, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the InOutSingleLiteralStringMapKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - m: Partial<Record<"key", string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Partial<Record<"key", string>>
 * - **Streaming Partial:** (Record<"key", (string | null)> )
 * - **Streaming Final:** Partial<Record<"key", string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useInOutSingleLiteralStringMapKey({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useInOutSingleLiteralStringMapKey({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useInOutSingleLiteralStringMapKey(props?: HookInput<'InOutSingleLiteralStringMapKey', { stream?: true }>): HookOutput<'InOutSingleLiteralStringMapKey', { stream: true }>
export function useInOutSingleLiteralStringMapKey(props: HookInput<'InOutSingleLiteralStringMapKey', { stream: false }>): HookOutput<'InOutSingleLiteralStringMapKey', { stream: false }>
export function useInOutSingleLiteralStringMapKey(
  props: HookInput<'InOutSingleLiteralStringMapKey', { stream?: boolean }> = {},
): HookOutput<'InOutSingleLiteralStringMapKey', { stream: true }> | HookOutput<'InOutSingleLiteralStringMapKey', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.InOutSingleLiteralStringMapKey, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.InOutSingleLiteralStringMapKey, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the JsonTypeAliasCycle BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: JsonValue
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** JsonValue
 * - **Streaming Partial:** JsonValue
 * - **Streaming Final:** JsonValue
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useJsonTypeAliasCycle({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useJsonTypeAliasCycle({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useJsonTypeAliasCycle(props?: HookInput<'JsonTypeAliasCycle', { stream?: true }>): HookOutput<'JsonTypeAliasCycle', { stream: true }>
export function useJsonTypeAliasCycle(props: HookInput<'JsonTypeAliasCycle', { stream: false }>): HookOutput<'JsonTypeAliasCycle', { stream: false }>
export function useJsonTypeAliasCycle(
  props: HookInput<'JsonTypeAliasCycle', { stream?: boolean }> = {},
): HookOutput<'JsonTypeAliasCycle', { stream: true }> | HookOutput<'JsonTypeAliasCycle', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.JsonTypeAliasCycle, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.JsonTypeAliasCycle, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the LiteralUnionsTest BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** 1 | true | "string output"
 * - **Streaming Partial:** (1 | true | "string output")
 * - **Streaming Final:** 1 | true | "string output"
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useLiteralUnionsTest({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useLiteralUnionsTest({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useLiteralUnionsTest(props?: HookInput<'LiteralUnionsTest', { stream?: true }>): HookOutput<'LiteralUnionsTest', { stream: true }>
export function useLiteralUnionsTest(props: HookInput<'LiteralUnionsTest', { stream: false }>): HookOutput<'LiteralUnionsTest', { stream: false }>
export function useLiteralUnionsTest(
  props: HookInput<'LiteralUnionsTest', { stream?: boolean }> = {},
): HookOutput<'LiteralUnionsTest', { stream: true }> | HookOutput<'LiteralUnionsTest', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.LiteralUnionsTest, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.LiteralUnionsTest, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the MakeBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<BlockConstraint,"cross_field">
 * - **Streaming Partial:** Checked<partial_types.BlockConstraint,"cross_field">
 * - **Streaming Final:** Checked<BlockConstraint,"cross_field">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMakeBlockConstraint({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useMakeBlockConstraint({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeBlockConstraint(props?: HookInput<'MakeBlockConstraint', { stream?: true }>): HookOutput<'MakeBlockConstraint', { stream: true }>
export function useMakeBlockConstraint(props: HookInput<'MakeBlockConstraint', { stream: false }>): HookOutput<'MakeBlockConstraint', { stream: false }>
export function useMakeBlockConstraint(
  props: HookInput<'MakeBlockConstraint', { stream?: boolean }> = {},
): HookOutput<'MakeBlockConstraint', { stream: true }> | HookOutput<'MakeBlockConstraint', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.MakeBlockConstraint, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.MakeBlockConstraint, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the MakeNestedBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** NestedBlockConstraint
 * - **Streaming Partial:** partial_types.NestedBlockConstraint
 * - **Streaming Final:** NestedBlockConstraint
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMakeNestedBlockConstraint({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useMakeNestedBlockConstraint({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeNestedBlockConstraint(props?: HookInput<'MakeNestedBlockConstraint', { stream?: true }>): HookOutput<'MakeNestedBlockConstraint', { stream: true }>
export function useMakeNestedBlockConstraint(props: HookInput<'MakeNestedBlockConstraint', { stream: false }>): HookOutput<'MakeNestedBlockConstraint', { stream: false }>
export function useMakeNestedBlockConstraint(
  props: HookInput<'MakeNestedBlockConstraint', { stream?: boolean }> = {},
): HookOutput<'MakeNestedBlockConstraint', { stream: true }> | HookOutput<'MakeNestedBlockConstraint', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.MakeNestedBlockConstraint, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.MakeNestedBlockConstraint, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the MakeSemanticContainer BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** SemanticContainer
 * - **Streaming Partial:** partial_types.SemanticContainer
 * - **Streaming Final:** SemanticContainer
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMakeSemanticContainer({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useMakeSemanticContainer({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMakeSemanticContainer(props?: HookInput<'MakeSemanticContainer', { stream?: true }>): HookOutput<'MakeSemanticContainer', { stream: true }>
export function useMakeSemanticContainer(props: HookInput<'MakeSemanticContainer', { stream: false }>): HookOutput<'MakeSemanticContainer', { stream: false }>
export function useMakeSemanticContainer(
  props: HookInput<'MakeSemanticContainer', { stream?: boolean }> = {},
): HookOutput<'MakeSemanticContainer', { stream: true }> | HookOutput<'MakeSemanticContainer', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.MakeSemanticContainer, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.MakeSemanticContainer, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the MapAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - m: Record<string, string[]>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, string[]>
 * - **Streaming Partial:** (Record<string, (string | null)[]> )
 * - **Streaming Final:** Record<string, string[]>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMapAlias({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useMapAlias({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMapAlias(props?: HookInput<'MapAlias', { stream?: true }>): HookOutput<'MapAlias', { stream: true }>
export function useMapAlias(props: HookInput<'MapAlias', { stream: false }>): HookOutput<'MapAlias', { stream: false }>
export function useMapAlias(
  props: HookInput<'MapAlias', { stream?: boolean }> = {},
): HookOutput<'MapAlias', { stream: true }> | HookOutput<'MapAlias', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.MapAlias, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.MapAlias, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the MergeAliasAttributes BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - money: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** MergeAttrs
 * - **Streaming Partial:** partial_types.MergeAttrs
 * - **Streaming Final:** MergeAttrs
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMergeAliasAttributes({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useMergeAliasAttributes({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMergeAliasAttributes(props?: HookInput<'MergeAliasAttributes', { stream?: true }>): HookOutput<'MergeAliasAttributes', { stream: true }>
export function useMergeAliasAttributes(props: HookInput<'MergeAliasAttributes', { stream: false }>): HookOutput<'MergeAliasAttributes', { stream: false }>
export function useMergeAliasAttributes(
  props: HookInput<'MergeAliasAttributes', { stream?: boolean }> = {},
): HookOutput<'MergeAliasAttributes', { stream: true }> | HookOutput<'MergeAliasAttributes', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.MergeAliasAttributes, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.MergeAliasAttributes, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the MyFunc BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** DynamicOutput
 * - **Streaming Partial:** partial_types.DynamicOutput
 * - **Streaming Final:** DynamicOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useMyFunc({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useMyFunc({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useMyFunc(props?: HookInput<'MyFunc', { stream?: true }>): HookOutput<'MyFunc', { stream: true }>
export function useMyFunc(props: HookInput<'MyFunc', { stream: false }>): HookOutput<'MyFunc', { stream: false }>
export function useMyFunc(
  props: HookInput<'MyFunc', { stream?: boolean }> = {},
): HookOutput<'MyFunc', { stream: true }> | HookOutput<'MyFunc', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.MyFunc, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.MyFunc, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the NestedAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - c: number | string | boolean | number | string[] | Record<string, string[]>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number | string | boolean | number | string[] | Record<string, string[]>
 * - **Streaming Partial:** (((number | null) | (string | null) | (boolean | null) | (number | null) | null) | (string | null)[] | (Record<string, (string | null)[]> | null))
 * - **Streaming Final:** number | string | boolean | number | string[] | Record<string, string[]>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useNestedAlias({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useNestedAlias({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useNestedAlias(props?: HookInput<'NestedAlias', { stream?: true }>): HookOutput<'NestedAlias', { stream: true }>
export function useNestedAlias(props: HookInput<'NestedAlias', { stream: false }>): HookOutput<'NestedAlias', { stream: false }>
export function useNestedAlias(
  props: HookInput<'NestedAlias', { stream?: boolean }> = {},
): HookOutput<'NestedAlias', { stream: true }> | HookOutput<'NestedAlias', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.NestedAlias, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.NestedAlias, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the NullLiteralClassHello BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - s: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** ClassForNullLiteral
 * - **Streaming Partial:** partial_types.ClassForNullLiteral
 * - **Streaming Final:** ClassForNullLiteral
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useNullLiteralClassHello({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useNullLiteralClassHello({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useNullLiteralClassHello(props?: HookInput<'NullLiteralClassHello', { stream?: true }>): HookOutput<'NullLiteralClassHello', { stream: true }>
export function useNullLiteralClassHello(props: HookInput<'NullLiteralClassHello', { stream: false }>): HookOutput<'NullLiteralClassHello', { stream: false }>
export function useNullLiteralClassHello(
  props: HookInput<'NullLiteralClassHello', { stream?: boolean }> = {},
): HookOutput<'NullLiteralClassHello', { stream: true }> | HookOutput<'NullLiteralClassHello', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.NullLiteralClassHello, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.NullLiteralClassHello, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the OptionalTest_Function BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (OptionalTest_ReturnType | null)[]
 * - **Streaming Partial:** ((partial_types.OptionalTest_ReturnType | null) | null)[]
 * - **Streaming Final:** (OptionalTest_ReturnType | null)[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useOptionalTest_Function({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useOptionalTest_Function({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useOptionalTest_Function(props?: HookInput<'OptionalTest_Function', { stream?: true }>): HookOutput<'OptionalTest_Function', { stream: true }>
export function useOptionalTest_Function(props: HookInput<'OptionalTest_Function', { stream: false }>): HookOutput<'OptionalTest_Function', { stream: false }>
export function useOptionalTest_Function(
  props: HookInput<'OptionalTest_Function', { stream?: boolean }> = {},
): HookOutput<'OptionalTest_Function', { stream: true }> | HookOutput<'OptionalTest_Function', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.OptionalTest_Function, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.OptionalTest_Function, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PredictAge BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - name: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** FooAny
 * - **Streaming Partial:** partial_types.FooAny
 * - **Streaming Final:** FooAny
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePredictAge({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePredictAge({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePredictAge(props?: HookInput<'PredictAge', { stream?: true }>): HookOutput<'PredictAge', { stream: true }>
export function usePredictAge(props: HookInput<'PredictAge', { stream: false }>): HookOutput<'PredictAge', { stream: false }>
export function usePredictAge(
  props: HookInput<'PredictAge', { stream?: boolean }> = {},
): HookOutput<'PredictAge', { stream: true }> | HookOutput<'PredictAge', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PredictAge, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PredictAge, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PredictAgeBare BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<number,"too_big">
 * - **Streaming Partial:** Checked<number,"too_big">
 * - **Streaming Final:** Checked<number,"too_big">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePredictAgeBare({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePredictAgeBare({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePredictAgeBare(props?: HookInput<'PredictAgeBare', { stream?: true }>): HookOutput<'PredictAgeBare', { stream: true }>
export function usePredictAgeBare(props: HookInput<'PredictAgeBare', { stream: false }>): HookOutput<'PredictAgeBare', { stream: false }>
export function usePredictAgeBare(
  props: HookInput<'PredictAgeBare', { stream?: boolean }> = {},
): HookOutput<'PredictAgeBare', { stream: true }> | HookOutput<'PredictAgeBare', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PredictAgeBare, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PredictAgeBare, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PrimitiveAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - p: number | string | boolean | number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number | string | boolean | number
 * - **Streaming Partial:** ((number | null) | (string | null) | (boolean | null) | (number | null))
 * - **Streaming Final:** number | string | boolean | number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePrimitiveAlias({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePrimitiveAlias({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePrimitiveAlias(props?: HookInput<'PrimitiveAlias', { stream?: true }>): HookOutput<'PrimitiveAlias', { stream: true }>
export function usePrimitiveAlias(props: HookInput<'PrimitiveAlias', { stream: false }>): HookOutput<'PrimitiveAlias', { stream: false }>
export function usePrimitiveAlias(
  props: HookInput<'PrimitiveAlias', { stream?: boolean }> = {},
): HookOutput<'PrimitiveAlias', { stream: true }> | HookOutput<'PrimitiveAlias', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PrimitiveAlias, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PrimitiveAlias, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PromptTestClaude BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestClaude({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePromptTestClaude({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestClaude(props?: HookInput<'PromptTestClaude', { stream?: true }>): HookOutput<'PromptTestClaude', { stream: true }>
export function usePromptTestClaude(props: HookInput<'PromptTestClaude', { stream: false }>): HookOutput<'PromptTestClaude', { stream: false }>
export function usePromptTestClaude(
  props: HookInput<'PromptTestClaude', { stream?: boolean }> = {},
): HookOutput<'PromptTestClaude', { stream: true }> | HookOutput<'PromptTestClaude', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PromptTestClaude, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PromptTestClaude, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PromptTestClaudeChat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestClaudeChat({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePromptTestClaudeChat({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestClaudeChat(props?: HookInput<'PromptTestClaudeChat', { stream?: true }>): HookOutput<'PromptTestClaudeChat', { stream: true }>
export function usePromptTestClaudeChat(props: HookInput<'PromptTestClaudeChat', { stream: false }>): HookOutput<'PromptTestClaudeChat', { stream: false }>
export function usePromptTestClaudeChat(
  props: HookInput<'PromptTestClaudeChat', { stream?: boolean }> = {},
): HookOutput<'PromptTestClaudeChat', { stream: true }> | HookOutput<'PromptTestClaudeChat', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PromptTestClaudeChat, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PromptTestClaudeChat, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PromptTestClaudeChatNoSystem BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestClaudeChatNoSystem({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePromptTestClaudeChatNoSystem({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestClaudeChatNoSystem(props?: HookInput<'PromptTestClaudeChatNoSystem', { stream?: true }>): HookOutput<'PromptTestClaudeChatNoSystem', { stream: true }>
export function usePromptTestClaudeChatNoSystem(props: HookInput<'PromptTestClaudeChatNoSystem', { stream: false }>): HookOutput<'PromptTestClaudeChatNoSystem', { stream: false }>
export function usePromptTestClaudeChatNoSystem(
  props: HookInput<'PromptTestClaudeChatNoSystem', { stream?: boolean }> = {},
): HookOutput<'PromptTestClaudeChatNoSystem', { stream: true }> | HookOutput<'PromptTestClaudeChatNoSystem', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PromptTestClaudeChatNoSystem, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PromptTestClaudeChatNoSystem, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PromptTestOpenAI BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestOpenAI({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePromptTestOpenAI({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestOpenAI(props?: HookInput<'PromptTestOpenAI', { stream?: true }>): HookOutput<'PromptTestOpenAI', { stream: true }>
export function usePromptTestOpenAI(props: HookInput<'PromptTestOpenAI', { stream: false }>): HookOutput<'PromptTestOpenAI', { stream: false }>
export function usePromptTestOpenAI(
  props: HookInput<'PromptTestOpenAI', { stream?: boolean }> = {},
): HookOutput<'PromptTestOpenAI', { stream: true }> | HookOutput<'PromptTestOpenAI', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PromptTestOpenAI, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PromptTestOpenAI, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PromptTestOpenAIChat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestOpenAIChat({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePromptTestOpenAIChat({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestOpenAIChat(props?: HookInput<'PromptTestOpenAIChat', { stream?: true }>): HookOutput<'PromptTestOpenAIChat', { stream: true }>
export function usePromptTestOpenAIChat(props: HookInput<'PromptTestOpenAIChat', { stream: false }>): HookOutput<'PromptTestOpenAIChat', { stream: false }>
export function usePromptTestOpenAIChat(
  props: HookInput<'PromptTestOpenAIChat', { stream?: boolean }> = {},
): HookOutput<'PromptTestOpenAIChat', { stream: true }> | HookOutput<'PromptTestOpenAIChat', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PromptTestOpenAIChat, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PromptTestOpenAIChat, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PromptTestOpenAIChatNoSystem BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestOpenAIChatNoSystem({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePromptTestOpenAIChatNoSystem({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestOpenAIChatNoSystem(props?: HookInput<'PromptTestOpenAIChatNoSystem', { stream?: true }>): HookOutput<'PromptTestOpenAIChatNoSystem', { stream: true }>
export function usePromptTestOpenAIChatNoSystem(props: HookInput<'PromptTestOpenAIChatNoSystem', { stream: false }>): HookOutput<'PromptTestOpenAIChatNoSystem', { stream: false }>
export function usePromptTestOpenAIChatNoSystem(
  props: HookInput<'PromptTestOpenAIChatNoSystem', { stream?: boolean }> = {},
): HookOutput<'PromptTestOpenAIChatNoSystem', { stream: true }> | HookOutput<'PromptTestOpenAIChatNoSystem', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PromptTestOpenAIChatNoSystem, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PromptTestOpenAIChatNoSystem, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the PromptTestStreaming BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = usePromptTestStreaming({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = usePromptTestStreaming({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function usePromptTestStreaming(props?: HookInput<'PromptTestStreaming', { stream?: true }>): HookOutput<'PromptTestStreaming', { stream: true }>
export function usePromptTestStreaming(props: HookInput<'PromptTestStreaming', { stream: false }>): HookOutput<'PromptTestStreaming', { stream: false }>
export function usePromptTestStreaming(
  props: HookInput<'PromptTestStreaming', { stream?: boolean }> = {},
): HookOutput<'PromptTestStreaming', { stream: true }> | HookOutput<'PromptTestStreaming', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.PromptTestStreaming, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.PromptTestStreaming, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the RecursiveAliasCycle BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecAliasOne
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecAliasOne
 * - **Streaming Partial:** RecAliasOne
 * - **Streaming Final:** RecAliasOne
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useRecursiveAliasCycle({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useRecursiveAliasCycle({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useRecursiveAliasCycle(props?: HookInput<'RecursiveAliasCycle', { stream?: true }>): HookOutput<'RecursiveAliasCycle', { stream: true }>
export function useRecursiveAliasCycle(props: HookInput<'RecursiveAliasCycle', { stream: false }>): HookOutput<'RecursiveAliasCycle', { stream: false }>
export function useRecursiveAliasCycle(
  props: HookInput<'RecursiveAliasCycle', { stream?: boolean }> = {},
): HookOutput<'RecursiveAliasCycle', { stream: true }> | HookOutput<'RecursiveAliasCycle', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.RecursiveAliasCycle, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.RecursiveAliasCycle, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the RecursiveClassWithAliasIndirection BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - cls: NodeWithAliasIndirection
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** NodeWithAliasIndirection
 * - **Streaming Partial:** partial_types.NodeWithAliasIndirection
 * - **Streaming Final:** NodeWithAliasIndirection
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useRecursiveClassWithAliasIndirection({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useRecursiveClassWithAliasIndirection({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useRecursiveClassWithAliasIndirection(props?: HookInput<'RecursiveClassWithAliasIndirection', { stream?: true }>): HookOutput<'RecursiveClassWithAliasIndirection', { stream: true }>
export function useRecursiveClassWithAliasIndirection(props: HookInput<'RecursiveClassWithAliasIndirection', { stream: false }>): HookOutput<'RecursiveClassWithAliasIndirection', { stream: false }>
export function useRecursiveClassWithAliasIndirection(
  props: HookInput<'RecursiveClassWithAliasIndirection', { stream?: boolean }> = {},
): HookOutput<'RecursiveClassWithAliasIndirection', { stream: true }> | HookOutput<'RecursiveClassWithAliasIndirection', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.RecursiveClassWithAliasIndirection, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.RecursiveClassWithAliasIndirection, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ReturnAliasWithMergedAttributes BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - money: Checked<number,"gt_ten">
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Checked<number,"gt_ten">
 * - **Streaming Partial:** Checked<number,"gt_ten">
 * - **Streaming Final:** Checked<number,"gt_ten">
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnAliasWithMergedAttributes({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useReturnAliasWithMergedAttributes({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnAliasWithMergedAttributes(props?: HookInput<'ReturnAliasWithMergedAttributes', { stream?: true }>): HookOutput<'ReturnAliasWithMergedAttributes', { stream: true }>
export function useReturnAliasWithMergedAttributes(props: HookInput<'ReturnAliasWithMergedAttributes', { stream: false }>): HookOutput<'ReturnAliasWithMergedAttributes', { stream: false }>
export function useReturnAliasWithMergedAttributes(
  props: HookInput<'ReturnAliasWithMergedAttributes', { stream?: boolean }> = {},
): HookOutput<'ReturnAliasWithMergedAttributes', { stream: true }> | HookOutput<'ReturnAliasWithMergedAttributes', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ReturnAliasWithMergedAttributes, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ReturnAliasWithMergedAttributes, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ReturnFailingAssert BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnFailingAssert({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useReturnFailingAssert({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnFailingAssert(props?: HookInput<'ReturnFailingAssert', { stream?: true }>): HookOutput<'ReturnFailingAssert', { stream: true }>
export function useReturnFailingAssert(props: HookInput<'ReturnFailingAssert', { stream: false }>): HookOutput<'ReturnFailingAssert', { stream: false }>
export function useReturnFailingAssert(
  props: HookInput<'ReturnFailingAssert', { stream?: boolean }> = {},
): HookOutput<'ReturnFailingAssert', { stream: true }> | HookOutput<'ReturnFailingAssert', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ReturnFailingAssert, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ReturnFailingAssert, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ReturnJsonEntry BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - s: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** JsonTemplate
 * - **Streaming Partial:** JsonTemplate
 * - **Streaming Final:** JsonTemplate
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnJsonEntry({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useReturnJsonEntry({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnJsonEntry(props?: HookInput<'ReturnJsonEntry', { stream?: true }>): HookOutput<'ReturnJsonEntry', { stream: true }>
export function useReturnJsonEntry(props: HookInput<'ReturnJsonEntry', { stream: false }>): HookOutput<'ReturnJsonEntry', { stream: false }>
export function useReturnJsonEntry(
  props: HookInput<'ReturnJsonEntry', { stream?: boolean }> = {},
): HookOutput<'ReturnJsonEntry', { stream: true }> | HookOutput<'ReturnJsonEntry', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ReturnJsonEntry, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ReturnJsonEntry, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the ReturnMalformedConstraints BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - a: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** MalformedConstraints
 * - **Streaming Partial:** partial_types.MalformedConstraints
 * - **Streaming Final:** MalformedConstraints
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useReturnMalformedConstraints({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useReturnMalformedConstraints({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useReturnMalformedConstraints(props?: HookInput<'ReturnMalformedConstraints', { stream?: true }>): HookOutput<'ReturnMalformedConstraints', { stream: true }>
export function useReturnMalformedConstraints(props: HookInput<'ReturnMalformedConstraints', { stream: false }>): HookOutput<'ReturnMalformedConstraints', { stream: false }>
export function useReturnMalformedConstraints(
  props: HookInput<'ReturnMalformedConstraints', { stream?: boolean }> = {},
): HookOutput<'ReturnMalformedConstraints', { stream: true }> | HookOutput<'ReturnMalformedConstraints', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.ReturnMalformedConstraints, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.ReturnMalformedConstraints, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the SchemaDescriptions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Schema
 * - **Streaming Partial:** partial_types.Schema
 * - **Streaming Final:** Schema
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useSchemaDescriptions({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useSchemaDescriptions({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSchemaDescriptions(props?: HookInput<'SchemaDescriptions', { stream?: true }>): HookOutput<'SchemaDescriptions', { stream: true }>
export function useSchemaDescriptions(props: HookInput<'SchemaDescriptions', { stream: false }>): HookOutput<'SchemaDescriptions', { stream: false }>
export function useSchemaDescriptions(
  props: HookInput<'SchemaDescriptions', { stream?: boolean }> = {},
): HookOutput<'SchemaDescriptions', { stream: true }> | HookOutput<'SchemaDescriptions', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.SchemaDescriptions, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.SchemaDescriptions, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the SimpleRecursiveListAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecursiveListAlias
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecursiveListAlias
 * - **Streaming Partial:** RecursiveListAlias
 * - **Streaming Final:** RecursiveListAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useSimpleRecursiveListAlias({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useSimpleRecursiveListAlias({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSimpleRecursiveListAlias(props?: HookInput<'SimpleRecursiveListAlias', { stream?: true }>): HookOutput<'SimpleRecursiveListAlias', { stream: true }>
export function useSimpleRecursiveListAlias(props: HookInput<'SimpleRecursiveListAlias', { stream: false }>): HookOutput<'SimpleRecursiveListAlias', { stream: false }>
export function useSimpleRecursiveListAlias(
  props: HookInput<'SimpleRecursiveListAlias', { stream?: boolean }> = {},
): HookOutput<'SimpleRecursiveListAlias', { stream: true }> | HookOutput<'SimpleRecursiveListAlias', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.SimpleRecursiveListAlias, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.SimpleRecursiveListAlias, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the SimpleRecursiveMapAlias BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecursiveMapAlias
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecursiveMapAlias
 * - **Streaming Partial:** RecursiveMapAlias
 * - **Streaming Final:** RecursiveMapAlias
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useSimpleRecursiveMapAlias({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useSimpleRecursiveMapAlias({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useSimpleRecursiveMapAlias(props?: HookInput<'SimpleRecursiveMapAlias', { stream?: true }>): HookOutput<'SimpleRecursiveMapAlias', { stream: true }>
export function useSimpleRecursiveMapAlias(props: HookInput<'SimpleRecursiveMapAlias', { stream: false }>): HookOutput<'SimpleRecursiveMapAlias', { stream: false }>
export function useSimpleRecursiveMapAlias(
  props: HookInput<'SimpleRecursiveMapAlias', { stream?: boolean }> = {},
): HookOutput<'SimpleRecursiveMapAlias', { stream: true }> | HookOutput<'SimpleRecursiveMapAlias', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.SimpleRecursiveMapAlias, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.SimpleRecursiveMapAlias, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the StreamBigNumbers BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** BigNumbers
 * - **Streaming Partial:** partial_types.BigNumbers
 * - **Streaming Final:** BigNumbers
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamBigNumbers({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useStreamBigNumbers({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamBigNumbers(props?: HookInput<'StreamBigNumbers', { stream?: true }>): HookOutput<'StreamBigNumbers', { stream: true }>
export function useStreamBigNumbers(props: HookInput<'StreamBigNumbers', { stream: false }>): HookOutput<'StreamBigNumbers', { stream: false }>
export function useStreamBigNumbers(
  props: HookInput<'StreamBigNumbers', { stream?: boolean }> = {},
): HookOutput<'StreamBigNumbers', { stream: true }> | HookOutput<'StreamBigNumbers', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.StreamBigNumbers, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.StreamBigNumbers, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the StreamFailingAssertion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - theme: string
 *
 * - length: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TwoStoriesOneTitle
 * - **Streaming Partial:** partial_types.TwoStoriesOneTitle
 * - **Streaming Final:** TwoStoriesOneTitle
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamFailingAssertion({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useStreamFailingAssertion({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamFailingAssertion(props?: HookInput<'StreamFailingAssertion', { stream?: true }>): HookOutput<'StreamFailingAssertion', { stream: true }>
export function useStreamFailingAssertion(props: HookInput<'StreamFailingAssertion', { stream: false }>): HookOutput<'StreamFailingAssertion', { stream: false }>
export function useStreamFailingAssertion(
  props: HookInput<'StreamFailingAssertion', { stream?: boolean }> = {},
): HookOutput<'StreamFailingAssertion', { stream: true }> | HookOutput<'StreamFailingAssertion', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.StreamFailingAssertion, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.StreamFailingAssertion, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the StreamOneBigNumber BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamOneBigNumber({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useStreamOneBigNumber({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamOneBigNumber(props?: HookInput<'StreamOneBigNumber', { stream?: true }>): HookOutput<'StreamOneBigNumber', { stream: true }>
export function useStreamOneBigNumber(props: HookInput<'StreamOneBigNumber', { stream: false }>): HookOutput<'StreamOneBigNumber', { stream: false }>
export function useStreamOneBigNumber(
  props: HookInput<'StreamOneBigNumber', { stream?: boolean }> = {},
): HookOutput<'StreamOneBigNumber', { stream: true }> | HookOutput<'StreamOneBigNumber', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.StreamOneBigNumber, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.StreamOneBigNumber, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the StreamUnionIntegers BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** (number | string)[]
 * - **Streaming Partial:** ((number | null) | (string | null) | null)[]
 * - **Streaming Final:** (number | string)[]
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamUnionIntegers({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useStreamUnionIntegers({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamUnionIntegers(props?: HookInput<'StreamUnionIntegers', { stream?: true }>): HookOutput<'StreamUnionIntegers', { stream: true }>
export function useStreamUnionIntegers(props: HookInput<'StreamUnionIntegers', { stream: false }>): HookOutput<'StreamUnionIntegers', { stream: false }>
export function useStreamUnionIntegers(
  props: HookInput<'StreamUnionIntegers', { stream?: boolean }> = {},
): HookOutput<'StreamUnionIntegers', { stream: true }> | HookOutput<'StreamUnionIntegers', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.StreamUnionIntegers, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.StreamUnionIntegers, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the StreamingCompoundNumbers BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - digits: number
 *
 * - yapping: boolean
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** CompoundBigNumbers
 * - **Streaming Partial:** partial_types.CompoundBigNumbers
 * - **Streaming Final:** CompoundBigNumbers
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useStreamingCompoundNumbers({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useStreamingCompoundNumbers({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useStreamingCompoundNumbers(props?: HookInput<'StreamingCompoundNumbers', { stream?: true }>): HookOutput<'StreamingCompoundNumbers', { stream: true }>
export function useStreamingCompoundNumbers(props: HookInput<'StreamingCompoundNumbers', { stream: false }>): HookOutput<'StreamingCompoundNumbers', { stream: false }>
export function useStreamingCompoundNumbers(
  props: HookInput<'StreamingCompoundNumbers', { stream?: boolean }> = {},
): HookOutput<'StreamingCompoundNumbers', { stream: true }> | HookOutput<'StreamingCompoundNumbers', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.StreamingCompoundNumbers, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.StreamingCompoundNumbers, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TakeRecAliasDep BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: RecursiveAliasDependency
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** RecursiveAliasDependency
 * - **Streaming Partial:** partial_types.RecursiveAliasDependency
 * - **Streaming Final:** RecursiveAliasDependency
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTakeRecAliasDep({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTakeRecAliasDep({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTakeRecAliasDep(props?: HookInput<'TakeRecAliasDep', { stream?: true }>): HookOutput<'TakeRecAliasDep', { stream: true }>
export function useTakeRecAliasDep(props: HookInput<'TakeRecAliasDep', { stream: false }>): HookOutput<'TakeRecAliasDep', { stream: false }>
export function useTakeRecAliasDep(
  props: HookInput<'TakeRecAliasDep', { stream?: boolean }> = {},
): HookOutput<'TakeRecAliasDep', { stream: true }> | HookOutput<'TakeRecAliasDep', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TakeRecAliasDep, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TakeRecAliasDep, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAnthropic BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAnthropic({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAnthropic({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAnthropic(props?: HookInput<'TestAnthropic', { stream?: true }>): HookOutput<'TestAnthropic', { stream: true }>
export function useTestAnthropic(props: HookInput<'TestAnthropic', { stream: false }>): HookOutput<'TestAnthropic', { stream: false }>
export function useTestAnthropic(
  props: HookInput<'TestAnthropic', { stream?: boolean }> = {},
): HookOutput<'TestAnthropic', { stream: true }> | HookOutput<'TestAnthropic', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAnthropic, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAnthropic, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAnthropicShorthand BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAnthropicShorthand({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAnthropicShorthand({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAnthropicShorthand(props?: HookInput<'TestAnthropicShorthand', { stream?: true }>): HookOutput<'TestAnthropicShorthand', { stream: true }>
export function useTestAnthropicShorthand(props: HookInput<'TestAnthropicShorthand', { stream: false }>): HookOutput<'TestAnthropicShorthand', { stream: false }>
export function useTestAnthropicShorthand(
  props: HookInput<'TestAnthropicShorthand', { stream?: boolean }> = {},
): HookOutput<'TestAnthropicShorthand', { stream: true }> | HookOutput<'TestAnthropicShorthand', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAnthropicShorthand, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAnthropicShorthand, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAws BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAws({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAws({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAws(props?: HookInput<'TestAws', { stream?: true }>): HookOutput<'TestAws', { stream: true }>
export function useTestAws(props: HookInput<'TestAws', { stream: false }>): HookOutput<'TestAws', { stream: false }>
export function useTestAws(
  props: HookInput<'TestAws', { stream?: boolean }> = {},
): HookOutput<'TestAws', { stream: true }> | HookOutput<'TestAws', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAws, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAws, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAwsInvalidAccessKey BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidAccessKey({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAwsInvalidAccessKey({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidAccessKey(props?: HookInput<'TestAwsInvalidAccessKey', { stream?: true }>): HookOutput<'TestAwsInvalidAccessKey', { stream: true }>
export function useTestAwsInvalidAccessKey(props: HookInput<'TestAwsInvalidAccessKey', { stream: false }>): HookOutput<'TestAwsInvalidAccessKey', { stream: false }>
export function useTestAwsInvalidAccessKey(
  props: HookInput<'TestAwsInvalidAccessKey', { stream?: boolean }> = {},
): HookOutput<'TestAwsInvalidAccessKey', { stream: true }> | HookOutput<'TestAwsInvalidAccessKey', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAwsInvalidAccessKey, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAwsInvalidAccessKey, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAwsInvalidProfile BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidProfile({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAwsInvalidProfile({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidProfile(props?: HookInput<'TestAwsInvalidProfile', { stream?: true }>): HookOutput<'TestAwsInvalidProfile', { stream: true }>
export function useTestAwsInvalidProfile(props: HookInput<'TestAwsInvalidProfile', { stream: false }>): HookOutput<'TestAwsInvalidProfile', { stream: false }>
export function useTestAwsInvalidProfile(
  props: HookInput<'TestAwsInvalidProfile', { stream?: boolean }> = {},
): HookOutput<'TestAwsInvalidProfile', { stream: true }> | HookOutput<'TestAwsInvalidProfile', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAwsInvalidProfile, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAwsInvalidProfile, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAwsInvalidRegion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidRegion({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAwsInvalidRegion({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidRegion(props?: HookInput<'TestAwsInvalidRegion', { stream?: true }>): HookOutput<'TestAwsInvalidRegion', { stream: true }>
export function useTestAwsInvalidRegion(props: HookInput<'TestAwsInvalidRegion', { stream: false }>): HookOutput<'TestAwsInvalidRegion', { stream: false }>
export function useTestAwsInvalidRegion(
  props: HookInput<'TestAwsInvalidRegion', { stream?: boolean }> = {},
): HookOutput<'TestAwsInvalidRegion', { stream: true }> | HookOutput<'TestAwsInvalidRegion', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAwsInvalidRegion, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAwsInvalidRegion, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAwsInvalidSessionToken BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAwsInvalidSessionToken({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAwsInvalidSessionToken({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAwsInvalidSessionToken(props?: HookInput<'TestAwsInvalidSessionToken', { stream?: true }>): HookOutput<'TestAwsInvalidSessionToken', { stream: true }>
export function useTestAwsInvalidSessionToken(props: HookInput<'TestAwsInvalidSessionToken', { stream: false }>): HookOutput<'TestAwsInvalidSessionToken', { stream: false }>
export function useTestAwsInvalidSessionToken(
  props: HookInput<'TestAwsInvalidSessionToken', { stream?: boolean }> = {},
): HookOutput<'TestAwsInvalidSessionToken', { stream: true }> | HookOutput<'TestAwsInvalidSessionToken', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAwsInvalidSessionToken, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAwsInvalidSessionToken, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzure({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzure({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzure(props?: HookInput<'TestAzure', { stream?: true }>): HookOutput<'TestAzure', { stream: true }>
export function useTestAzure(props: HookInput<'TestAzure', { stream: false }>): HookOutput<'TestAzure', { stream: false }>
export function useTestAzure(
  props: HookInput<'TestAzure', { stream?: boolean }> = {},
): HookOutput<'TestAzure', { stream: true }> | HookOutput<'TestAzure', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzure, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzure, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzureFailure BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureFailure({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzureFailure({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureFailure(props?: HookInput<'TestAzureFailure', { stream?: true }>): HookOutput<'TestAzureFailure', { stream: true }>
export function useTestAzureFailure(props: HookInput<'TestAzureFailure', { stream: false }>): HookOutput<'TestAzureFailure', { stream: false }>
export function useTestAzureFailure(
  props: HookInput<'TestAzureFailure', { stream?: boolean }> = {},
): HookOutput<'TestAzureFailure', { stream: true }> | HookOutput<'TestAzureFailure', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzureFailure, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzureFailure, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzureO1NoMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO1NoMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzureO1NoMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO1NoMaxTokens(props?: HookInput<'TestAzureO1NoMaxTokens', { stream?: true }>): HookOutput<'TestAzureO1NoMaxTokens', { stream: true }>
export function useTestAzureO1NoMaxTokens(props: HookInput<'TestAzureO1NoMaxTokens', { stream: false }>): HookOutput<'TestAzureO1NoMaxTokens', { stream: false }>
export function useTestAzureO1NoMaxTokens(
  props: HookInput<'TestAzureO1NoMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestAzureO1NoMaxTokens', { stream: true }> | HookOutput<'TestAzureO1NoMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzureO1NoMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzureO1NoMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzureO1WithMaxCompletionTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO1WithMaxCompletionTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzureO1WithMaxCompletionTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO1WithMaxCompletionTokens(props?: HookInput<'TestAzureO1WithMaxCompletionTokens', { stream?: true }>): HookOutput<'TestAzureO1WithMaxCompletionTokens', { stream: true }>
export function useTestAzureO1WithMaxCompletionTokens(props: HookInput<'TestAzureO1WithMaxCompletionTokens', { stream: false }>): HookOutput<'TestAzureO1WithMaxCompletionTokens', { stream: false }>
export function useTestAzureO1WithMaxCompletionTokens(
  props: HookInput<'TestAzureO1WithMaxCompletionTokens', { stream?: boolean }> = {},
): HookOutput<'TestAzureO1WithMaxCompletionTokens', { stream: true }> | HookOutput<'TestAzureO1WithMaxCompletionTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzureO1WithMaxCompletionTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzureO1WithMaxCompletionTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzureO1WithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO1WithMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzureO1WithMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO1WithMaxTokens(props?: HookInput<'TestAzureO1WithMaxTokens', { stream?: true }>): HookOutput<'TestAzureO1WithMaxTokens', { stream: true }>
export function useTestAzureO1WithMaxTokens(props: HookInput<'TestAzureO1WithMaxTokens', { stream: false }>): HookOutput<'TestAzureO1WithMaxTokens', { stream: false }>
export function useTestAzureO1WithMaxTokens(
  props: HookInput<'TestAzureO1WithMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestAzureO1WithMaxTokens', { stream: true }> | HookOutput<'TestAzureO1WithMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzureO1WithMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzureO1WithMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzureO3NoMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO3NoMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzureO3NoMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO3NoMaxTokens(props?: HookInput<'TestAzureO3NoMaxTokens', { stream?: true }>): HookOutput<'TestAzureO3NoMaxTokens', { stream: true }>
export function useTestAzureO3NoMaxTokens(props: HookInput<'TestAzureO3NoMaxTokens', { stream: false }>): HookOutput<'TestAzureO3NoMaxTokens', { stream: false }>
export function useTestAzureO3NoMaxTokens(
  props: HookInput<'TestAzureO3NoMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestAzureO3NoMaxTokens', { stream: true }> | HookOutput<'TestAzureO3NoMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzureO3NoMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzureO3NoMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzureO3WithMaxCompletionTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureO3WithMaxCompletionTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzureO3WithMaxCompletionTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureO3WithMaxCompletionTokens(props?: HookInput<'TestAzureO3WithMaxCompletionTokens', { stream?: true }>): HookOutput<'TestAzureO3WithMaxCompletionTokens', { stream: true }>
export function useTestAzureO3WithMaxCompletionTokens(props: HookInput<'TestAzureO3WithMaxCompletionTokens', { stream: false }>): HookOutput<'TestAzureO3WithMaxCompletionTokens', { stream: false }>
export function useTestAzureO3WithMaxCompletionTokens(
  props: HookInput<'TestAzureO3WithMaxCompletionTokens', { stream?: boolean }> = {},
): HookOutput<'TestAzureO3WithMaxCompletionTokens', { stream: true }> | HookOutput<'TestAzureO3WithMaxCompletionTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzureO3WithMaxCompletionTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzureO3WithMaxCompletionTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestAzureWithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestAzureWithMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestAzureWithMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestAzureWithMaxTokens(props?: HookInput<'TestAzureWithMaxTokens', { stream?: true }>): HookOutput<'TestAzureWithMaxTokens', { stream: true }>
export function useTestAzureWithMaxTokens(props: HookInput<'TestAzureWithMaxTokens', { stream: false }>): HookOutput<'TestAzureWithMaxTokens', { stream: false }>
export function useTestAzureWithMaxTokens(
  props: HookInput<'TestAzureWithMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestAzureWithMaxTokens', { stream: true }> | HookOutput<'TestAzureWithMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestAzureWithMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestAzureWithMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestCaching BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 * - not_cached: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestCaching({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestCaching({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestCaching(props?: HookInput<'TestCaching', { stream?: true }>): HookOutput<'TestCaching', { stream: true }>
export function useTestCaching(props: HookInput<'TestCaching', { stream: false }>): HookOutput<'TestCaching', { stream: false }>
export function useTestCaching(
  props: HookInput<'TestCaching', { stream?: boolean }> = {},
): HookOutput<'TestCaching', { stream: true }> | HookOutput<'TestCaching', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestCaching, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestCaching, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFallbackClient BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFallbackClient({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFallbackClient({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFallbackClient(props?: HookInput<'TestFallbackClient', { stream?: true }>): HookOutput<'TestFallbackClient', { stream: true }>
export function useTestFallbackClient(props: HookInput<'TestFallbackClient', { stream: false }>): HookOutput<'TestFallbackClient', { stream: false }>
export function useTestFallbackClient(
  props: HookInput<'TestFallbackClient', { stream?: boolean }> = {},
): HookOutput<'TestFallbackClient', { stream: true }> | HookOutput<'TestFallbackClient', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFallbackClient, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFallbackClient, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFallbackToShorthand BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFallbackToShorthand({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFallbackToShorthand({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFallbackToShorthand(props?: HookInput<'TestFallbackToShorthand', { stream?: true }>): HookOutput<'TestFallbackToShorthand', { stream: true }>
export function useTestFallbackToShorthand(props: HookInput<'TestFallbackToShorthand', { stream: false }>): HookOutput<'TestFallbackToShorthand', { stream: false }>
export function useTestFallbackToShorthand(
  props: HookInput<'TestFallbackToShorthand', { stream?: boolean }> = {},
): HookOutput<'TestFallbackToShorthand', { stream: true }> | HookOutput<'TestFallbackToShorthand', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFallbackToShorthand, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFallbackToShorthand, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myBool: boolean
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleBool({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleBool({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleBool(props?: HookInput<'TestFnNamedArgsSingleBool', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleBool', { stream: true }>
export function useTestFnNamedArgsSingleBool(props: HookInput<'TestFnNamedArgsSingleBool', { stream: false }>): HookOutput<'TestFnNamedArgsSingleBool', { stream: false }>
export function useTestFnNamedArgsSingleBool(
  props: HookInput<'TestFnNamedArgsSingleBool', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleBool', { stream: true }> | HookOutput<'TestFnNamedArgsSingleBool', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleBool, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleBool, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleClass({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleClass({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleClass(props?: HookInput<'TestFnNamedArgsSingleClass', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleClass', { stream: true }>
export function useTestFnNamedArgsSingleClass(props: HookInput<'TestFnNamedArgsSingleClass', { stream: false }>): HookOutput<'TestFnNamedArgsSingleClass', { stream: false }>
export function useTestFnNamedArgsSingleClass(
  props: HookInput<'TestFnNamedArgsSingleClass', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleClass', { stream: true }> | HookOutput<'TestFnNamedArgsSingleClass', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleClass, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleClass, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleEnumList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleEnumList[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleEnumList({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleEnumList({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleEnumList(props?: HookInput<'TestFnNamedArgsSingleEnumList', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleEnumList', { stream: true }>
export function useTestFnNamedArgsSingleEnumList(props: HookInput<'TestFnNamedArgsSingleEnumList', { stream: false }>): HookOutput<'TestFnNamedArgsSingleEnumList', { stream: false }>
export function useTestFnNamedArgsSingleEnumList(
  props: HookInput<'TestFnNamedArgsSingleEnumList', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleEnumList', { stream: true }> | HookOutput<'TestFnNamedArgsSingleEnumList', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleEnumList, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleEnumList, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleFloat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myFloat: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleFloat({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleFloat({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleFloat(props?: HookInput<'TestFnNamedArgsSingleFloat', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleFloat', { stream: true }>
export function useTestFnNamedArgsSingleFloat(props: HookInput<'TestFnNamedArgsSingleFloat', { stream: false }>): HookOutput<'TestFnNamedArgsSingleFloat', { stream: false }>
export function useTestFnNamedArgsSingleFloat(
  props: HookInput<'TestFnNamedArgsSingleFloat', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleFloat', { stream: true }> | HookOutput<'TestFnNamedArgsSingleFloat', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleFloat, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleFloat, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myInt: number
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleInt({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleInt({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleInt(props?: HookInput<'TestFnNamedArgsSingleInt', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleInt', { stream: true }>
export function useTestFnNamedArgsSingleInt(props: HookInput<'TestFnNamedArgsSingleInt', { stream: false }>): HookOutput<'TestFnNamedArgsSingleInt', { stream: false }>
export function useTestFnNamedArgsSingleInt(
  props: HookInput<'TestFnNamedArgsSingleInt', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleInt', { stream: true }> | HookOutput<'TestFnNamedArgsSingleInt', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleInt, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleInt, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToClass BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myMap: Record<string, StringToClassEntry>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, StringToClassEntry>
 * - **Streaming Partial:** (Record<string, (partial_types.StringToClassEntry | null)> )
 * - **Streaming Final:** Record<string, StringToClassEntry>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleMapStringToClass({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleMapStringToClass({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToClass(props?: HookInput<'TestFnNamedArgsSingleMapStringToClass', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleMapStringToClass', { stream: true }>
export function useTestFnNamedArgsSingleMapStringToClass(props: HookInput<'TestFnNamedArgsSingleMapStringToClass', { stream: false }>): HookOutput<'TestFnNamedArgsSingleMapStringToClass', { stream: false }>
export function useTestFnNamedArgsSingleMapStringToClass(
  props: HookInput<'TestFnNamedArgsSingleMapStringToClass', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleMapStringToClass', { stream: true }> | HookOutput<'TestFnNamedArgsSingleMapStringToClass', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleMapStringToClass, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleMapStringToClass, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToMap BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myMap: Record<string, Record<string, string>>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, Record<string, string>>
 * - **Streaming Partial:** (Record<string, (Record<string, (string | null)> | null)> )
 * - **Streaming Final:** Record<string, Record<string, string>>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleMapStringToMap({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleMapStringToMap({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToMap(props?: HookInput<'TestFnNamedArgsSingleMapStringToMap', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleMapStringToMap', { stream: true }>
export function useTestFnNamedArgsSingleMapStringToMap(props: HookInput<'TestFnNamedArgsSingleMapStringToMap', { stream: false }>): HookOutput<'TestFnNamedArgsSingleMapStringToMap', { stream: false }>
export function useTestFnNamedArgsSingleMapStringToMap(
  props: HookInput<'TestFnNamedArgsSingleMapStringToMap', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleMapStringToMap', { stream: true }> | HookOutput<'TestFnNamedArgsSingleMapStringToMap', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleMapStringToMap, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleMapStringToMap, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleMapStringToString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myMap: Record<string, string>
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** Record<string, string>
 * - **Streaming Partial:** (Record<string, (string | null)> )
 * - **Streaming Final:** Record<string, string>
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleMapStringToString({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleMapStringToString({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleMapStringToString(props?: HookInput<'TestFnNamedArgsSingleMapStringToString', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleMapStringToString', { stream: true }>
export function useTestFnNamedArgsSingleMapStringToString(props: HookInput<'TestFnNamedArgsSingleMapStringToString', { stream: false }>): HookOutput<'TestFnNamedArgsSingleMapStringToString', { stream: false }>
export function useTestFnNamedArgsSingleMapStringToString(
  props: HookInput<'TestFnNamedArgsSingleMapStringToString', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleMapStringToString', { stream: true }> | HookOutput<'TestFnNamedArgsSingleMapStringToString', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleMapStringToString, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleMapStringToString, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myString: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleString({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleString({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleString(props?: HookInput<'TestFnNamedArgsSingleString', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleString', { stream: true }>
export function useTestFnNamedArgsSingleString(props: HookInput<'TestFnNamedArgsSingleString', { stream: false }>): HookOutput<'TestFnNamedArgsSingleString', { stream: false }>
export function useTestFnNamedArgsSingleString(
  props: HookInput<'TestFnNamedArgsSingleString', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleString', { stream: true }> | HookOutput<'TestFnNamedArgsSingleString', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleString, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleString, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleStringArray BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myStringArray: string[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleStringArray({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleStringArray({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleStringArray(props?: HookInput<'TestFnNamedArgsSingleStringArray', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleStringArray', { stream: true }>
export function useTestFnNamedArgsSingleStringArray(props: HookInput<'TestFnNamedArgsSingleStringArray', { stream: false }>): HookOutput<'TestFnNamedArgsSingleStringArray', { stream: false }>
export function useTestFnNamedArgsSingleStringArray(
  props: HookInput<'TestFnNamedArgsSingleStringArray', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleStringArray', { stream: true }> | HookOutput<'TestFnNamedArgsSingleStringArray', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleStringArray, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleStringArray, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestFnNamedArgsSingleStringList BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: string[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestFnNamedArgsSingleStringList({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestFnNamedArgsSingleStringList({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestFnNamedArgsSingleStringList(props?: HookInput<'TestFnNamedArgsSingleStringList', { stream?: true }>): HookOutput<'TestFnNamedArgsSingleStringList', { stream: true }>
export function useTestFnNamedArgsSingleStringList(props: HookInput<'TestFnNamedArgsSingleStringList', { stream: false }>): HookOutput<'TestFnNamedArgsSingleStringList', { stream: false }>
export function useTestFnNamedArgsSingleStringList(
  props: HookInput<'TestFnNamedArgsSingleStringList', { stream?: boolean }> = {},
): HookOutput<'TestFnNamedArgsSingleStringList', { stream: true }> | HookOutput<'TestFnNamedArgsSingleStringList', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestFnNamedArgsSingleStringList, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestFnNamedArgsSingleStringList, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestGemini BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGemini({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestGemini({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGemini(props?: HookInput<'TestGemini', { stream?: true }>): HookOutput<'TestGemini', { stream: true }>
export function useTestGemini(props: HookInput<'TestGemini', { stream: false }>): HookOutput<'TestGemini', { stream: false }>
export function useTestGemini(
  props: HookInput<'TestGemini', { stream?: boolean }> = {},
): HookOutput<'TestGemini', { stream: true }> | HookOutput<'TestGemini', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestGemini, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestGemini, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestGeminiOpenAiGeneric BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGeminiOpenAiGeneric({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestGeminiOpenAiGeneric({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGeminiOpenAiGeneric(props?: HookInput<'TestGeminiOpenAiGeneric', { stream?: true }>): HookOutput<'TestGeminiOpenAiGeneric', { stream: true }>
export function useTestGeminiOpenAiGeneric(props: HookInput<'TestGeminiOpenAiGeneric', { stream: false }>): HookOutput<'TestGeminiOpenAiGeneric', { stream: false }>
export function useTestGeminiOpenAiGeneric(
  props: HookInput<'TestGeminiOpenAiGeneric', { stream?: boolean }> = {},
): HookOutput<'TestGeminiOpenAiGeneric', { stream: true }> | HookOutput<'TestGeminiOpenAiGeneric', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestGeminiOpenAiGeneric, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestGeminiOpenAiGeneric, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestGeminiSystem BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGeminiSystem({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestGeminiSystem({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGeminiSystem(props?: HookInput<'TestGeminiSystem', { stream?: true }>): HookOutput<'TestGeminiSystem', { stream: true }>
export function useTestGeminiSystem(props: HookInput<'TestGeminiSystem', { stream: false }>): HookOutput<'TestGeminiSystem', { stream: false }>
export function useTestGeminiSystem(
  props: HookInput<'TestGeminiSystem', { stream?: boolean }> = {},
): HookOutput<'TestGeminiSystem', { stream: true }> | HookOutput<'TestGeminiSystem', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestGeminiSystem, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestGeminiSystem, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestGeminiSystemAsChat BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestGeminiSystemAsChat({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestGeminiSystemAsChat({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestGeminiSystemAsChat(props?: HookInput<'TestGeminiSystemAsChat', { stream?: true }>): HookOutput<'TestGeminiSystemAsChat', { stream: true }>
export function useTestGeminiSystemAsChat(props: HookInput<'TestGeminiSystemAsChat', { stream: false }>): HookOutput<'TestGeminiSystemAsChat', { stream: false }>
export function useTestGeminiSystemAsChat(
  props: HookInput<'TestGeminiSystemAsChat', { stream?: boolean }> = {},
): HookOutput<'TestGeminiSystemAsChat', { stream: true }> | HookOutput<'TestGeminiSystemAsChat', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestGeminiSystemAsChat, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestGeminiSystemAsChat, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestImageInput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestImageInput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestImageInput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestImageInput(props?: HookInput<'TestImageInput', { stream?: true }>): HookOutput<'TestImageInput', { stream: true }>
export function useTestImageInput(props: HookInput<'TestImageInput', { stream: false }>): HookOutput<'TestImageInput', { stream: false }>
export function useTestImageInput(
  props: HookInput<'TestImageInput', { stream?: boolean }> = {},
): HookOutput<'TestImageInput', { stream: true }> | HookOutput<'TestImageInput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestImageInput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestImageInput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestImageInputAnthropic BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - img: Image
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestImageInputAnthropic({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestImageInputAnthropic({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestImageInputAnthropic(props?: HookInput<'TestImageInputAnthropic', { stream?: true }>): HookOutput<'TestImageInputAnthropic', { stream: true }>
export function useTestImageInputAnthropic(props: HookInput<'TestImageInputAnthropic', { stream: false }>): HookOutput<'TestImageInputAnthropic', { stream: false }>
export function useTestImageInputAnthropic(
  props: HookInput<'TestImageInputAnthropic', { stream?: boolean }> = {},
): HookOutput<'TestImageInputAnthropic', { stream: true }> | HookOutput<'TestImageInputAnthropic', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestImageInputAnthropic, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestImageInputAnthropic, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestImageListInput BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - imgs: Image[]
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestImageListInput({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestImageListInput({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestImageListInput(props?: HookInput<'TestImageListInput', { stream?: true }>): HookOutput<'TestImageListInput', { stream: true }>
export function useTestImageListInput(props: HookInput<'TestImageListInput', { stream: false }>): HookOutput<'TestImageListInput', { stream: false }>
export function useTestImageListInput(
  props: HookInput<'TestImageListInput', { stream?: boolean }> = {},
): HookOutput<'TestImageListInput', { stream: true }> | HookOutput<'TestImageListInput', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestImageListInput, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestImageListInput, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestMemory BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** TestMemoryOutput
 * - **Streaming Partial:** partial_types.TestMemoryOutput
 * - **Streaming Final:** TestMemoryOutput
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestMemory({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestMemory({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestMemory(props?: HookInput<'TestMemory', { stream?: true }>): HookOutput<'TestMemory', { stream: true }>
export function useTestMemory(props: HookInput<'TestMemory', { stream: false }>): HookOutput<'TestMemory', { stream: false }>
export function useTestMemory(
  props: HookInput<'TestMemory', { stream?: boolean }> = {},
): HookOutput<'TestMemory', { stream: true }> | HookOutput<'TestMemory', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestMemory, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestMemory, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestMulticlassNamedArgs BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myArg: NamedArgsSingleClass
 *
 * - myArg2: NamedArgsSingleClass
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestMulticlassNamedArgs({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestMulticlassNamedArgs({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestMulticlassNamedArgs(props?: HookInput<'TestMulticlassNamedArgs', { stream?: true }>): HookOutput<'TestMulticlassNamedArgs', { stream: true }>
export function useTestMulticlassNamedArgs(props: HookInput<'TestMulticlassNamedArgs', { stream: false }>): HookOutput<'TestMulticlassNamedArgs', { stream: false }>
export function useTestMulticlassNamedArgs(
  props: HookInput<'TestMulticlassNamedArgs', { stream?: boolean }> = {},
): HookOutput<'TestMulticlassNamedArgs', { stream: true }> | HookOutput<'TestMulticlassNamedArgs', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestMulticlassNamedArgs, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestMulticlassNamedArgs, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestNamedArgsLiteralBool BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myBool: true
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestNamedArgsLiteralBool({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestNamedArgsLiteralBool({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestNamedArgsLiteralBool(props?: HookInput<'TestNamedArgsLiteralBool', { stream?: true }>): HookOutput<'TestNamedArgsLiteralBool', { stream: true }>
export function useTestNamedArgsLiteralBool(props: HookInput<'TestNamedArgsLiteralBool', { stream: false }>): HookOutput<'TestNamedArgsLiteralBool', { stream: false }>
export function useTestNamedArgsLiteralBool(
  props: HookInput<'TestNamedArgsLiteralBool', { stream?: boolean }> = {},
): HookOutput<'TestNamedArgsLiteralBool', { stream: true }> | HookOutput<'TestNamedArgsLiteralBool', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestNamedArgsLiteralBool, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestNamedArgsLiteralBool, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestNamedArgsLiteralInt BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myInt: 1
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestNamedArgsLiteralInt({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestNamedArgsLiteralInt({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestNamedArgsLiteralInt(props?: HookInput<'TestNamedArgsLiteralInt', { stream?: true }>): HookOutput<'TestNamedArgsLiteralInt', { stream: true }>
export function useTestNamedArgsLiteralInt(props: HookInput<'TestNamedArgsLiteralInt', { stream: false }>): HookOutput<'TestNamedArgsLiteralInt', { stream: false }>
export function useTestNamedArgsLiteralInt(
  props: HookInput<'TestNamedArgsLiteralInt', { stream?: boolean }> = {},
): HookOutput<'TestNamedArgsLiteralInt', { stream: true }> | HookOutput<'TestNamedArgsLiteralInt', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestNamedArgsLiteralInt, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestNamedArgsLiteralInt, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestNamedArgsLiteralString BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - myString: "My String"
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestNamedArgsLiteralString({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestNamedArgsLiteralString({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestNamedArgsLiteralString(props?: HookInput<'TestNamedArgsLiteralString', { stream?: true }>): HookOutput<'TestNamedArgsLiteralString', { stream: true }>
export function useTestNamedArgsLiteralString(props: HookInput<'TestNamedArgsLiteralString', { stream: false }>): HookOutput<'TestNamedArgsLiteralString', { stream: false }>
export function useTestNamedArgsLiteralString(
  props: HookInput<'TestNamedArgsLiteralString', { stream?: boolean }> = {},
): HookOutput<'TestNamedArgsLiteralString', { stream: true }> | HookOutput<'TestNamedArgsLiteralString', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestNamedArgsLiteralString, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestNamedArgsLiteralString, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOllama BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOllama({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOllama({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOllama(props?: HookInput<'TestOllama', { stream?: true }>): HookOutput<'TestOllama', { stream: true }>
export function useTestOllama(props: HookInput<'TestOllama', { stream: false }>): HookOutput<'TestOllama', { stream: false }>
export function useTestOllama(
  props: HookInput<'TestOllama', { stream?: boolean }> = {},
): HookOutput<'TestOllama', { stream: true }> | HookOutput<'TestOllama', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOllama, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOllama, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAI BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAI({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAI({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAI(props?: HookInput<'TestOpenAI', { stream?: true }>): HookOutput<'TestOpenAI', { stream: true }>
export function useTestOpenAI(props: HookInput<'TestOpenAI', { stream: false }>): HookOutput<'TestOpenAI', { stream: false }>
export function useTestOpenAI(
  props: HookInput<'TestOpenAI', { stream?: boolean }> = {},
): HookOutput<'TestOpenAI', { stream: true }> | HookOutput<'TestOpenAI', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAI, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAI, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAILegacyProvider BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAILegacyProvider({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAILegacyProvider({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAILegacyProvider(props?: HookInput<'TestOpenAILegacyProvider', { stream?: true }>): HookOutput<'TestOpenAILegacyProvider', { stream: true }>
export function useTestOpenAILegacyProvider(props: HookInput<'TestOpenAILegacyProvider', { stream: false }>): HookOutput<'TestOpenAILegacyProvider', { stream: false }>
export function useTestOpenAILegacyProvider(
  props: HookInput<'TestOpenAILegacyProvider', { stream?: boolean }> = {},
): HookOutput<'TestOpenAILegacyProvider', { stream: true }> | HookOutput<'TestOpenAILegacyProvider', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAILegacyProvider, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAILegacyProvider, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAIO1NoMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIO1NoMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAIO1NoMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIO1NoMaxTokens(props?: HookInput<'TestOpenAIO1NoMaxTokens', { stream?: true }>): HookOutput<'TestOpenAIO1NoMaxTokens', { stream: true }>
export function useTestOpenAIO1NoMaxTokens(props: HookInput<'TestOpenAIO1NoMaxTokens', { stream: false }>): HookOutput<'TestOpenAIO1NoMaxTokens', { stream: false }>
export function useTestOpenAIO1NoMaxTokens(
  props: HookInput<'TestOpenAIO1NoMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestOpenAIO1NoMaxTokens', { stream: true }> | HookOutput<'TestOpenAIO1NoMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAIO1NoMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAIO1NoMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAIO1WithMaxCompletionTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIO1WithMaxCompletionTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAIO1WithMaxCompletionTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIO1WithMaxCompletionTokens(props?: HookInput<'TestOpenAIO1WithMaxCompletionTokens', { stream?: true }>): HookOutput<'TestOpenAIO1WithMaxCompletionTokens', { stream: true }>
export function useTestOpenAIO1WithMaxCompletionTokens(props: HookInput<'TestOpenAIO1WithMaxCompletionTokens', { stream: false }>): HookOutput<'TestOpenAIO1WithMaxCompletionTokens', { stream: false }>
export function useTestOpenAIO1WithMaxCompletionTokens(
  props: HookInput<'TestOpenAIO1WithMaxCompletionTokens', { stream?: boolean }> = {},
): HookOutput<'TestOpenAIO1WithMaxCompletionTokens', { stream: true }> | HookOutput<'TestOpenAIO1WithMaxCompletionTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAIO1WithMaxCompletionTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAIO1WithMaxCompletionTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAIO1WithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIO1WithMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAIO1WithMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIO1WithMaxTokens(props?: HookInput<'TestOpenAIO1WithMaxTokens', { stream?: true }>): HookOutput<'TestOpenAIO1WithMaxTokens', { stream: true }>
export function useTestOpenAIO1WithMaxTokens(props: HookInput<'TestOpenAIO1WithMaxTokens', { stream: false }>): HookOutput<'TestOpenAIO1WithMaxTokens', { stream: false }>
export function useTestOpenAIO1WithMaxTokens(
  props: HookInput<'TestOpenAIO1WithMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestOpenAIO1WithMaxTokens', { stream: true }> | HookOutput<'TestOpenAIO1WithMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAIO1WithMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAIO1WithMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAIShorthand BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIShorthand({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAIShorthand({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIShorthand(props?: HookInput<'TestOpenAIShorthand', { stream?: true }>): HookOutput<'TestOpenAIShorthand', { stream: true }>
export function useTestOpenAIShorthand(props: HookInput<'TestOpenAIShorthand', { stream: false }>): HookOutput<'TestOpenAIShorthand', { stream: false }>
export function useTestOpenAIShorthand(
  props: HookInput<'TestOpenAIShorthand', { stream?: boolean }> = {},
): HookOutput<'TestOpenAIShorthand', { stream: true }> | HookOutput<'TestOpenAIShorthand', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAIShorthand, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAIShorthand, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAIWithMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIWithMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAIWithMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIWithMaxTokens(props?: HookInput<'TestOpenAIWithMaxTokens', { stream?: true }>): HookOutput<'TestOpenAIWithMaxTokens', { stream: true }>
export function useTestOpenAIWithMaxTokens(props: HookInput<'TestOpenAIWithMaxTokens', { stream: false }>): HookOutput<'TestOpenAIWithMaxTokens', { stream: false }>
export function useTestOpenAIWithMaxTokens(
  props: HookInput<'TestOpenAIWithMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestOpenAIWithMaxTokens', { stream: true }> | HookOutput<'TestOpenAIWithMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAIWithMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAIWithMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestOpenAIWithNullMaxTokens BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestOpenAIWithNullMaxTokens({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestOpenAIWithNullMaxTokens({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestOpenAIWithNullMaxTokens(props?: HookInput<'TestOpenAIWithNullMaxTokens', { stream?: true }>): HookOutput<'TestOpenAIWithNullMaxTokens', { stream: true }>
export function useTestOpenAIWithNullMaxTokens(props: HookInput<'TestOpenAIWithNullMaxTokens', { stream: false }>): HookOutput<'TestOpenAIWithNullMaxTokens', { stream: false }>
export function useTestOpenAIWithNullMaxTokens(
  props: HookInput<'TestOpenAIWithNullMaxTokens', { stream?: boolean }> = {},
): HookOutput<'TestOpenAIWithNullMaxTokens', { stream: true }> | HookOutput<'TestOpenAIWithNullMaxTokens', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestOpenAIWithNullMaxTokens, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestOpenAIWithNullMaxTokens, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestRetryConstant BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestRetryConstant({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestRetryConstant({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestRetryConstant(props?: HookInput<'TestRetryConstant', { stream?: true }>): HookOutput<'TestRetryConstant', { stream: true }>
export function useTestRetryConstant(props: HookInput<'TestRetryConstant', { stream: false }>): HookOutput<'TestRetryConstant', { stream: false }>
export function useTestRetryConstant(
  props: HookInput<'TestRetryConstant', { stream?: boolean }> = {},
): HookOutput<'TestRetryConstant', { stream: true }> | HookOutput<'TestRetryConstant', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestRetryConstant, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestRetryConstant, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestRetryExponential BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestRetryExponential({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestRetryExponential({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestRetryExponential(props?: HookInput<'TestRetryExponential', { stream?: true }>): HookOutput<'TestRetryExponential', { stream: true }>
export function useTestRetryExponential(props: HookInput<'TestRetryExponential', { stream: false }>): HookOutput<'TestRetryExponential', { stream: false }>
export function useTestRetryExponential(
  props: HookInput<'TestRetryExponential', { stream?: boolean }> = {},
): HookOutput<'TestRetryExponential', { stream: true }> | HookOutput<'TestRetryExponential', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestRetryExponential, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestRetryExponential, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestSingleFallbackClient BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestSingleFallbackClient({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestSingleFallbackClient({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestSingleFallbackClient(props?: HookInput<'TestSingleFallbackClient', { stream?: true }>): HookOutput<'TestSingleFallbackClient', { stream: true }>
export function useTestSingleFallbackClient(props: HookInput<'TestSingleFallbackClient', { stream: false }>): HookOutput<'TestSingleFallbackClient', { stream: false }>
export function useTestSingleFallbackClient(
  props: HookInput<'TestSingleFallbackClient', { stream?: boolean }> = {},
): HookOutput<'TestSingleFallbackClient', { stream: true }> | HookOutput<'TestSingleFallbackClient', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestSingleFallbackClient, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestSingleFallbackClient, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestUniverseQuestion BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - question: UniverseQuestionInput
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** UniverseQuestion
 * - **Streaming Partial:** partial_types.UniverseQuestion
 * - **Streaming Final:** UniverseQuestion
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestUniverseQuestion({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestUniverseQuestion({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestUniverseQuestion(props?: HookInput<'TestUniverseQuestion', { stream?: true }>): HookOutput<'TestUniverseQuestion', { stream: true }>
export function useTestUniverseQuestion(props: HookInput<'TestUniverseQuestion', { stream: false }>): HookOutput<'TestUniverseQuestion', { stream: false }>
export function useTestUniverseQuestion(
  props: HookInput<'TestUniverseQuestion', { stream?: boolean }> = {},
): HookOutput<'TestUniverseQuestion', { stream: true }> | HookOutput<'TestUniverseQuestion', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestUniverseQuestion, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestUniverseQuestion, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestVertex BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestVertex({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestVertex({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestVertex(props?: HookInput<'TestVertex', { stream?: true }>): HookOutput<'TestVertex', { stream: true }>
export function useTestVertex(props: HookInput<'TestVertex', { stream: false }>): HookOutput<'TestVertex', { stream: false }>
export function useTestVertex(
  props: HookInput<'TestVertex', { stream?: boolean }> = {},
): HookOutput<'TestVertex', { stream: true }> | HookOutput<'TestVertex', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestVertex, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestVertex, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the TestVertexWithSystemInstructions BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** string
 * - **Streaming Partial:** string
 * - **Streaming Final:** string
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useTestVertexWithSystemInstructions({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useTestVertexWithSystemInstructions({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useTestVertexWithSystemInstructions(props?: HookInput<'TestVertexWithSystemInstructions', { stream?: true }>): HookOutput<'TestVertexWithSystemInstructions', { stream: true }>
export function useTestVertexWithSystemInstructions(props: HookInput<'TestVertexWithSystemInstructions', { stream: false }>): HookOutput<'TestVertexWithSystemInstructions', { stream: false }>
export function useTestVertexWithSystemInstructions(
  props: HookInput<'TestVertexWithSystemInstructions', { stream?: boolean }> = {},
): HookOutput<'TestVertexWithSystemInstructions', { stream: true }> | HookOutput<'TestVertexWithSystemInstructions', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.TestVertexWithSystemInstructions, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.TestVertexWithSystemInstructions, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the UnionTest_Function BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - input: string | boolean
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** UnionTest_ReturnType
 * - **Streaming Partial:** partial_types.UnionTest_ReturnType
 * - **Streaming Final:** UnionTest_ReturnType
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUnionTest_Function({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useUnionTest_Function({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUnionTest_Function(props?: HookInput<'UnionTest_Function', { stream?: true }>): HookOutput<'UnionTest_Function', { stream: true }>
export function useUnionTest_Function(props: HookInput<'UnionTest_Function', { stream: false }>): HookOutput<'UnionTest_Function', { stream: false }>
export function useUnionTest_Function(
  props: HookInput<'UnionTest_Function', { stream?: boolean }> = {},
): HookOutput<'UnionTest_Function', { stream: true }> | HookOutput<'UnionTest_Function', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.UnionTest_Function, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.UnionTest_Function, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the UseBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: BlockConstraintForParam
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUseBlockConstraint({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useUseBlockConstraint({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUseBlockConstraint(props?: HookInput<'UseBlockConstraint', { stream?: true }>): HookOutput<'UseBlockConstraint', { stream: true }>
export function useUseBlockConstraint(props: HookInput<'UseBlockConstraint', { stream: false }>): HookOutput<'UseBlockConstraint', { stream: false }>
export function useUseBlockConstraint(
  props: HookInput<'UseBlockConstraint', { stream?: boolean }> = {},
): HookOutput<'UseBlockConstraint', { stream: true }> | HookOutput<'UseBlockConstraint', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.UseBlockConstraint, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.UseBlockConstraint, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the UseMalformedConstraints BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - a: MalformedConstraints2
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUseMalformedConstraints({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useUseMalformedConstraints({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUseMalformedConstraints(props?: HookInput<'UseMalformedConstraints', { stream?: true }>): HookOutput<'UseMalformedConstraints', { stream: true }>
export function useUseMalformedConstraints(props: HookInput<'UseMalformedConstraints', { stream: false }>): HookOutput<'UseMalformedConstraints', { stream: false }>
export function useUseMalformedConstraints(
  props: HookInput<'UseMalformedConstraints', { stream?: boolean }> = {},
): HookOutput<'UseMalformedConstraints', { stream: true }> | HookOutput<'UseMalformedConstraints', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.UseMalformedConstraints, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.UseMalformedConstraints, props)
  }
  throw new Error('Invalid props')
}
/**
 * A specialized hook for the UseNestedBlockConstraint BAML function that supports both streaming and non‑streaming responses.
 *
 * **Input Types:**
 *
 * - inp: NestedBlockConstraintForParam
 *
 *
 * **Return Type:**
 * - **Non‑streaming:** number
 * - **Streaming Partial:** number
 * - **Streaming Final:** number
 *
 * **Usage Patterns:**
 * 1. **Non‑streaming (Default)**
 *    - Best for quick responses and simple UI updates.
 * 2. **Streaming**
 *    - Ideal for long‑running operations or real‑time feedback.
 *
 * **Edge Cases:**
 * - Ensure robust error handling via `onError`.
 * - Handle cases where partial data may be incomplete or missing.
 *
 * @example
 * ```tsx
 * // Basic non‑streaming usage:
 * const { data, error, isPending, mutate } = useUseNestedBlockConstraint({ stream: false});
 *
 * // Streaming usage:
 * const { data, streamingData, isPending, error, mutate } = useUseNestedBlockConstraint({
 *   stream: true | undefined,
 *   onPartial: (partial) => console.log('Partial update:', partial),
 *   onFinal: (final) => console.log('Final result:', final),
 *   onError: (err) => console.error('Error:', err),
 * });
 * ```
 */
export function useUseNestedBlockConstraint(props?: HookInput<'UseNestedBlockConstraint', { stream?: true }>): HookOutput<'UseNestedBlockConstraint', { stream: true }>
export function useUseNestedBlockConstraint(props: HookInput<'UseNestedBlockConstraint', { stream: false }>): HookOutput<'UseNestedBlockConstraint', { stream: false }>
export function useUseNestedBlockConstraint(
  props: HookInput<'UseNestedBlockConstraint', { stream?: boolean }> = {},
): HookOutput<'UseNestedBlockConstraint', { stream: true }> | HookOutput<'UseNestedBlockConstraint', { stream: false }> {
  if (isNotStreamingProps(props)) {
    return useBamlAction(Actions.UseNestedBlockConstraint, props)
  }
  if (isStreamingProps(props)) {
    return useBamlAction(StreamingActions.UseNestedBlockConstraint, props)
  }
  throw new Error('Invalid props')
}
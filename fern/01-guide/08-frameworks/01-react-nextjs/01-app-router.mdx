---
title: Next.js App Router Setup
---

This guide walks you through setting up BAML with Next.js App Router, leveraging Server Actions and React Server Components for optimal performance.

## Quick Start

Follow the step-by-step instructions below to set up BAML in a new or existing Next.js project.

<Steps>
### Create a New Next.js Project

First, create a new Next.js project with the App Router:

<CodeBlocks>
```bash npm
npx create-next-app@latest my-baml-app
```

```bash pnpm
pnpm create next-app my-baml-app
```

```bash yarn
yarn create next-app my-baml-app
```
</CodeBlocks>

When prompted, make sure to:
- Select **Yes** for "Would you like to use TypeScript?"
- Select **Yes** for "Would you like to use the App Router? (recommended)"
- Configure other options as needed for your project

### Install Dependencies

Next, install BAML and its dependencies:

<CodeBlocks>
```bash npm
npm install @boundaryml/baml
npm install @boundaryml/baml-nextjs-plugin
```

```bash pnpm
pnpm add @boundaryml/baml
pnpm add @boundaryml/baml-nextjs-plugin
```

```bash yarn
yarn add @boundaryml/baml
yarn add @boundaryml/baml-nextjs-plugin
```
</CodeBlocks>

### Configure Next.js

Update your `next.config.mjs`:

<CodeBlocks>
```typescript title="next.config.ts" {1,8}
import { withBaml } from '@boundaryml/baml-nextjs-plugin';
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  // ... existing config
};

export default withBaml()(nextConfig);
```

```javascript title="next.config.mjs" {1,8}
import { withBaml } from '@boundaryml/baml-nextjs-plugin';
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  // ... existing config
};

export default withBaml()(nextConfig);
```

```javascript title="next.config.js" {1,8}
const { withBaml } = require('@boundaryml/baml-nextjs-plugin');

/** @type {import('next').NextConfig} */
const nextConfig = {
  // ... existing config
}

module.exports = withBaml()(nextConfig)
```
</CodeBlocks>

### Initialize BAML

Create a new BAML project in your Next.js application:
<Markdown src="../../../snippets/baml/cli/install/nodejs.mdx" />

This will create a `baml_src` directory with starter code.

### Setup Environment Variables

Setup provider specific API Keys.

```.env .env.local
OPENAI_API_KEY=sk-...
```

<Accordion title='(Optional) BAML Observability'>
To enable observability with BAML, you'll first need to sign up for a [Boundary Studio](https://app.boundaryml.com) account.


```.env .env.local
BOUNDARY_PROJECT_ID=sk-...
BOUNDARY_SECRET=sk-...

OPENAI_API_KEY=sk-...
```

</Accordion>

### Setup BAML Client Provider

<Markdown src="../../../snippets/baml/clients/openai.mdx" />

### Setup BAML Next.js Generator

```baml title="baml_src/generators.baml"
generator typescript {
  output_type "typescript/react"
  output_dir ".."
  version "0.75.0"
}
```

### Generate BAML Client

<Markdown src="../../../snippets/baml/cli/generate.mdx" />

### Generated Server Actions

BAML automatically generates type-safe Next.js server actions and React hooks for your BAML functions, with built-in support for both streaming and non-streaming modes. Here's how to use them:

#### Basic Usage (Non-Streaming)
```tsx title="app/components/story-form.tsx"
'use client'

import { useWriteMeAStoryAction } from "@/baml_client/react/client";
import type { Story } from "@/baml_client/types";

export function StoryForm() {
  const {
    data,          // Final response
    isLoading,     // Loading state
    isError,       // Error state
    error,         // Error details
    mutate        // Function to call the action
  } = useWriteMeAStoryAction();

  return (
    <div>
      <button onClick={() => mutate("Tell me a story about dragons")}>
        Generate Story
      </button>

      {isLoading && <div>Generating...</div>}
      {error && <div>Error: {error.message}</div>}
      {data && (
        <div>
          <h4>{data.title}</h4>
          <p>{data.content}</p>
        </div>
      )}
    </div>
  );
}
```

#### Streaming
Simply add the `stream: true` prop to get real-time updates:

```tsx title="app/components/streaming-story.tsx"
'use client'

import { useWriteMeAStoryAction } from "@/baml_client/react/client";
import type { Story } from "@/baml_client/types";

export function StreamingStoryForm() {
  const {
    data: finalStory,           // Final complete response
    partialData: streamingStory, // Real-time partial updates
    isLoading,
    isError,
    error,
    mutate
  } = useWriteMeAStoryAction({
    stream: true,
    onPartial: (partial) => {
      // Handle real-time updates
      console.log('Story in progress:', partial);
    },
    onFinal: (final) => {
      // Handle completed story
      console.log('Story completed:', final);
    }
  });

  // Use streaming data while loading, fall back to final data when done
  const story = isLoading ? streamingStory : finalStory;

  return (
    <div>
      <button
        onClick={() => mutate("Tell me a story about dragons")}
        disabled={isLoading}
      >
        {isLoading ? 'Generating...' : 'Generate Story'}
      </button>

      <div>
        <h3>{streamingStory ? "Writing story..." : "Final story"}</h3>
        <h4>{story?.title}</h4>
        <p>{story?.content}</p>
      </div>

      {isError && <div>Error: {error.message}</div>}
    </div>
  );
}
```

#### Custom Server Actions
You can wrap BAML functions in your own server actions for additional control:

```ts title="app/actions/story.ts"
'use server'

import { b } from "@/baml_client";

export async function writeMeAStoryAction(prompt: string) {
  // Add your own logic (auth, validation, etc.)
  const auth = await auth();
  if (!auth) throw new Error("Unauthorized");

  // Choose streaming or non-streaming mode:

  // Non-streaming:
  return b.WriteMeAStory(prompt);

  // Or streaming:
  return b.stream.WriteMeAStory(prompt).toStreamable();
}
```

Then use it with the generic `useBamlAction` hook:

```tsx
const {
  data,
  partialData,
  isLoading,
  mutate
} = useBamlAction(writeMeAStoryAction, {
  stream: true,
  onPartial: (data) => console.log('Progress:', data),
});
```

### Update Package Scripts

Update your `package.json` scripts:

```json {3,4}
{
  "scripts": {
    "prebuild": "npm run generate",
    "generate": "baml-cli generate",
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
  }
}
```

</Steps>

## Best Practices

1. **Component Organization**
   - Keep BAML calls in server components
   - Use server actions for mutations
   - Implement proper error boundaries
   - Handle cleanup on unmount

2. **Streaming Flexibility**
   - BAML hooks support both streaming and non-streaming modes with the same API
   - Switch between modes by toggling a single prop:
     ```typescript
     // Non-streaming mode (default)
     const { data, error, isPending, mutate } = useTestAws();

     // Streaming mode
     const { data, partialData, error, isPending, mutate } = useTestAws({
       stream: true,
       onPartial: (partial) => console.log('Partial:', partial),
       onFinal: (final) => console.log('Final:', final),
     });
     ```
   - Type-safe responses in both modes:
     ```typescript
     // Types are automatically inferred
     data: FinalType | undefined      // Final response type
     partialData: PartialType | null  // Streaming response type
     error: BamlError | undefined     // Type-safe error handling
     ```
   - Consistent error handling across modes:
     ```typescript
     const {
       data,
       partialData,
       error,
       isPending,
       isError,
       isSuccess,
       mutate
     } = useTestAws({
       stream: true,
       onError: (error) => {
         if (error instanceof BamlValidationError) {
           // Handle validation errors
         } else if (error instanceof BamlClientFinishReasonError) {
           // Handle early termination
         }
       }
     });
     ```
   - Easy state management:
     ```typescript
     const story = isPending ? partialData : data; // Use streaming data while loading
     ```
   - Custom server actions support both modes:
     ```typescript
     // Server action
     export async function customAction(input: string) {
       // Non-streaming
       return b.TestAws(input);

       // Or streaming
       return b.stream.TestAws(input).toStreamable();
     }

     // React component
     const { data, partialData } = useBamlAction(customAction, {
       stream: true,
       onPartial: (data) => console.log('Streaming:', data),
     });
     ```

3. **Performance**
   - Use streaming for long responses
   - Implement proper loading states
   - Cache results when appropriate
   - Monitor memory usage

4. **Error Handling**
   - BAML provides three types of errors you need to handle:
     ```typescript
     import { BamlValidationError, BamlClientFinishReasonError } from "@boundaryml/baml/errors"

     try {
       const result = await myBamlFunction(params);
     } catch (e) {
       if (e instanceof BamlValidationError) {
         // Thrown when BAML fails to parse LLM output
         console.error('Parsing error:', e.message);
         console.error('Original prompt:', e.prompt);
         console.error('Raw LLM output:', e.raw_output);
       } else if (e instanceof BamlClientFinishReasonError) {
         // Thrown when LLM terminates with disallowed finish reason
         console.error('LLM terminated early:', e.finish_reason);
         console.error('Error message:', e.message);
         console.error('Original prompt:', e.prompt);
         console.error('Partial output:', e.raw_output);
       } else {
         // Handle other errors (network, etc)
         console.error('Other error:', e);
       }
     }
     ```
   - Create error boundaries for graceful UI fallbacks:
     ```typescript
     'use client';

     import { useEffect } from 'react';
     import { useWriteMeAStoryAction } from './baml_client';

     export function StoryGenerator() {
       const {
         data,
         error,
         isPending,
         mutate
       } = useWriteMeAStoryAction();

       useEffect(() => {
         if (error) {
           if (error instanceof BamlValidationError) {
             // Show parsing error UI
             toast.error('Failed to understand AI response');
           } else if (error instanceof BamlClientFinishReasonError) {
             // Show early termination UI
             toast.error('AI response was cut off');
           } else {
             // Show generic error UI
             toast.error('Something went wrong');
           }
         }
       }, [error]);

       return (
         <div>
           {isPending && <LoadingSpinner />}
           {error && <ErrorDisplay error={error} />}
           {data && <StoryDisplay story={data} />}

           <button
             onClick={() => mutate({ topic: 'adventure' })}
             disabled={isPending}
           >
             Generate Story
           </button>
         </div>
       );
     }
     ```
   - Implement retry mechanisms
   - Show meaningful error messages
   - Handle network errors
   - Clean up resources

5. **Security**
   - Never expose API keys
   - Validate user input
   - Implement rate limiting
   - Use proper authentication

## Next Steps

- See the [React/Next.js Reference](/ref/generators/framework-generators/react-next-js) for detailed API documentation
- Check out the [BAML Examples](https://github.com/BoundaryML/baml-examples/tree/main/nextjs-starter) for more use cases
- Learn about [Environment Variables](/guide/development/environment-variables) for configuration

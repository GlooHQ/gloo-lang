---
slug: /guide/baml-basics/streaming
---

BAML lets you stream in structured JSON output from LLMs as it comes in.

If you tried streaming in a JSON output from an LLM you'd see something like:
```
{"items": [{"name": "Appl
{"items": [{"name": "Apple", "quantity": 2, "price": 1.
{"items": [{"name": "Apple", "quantity": 2, "price": 1.50}], "total_cost":
{"items": [{"name": "Apple", "quantity": 2, "price": 1.50}], "total_cost": 3.00} # Completed
```

BAML gives you fine-grained control of how it fixes this partial JSON and transforms
it into a series of semantically valid partial objects.

<Tip>You can check out more examples (including streaming in FastAPI and NextJS) in the [BAML Examples] repo.</Tip>

[call BAML functions]: /docs/calling-baml/calling-functions
[BAML Examples]: https://github.com/BoundaryML/baml-examples/tree/main

Let's stream the output of this function `function ExtractReceiptInfo(email: string) -> ReceiptInfo` for our example:

<Accordion title="extract-receipt-info.baml">

```rust
class ReceiptItem {
  name string
  description string?
  quantity int
  price float
}

class ReceiptInfo {
    items ReceiptItem[]
    total_cost float?
}

function ExtractReceiptInfo(email: string) -> ReceiptInfo {
  client GPT4o
  prompt #"
    Given the receipt below:

    {{ email }}

    {{ ctx.output_format }}
  "#
}
```
</Accordion>

The BAML code generator creates a set of types in the `baml_client` library
in a module called `partial` in `baml_client`. These types are modified
from your original types to support streaming.

By default, BAML will convert all Class fields into nullable fields, and
fill those fields with non-null values as much as possible given the tokens
received so far.

<Tabs>

<Tab title="Python">
BAML will generate `b.stream.ExtractReceiptInfo()` for you, which you can use like so:

```python main.py
import asyncio
from baml_client import b, partial_types, types

# Using a stream:
def example1(receipt: str):
    stream = b.stream.ExtractReceiptInfo(receipt)

    # partial is a Partial type with all Optional fields
    for partial in stream:
        print(f"partial: parsed {len(partial.items)} items (object: {partial})")

    # final is the full, original, validated ReceiptInfo type
    final = stream.get_final_response()
    print(f"final: {len(final.items)} items (object: {final})")

# Using only get_final_response() of a stream
#
# In this case, you should just use b.ExtractReceiptInfo(receipt) instead,
# which is slightly faster and more efficient.
def example2(receipt: str):
    final = b.stream.ExtractReceiptInfo(receipt).get_final_response()
    print(f"final: {len(final.items)} items (object: {final})")

# Using the async client:
async def example3(receipt: str):
    # Note the import of the async client
    from baml_client.async_client import b
    stream = b.stream.ExtractReceiptInfo(receipt)
    async for partial in stream:
        print(f"partial: parsed {len(partial.items)} items (object: {partial})")

    final = await stream.get_final_response()
    print(f"final: {len(final.items)} items (object: {final})")

receipt = """
04/14/2024 1:05 pm

Ticket: 220000082489
Register: Shop Counter
Employee: Connor
Customer: Sam
Item	#	Price
Guide leash (1 Pair) uni UNI
1	$34.95
The Index Town Walls
1	$35.00
Boot Punch
3	$60.00
Subtotal	$129.95
Tax ($129.95 @ 9%)	$11.70
Total Tax	$11.70
Total	$141.65
"""

if __name__ == '__main__':
    asyncio.run(example1(receipt))
    asyncio.run(example2(receipt))
    asyncio.run(example3(receipt))
```
</Tab>

<Tab title="TypeScript">
BAML will generate `b.stream.ExtractReceiptInfo()` for you, which you can use like so:

```ts main.ts
import { b } from './baml_client'

// Using both async iteration and getFinalResponse() from a stream
const example1 = async (receipt: string) => {
  const stream = b.stream.ExtractReceiptInfo(receipt)

  // partial is a Partial type with all Optional fields
  for await (const partial of stream) {
    console.log(`partial: ${partial.items?.length} items (object: ${partial})`)
  }

  // final is the full, original, validated ReceiptInfo type
  const final = await stream.getFinalResponse()
  console.log(`final: ${final.items.length} items (object: ${final})`)
}

// Using only async iteration of a stream
const example2 = async (receipt: string) => {
  for await (const partial of b.stream.ExtractReceiptInfo(receipt)) {
    console.log(`partial: ${partial.items?.length} items (object: ${partial})`)
  }
}

// Using only getFinalResponse() of a stream
//
// In this case, you should just use b.ExtractReceiptInfo(receipt) instead,
// which is faster and more efficient.
const example3 = async (receipt: string) => {
  const final = await b.stream.ExtractReceiptInfo(receipt).getFinalResponse()
  console.log(`final: ${final.items.length} items (object: ${final})`)
}

const receipt = `
04/14/2024 1:05 pm

Ticket: 220000082489
Register: Shop Counter
Employee: Connor
Customer: Sam
Item	#	Price
Guide leash (1 Pair) uni UNI
1	$34.95
The Index Town Walls
1	$35.00
Boot Punch
3	$60.00
Subtotal	$129.95
Tax ($129.95 @ 9%)	$11.70
Total Tax	$11.70
Total	$141.65
`

if (require.main === module) {
  example1(receipt)
  example2(receipt)
  example3(receipt)
}
```
</Tab>

<Tab title="Ruby (beta)">
BAML will generate `Baml.Client.stream.ExtractReceiptInfo()` for you,
which you can use like so:

```ruby main.rb
require_relative "baml_client/client"

$b = Baml.Client

# Using both iteration and get_final_response() from a stream
def example1(receipt)
  stream = $b.stream.ExtractReceiptInfo(receipt)

  stream.each do |partial|
    puts "partial: #{partial.items&.length} items"
  end

  final = stream.get_final_response
  puts "final: #{final.items.length} items"
end

# Using only iteration of a stream
def example2(receipt)
  $b.stream.ExtractReceiptInfo(receipt).each do |partial|
    puts "partial: #{partial.items&.length} items"
  end
end

# Using only get_final_response() of a stream
#
# In this case, you should just use BamlClient.ExtractReceiptInfo(receipt) instead,
# which is faster and more efficient.
def example3(receipt)
  final = $b.stream.ExtractReceiptInfo(receipt).get_final_response
  puts "final: #{final.items.length} items"
end

receipt = <<~RECEIPT
  04/14/2024 1:05 pm

  Ticket: 220000082489
  Register: Shop Counter
  Employee: Connor
  Customer: Sam
  Item  #  Price
  Guide leash (1 Pair) uni UNI
  1 $34.95
  The Index Town Walls
  1 $35.00
  Boot Punch
  3 $60.00
  Subtotal $129.95
  Tax ($129.95 @ 9%) $11.70
  Total Tax $11.70
  Total $141.65
RECEIPT

if __FILE__ == $0
  example1(receipt)
  example2(receipt)
  example3(receipt)
end
```

</Tab>
<Tab title="OpenAPI">

Streaming is not yet supported via OpenAPI, but it will be coming soon!

</Tab>
</Tabs>

<Note>
Number fields are always streamed in only when the LLM completes them. E.g. if
the final number is 129.95, you'll only see null or 129.95 instead of partial
numbers like 1, 12, 129.9, etc.
</Note>

## Semantic Streaming

The BAML language provides several attributes that can be attached to types
to control streaming behavior, ensuring that the partial values streamed to you
are always valid within your own semantics.

  - `@stream.done`: Marks a type that should only be streamed when it is
    done being read from the LLM response.
  - `@stream.not_null`: Marks a field to indicate that the class containing
     that field should only be streamed if that field is present (the field needed
     not be completed)
  - `@stream.with_state`: Adds metadata to a type indicating whether types appearing
    
### `@stream.done`

To demonstrate the use of `@stream.done`, imagine that a `ReceiptItem`
must only be consider valid and can only reach the client when its `name`,
`description`, `quantity` and `price` fields are completely streamed in.
To achieve this we can annotate the `ReceiptItem` class with the
`@stream.done` attribute:

```rust
class ReceiptItem {
  name string
  description string?
  quantity int
  price float
  @@stream.done
}
```

When generating the client code for `ReceiptType` none of the fields of
`ReceiptItem` will be converted to optional. And when parsing an LLM response,
no `ReceiptItem` will be streamed out until all of its fields are done being
streamed in.

### `@stream.not_null`

Sometimes the presence of a value is important to the correct interpretation
of a containing value. This commonly occurs with tags used to determine which
part of a union is being used.

For example, in this code block, `@stream.not_null` on each of the
`message_type` fields will ensure that an `Event` is never streamed until
enough tokens have been received to precisely know what the message type is,
allowing you to build UI appropriate to the message type before the other
fields have been completed.

```rust
class Message {
  message_type "greeting" | "within-convo" | "farewell" @stream.not_null
  gesture ("gesticulate" | "wave" | "shake-hands" | "hug")?
  message string
}

class Event {
  event_message: Message
  speaker string
}

function Chat(history: Event[]) -> Event { ... }
```

<Tip>
You might wonder if it's sufficient to use `@stream.done` on the
`message_type` field. `@stream.done` applies to types, preventing them
from streaming out until they are completed. On the other hand,
`@stream.not_null` applies to fields and prevents a containing object
from streaming out until that field is present.

A type with `@stream.done` on it will still be converted to a
nullable field in the generated partial types, so this change would not
produce the desired result of witholding a `Message` until its type is
known. Messages would be streamed with `message_type: null`.

This is a subtle distinction between `@stream.done` and
`@stream.not_null`. As a rule of thumb, remember that `@stream.done`
is about the type itself, and `@stream.not_null` is about the type's
containing context.
</Tip>

### `@stream.with_state`

It is often useful to know in client code whether a value is finished, or
could be updated in future messages. The `@stream.with_state` attribute lets
you attach metadata to types to indicate this state in client code.

<Tabs>
<Tab title="BAML">
```rust
class Message {
  message_type "greeting" | "within-convo" | "farewell" @stream.not_null
  gesture ("gesticulate" | "wave" | "shake-hands" | "hug")?
  message string @stream.with_state
}
```
</Tab>
<Tab title="Python">
```python
class StreamState(BaseModel, Generic[T]):
  value: T,
  state: "incomplete" | "complete"

class Message(BaseModel):
  message_type: Union["greeting", "within-convo", "farewell"]
  gesture: Option[Union["gesticulate", "wave", "shake-hands", "hug"]]
  message: StreamState[String]
```
</Tab>

<Tab title="Typescript">
```typescript
interface StreamState<T> {
  value: T,
  state: "incomplete" | "complete"
}

interface Message {
  message_type: "greeting" | "within-convo" | "farewell",
  gesture: ("gesticulate" | "wave" | "shake-hands" | "hug")?,
  message: StreamState<string>,
}
```
</Tab>

</Tabs>

## Putting it all together

Let's put all of these concepts together to design an application that
streams a conversation containing stock recommendations, using semantic
streaming to ensure that the streamed data obeys our domain's invariants.

```rust
enum Stock {
  APPL,
  MSFT,
  GOOG,
  BAML,
}

// Make recommendations atomic - we do not want a recommendation to be
// modified by streaming additional messages.
class Recommendation {
  stock Stock
  amount float
  action "buy" | "sell"
  @@stream.done
}

class Message {
  message_type "greeting" | "conversation" | "farewell" @stream.not_null
  message string @stream.with_state @stream.not_null
}

function Respond(
  history: (Message | Recommendation | UserMessage)[]
) -> Message | Recommendation { ... }
```

<Tabs>

<Tab title="Python">
The above BAML code will generate the following Python definitions in the
`partial` module. The use of streaming attributes has several effects on
the generated code:

 - `Recommendation` does not have any partial field because it was marked
   `@stream.done`.
 - The `Message.message` `string` is wrapped in `StreamState`, allowing
   runtime checking of its completion status. This status could be used
   to render a spinner as the message streams in.
 - The `Message.message_type` field may not be `null`, because it was marked
   as `@stream.not_null`.

```python
class StreamState(BaseModel, Generic[T]):
  value: T,
  state: Union[Literal["incomplete"] | Literal[]]

class Stock(str, Enum):
    APPL = "APPL"
    MSFT = "MSFT"
    GOOG = "GOOG"
    BAML = "BAML"

class Recommendation(BaseClass):
    stock: Stock
    amount: float
    action: Union[Literal["buy"], Literal["sell"]]

class Message(BaseClass):
  message_type: Union[Literal["gretting"], Literal["conversation"], Literal["farewell"]]
  message: StreamState[string]
```
</Tab>

<Tab title="Typescript">
The above BAML code will generate the following Typescript definitions in the
`partial` module. The use of streaming attributes has several effects on
the generated code:

 - `Recommendation` does not have any partial field because it was marked
   `@stream.done`.
 - The `Message.message` `string` is wrapped in `StreamState`, allowing
   runtime checking of its completion status. This status could be used
   to render a spinner as the message streams in.
 - The `Message.message_type` field may not be `null`, because it was marked
   as `@stream.not_null`.

```typescript
export interface StreamState<T> {
  value: T,
  state: "incomplete" | "complete"
}

export enum Category {
  APPL = "APPl",
  MSFT = "MSFT",
  GOOG = "GOOG",
  BAML = "BAML",
}

export interface Recommendation {
  stock: Stock,
  amount: float,
  action: "buy" | "sell"
}

export interface Message {
  message_type: "gretting" | "conversation" | "farewell"
  message: StreamState<string>
}
```
</Tab>

</Tabs>

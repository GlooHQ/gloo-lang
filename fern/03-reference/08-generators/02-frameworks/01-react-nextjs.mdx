---
title: React/Next.js Generator
---

The React generator creates type-safe hooks and server actions for Next.js App Router, with full support for streaming responses and Server Components.

## Configuration

<CodeBlocks>
```baml BAML
generator lang_typescript_react {
  output_type typescript/react
  output_dir "../react"
  version "0.74.0"
}
```

```txt Generated Files
baml_client/
├── async_client.ts    # Asynchronous client methods
├── sync_client.ts     # Synchronous client methods
├── globals.ts         # Global configuration
├── index.ts          # Main entry point and exports
├── inlinedbaml.ts    # Inlined BAML definitions
├── partial_types.ts   # Types for streaming responses
├── tracing.ts        # Tracing utilities
├── type_builder.ts   # Type construction utilities
├── types.ts          # Generated TypeScript types
└── react/
    ├── client.tsx              # React hooks and components
    ├── server.ts               # Server actions
    ├── server_streaming.ts     # Streaming server actions
    ├── server_streaming_types.ts # Streaming type definitions
    └── types.ts                # React-specific types
```
</CodeBlocks>

## Dependencies

Required packages in your package.json:

```json
{
  "dependencies": {
    "@boundaryml/baml": "latest",
    "next": "latest", // Works with 14.x and 15.x
    "react": "latest", // Works with 18.x and 19.x
    "react-dom": "latest" // Works with 18.x and 19.x
  }
}
```

## React Hooks API

The generator creates React hooks for each BAML function with support for both streaming and non-streaming modes:

<CodeBlocks>
```baml BAML
function TestAws(input: string) -> string {
  client GPT35
  prompt #"
    Process this input: {{ input }}
  "#
}
```

```tsx Basic Usage
'use client'

import { useTestAws } from '@/baml_client/react/client'

function MyComponent() {
  const {
    data,           // Final response
    error,          // Error if any
    isPending,      // Loading state
    mutate         // Function to call
  } = useTestAws()

  return (
    <div>
      <button onClick={() => mutate("test input")}>
        {isPending ? "Loading..." : "Submit"}
      </button>
      {data && <div>{data}</div>}
      {error && <div>Error: {error.message}</div>}
    </div>
  )
}
```

```tsx Streaming Usage
'use client'

function MyStreamingComponent() {
  const {
    data,           // Final complete response
    partialData,    // Latest partial response
    isPending,      // Loading state
    mutate         // Function to call
  } = useTestAws({
    stream: true,
    onPartial: (partial) => {
      console.log("Partial update:", partial)
    },
    onFinal: (final) => {
      console.log("Final response:", final)
    }
  })

  const response = isPending ? partialData : data

  return (
    <div>
      <button onClick={() => mutate("test input")}>
        {isPending ? "Processing..." : "Submit"}
      </button>
      {response && <div>{response}</div>}
    </div>
  )
}
```
</CodeBlocks>

### Hook Configuration

The hooks accept configuration options for both streaming and non-streaming modes:

<CodeBlocks>
```typescript Hook Options
type HookOptions<T> = {
  // Enable streaming mode
  stream?: boolean

  // Callbacks
  onPartial?: (partial?: PartialType) => void
  onFinal?: (final?: FinalType) => void
  onError?: (error: Error) => void

  // Request options
  timeout_ms?: number
  signal?: AbortSignal
}

// Usage
const result = useTestAws({
  stream: true,
  onPartial: (response) => console.log(response),
  onFinal: (response) => console.log("Final:", response),
  onError: (error) => console.error(error),
  timeout_ms: 30000
})
```
</CodeBlocks>

### Hook Result Types

The hooks return different result types based on streaming mode:

<CodeBlocks>
```typescript Type Definitions
// Non-streaming result
type NonStreamingHookResult<T> = {
  data?: FinalType
  error?: Error | BamlValidationError | BamlClientFinishReasonError
  isError: boolean
  isPending: boolean
  isSuccess: boolean
  status: 'idle' | 'pending' | 'success' | 'error'
  mutate: (...args: InputType) => Promise<FinalType>
}

// Streaming result
type StreamingHookResult<T> = {
  data?: FinalType
  partialData?: PartialType
  error?: Error | BamlValidationError | BamlClientFinishReasonError
  isError: boolean
  isPending: boolean
  isSuccess: boolean
  status: 'idle' | 'pending' | 'success' | 'error'
  mutate: (...args: InputType) => Promise<ReadableStream<Uint8Array>>
}
```

```tsx Type Safety Example
type ResponseCardProps = {
  streamingHookResult: StreamingHookResult<'TestAws'>
  nonStreamingHookResult: NonStreamingHookResult<'TestAws'>
  status: HookResult['status']
}

function ResponseCard({
  streamingHookResult,
  nonStreamingHookResult,
  status
}: ResponseCardProps) {
  const { isPending, error, isError, data, partialData } = streamingHookResult
  const response = isPending ? partialData : data

  return (
    <>
      {isError && (
        <Alert variant="destructive">
          <AlertDescription>Error: {error?.message}</AlertDescription>
        </Alert>
      )}

      {response && (
        <pre className="whitespace-pre-wrap">
          {typeof response === 'string' ? response : JSON.stringify(response, null, 2)}
        </pre>
      )}
      <div>{status}</div>
    </>
  )
}
```
</CodeBlocks>

## Server Components Integration

The generator creates server actions for use in Next.js Server Components:

<CodeBlocks>
```tsx Server Component
// app/page.tsx
import { TestAws } from '@/baml_client/react/server'

export default async function Page() {
  // Direct server-side call
  const result = await TestAws("test input")

  return <div>{result}</div>
}
```

```tsx Streaming Server Component
// app/page.tsx
import { TestAws } from '@/baml_client/react/server_streaming'

export default async function Page() {
  const stream = TestAws("test input")

  return (
    <Suspense fallback={<div>Loading...</div>}>
      <StreamingResponse stream={stream} />
    </Suspense>
  )
}
```
</CodeBlocks>

## Advanced Usage

### Type-Safe Component Composition

<CodeBlocks>
```tsx Type-Safe Components
import { useTestAws } from '@/baml_client/react/client'
import type {
  HookResult,
  StreamingHookResult,
  NonStreamingHookResult
} from '@/baml_client/react/types'

// Generic hook result handler
function BamlComponent<T extends ActionKey>({
  hookResult
}: {
  hookResult: HookResult<T>
}) {
  if ('partialData' in hookResult) {
    // TypeScript knows this is streaming
    return <div>{hookResult.partialData}</div>
  }
  // TypeScript knows this is non-streaming
  return <div>{hookResult.data}</div>
}

// Specific implementation
function TestAwsComponent() {
  const streamingResult = useTestAws({ stream: true })
  const nonStreamingResult = useTestAws()

  // Type checking ensures correct usage
  streamingResult satisfies StreamingHookResult<'TestAws'>
  nonStreamingResult satisfies NonStreamingHookResult<'TestAws'>

  return (
    <div>
      <BamlComponent hookResult={streamingResult} />
      <BamlComponent hookResult={nonStreamingResult} />
    </div>
  )
}
```
</CodeBlocks>

### Resource Management

<CodeBlocks>
```tsx Cleanup Example
function StreamingComponent() {
  const streamController = useRef<AbortController | null>(null)

  const { mutate } = useTestAws({
    stream: true,
    onPartial: (data) => {
      // Handle streaming data
    }
  })

  const handleSubmit = async (input: string) => {
    // Cleanup previous stream
    streamController.current?.abort()

    // Create new controller
    streamController.current = new AbortController()

    try {
      await mutate(input, {
        signal: streamController.current.signal
      })
    } catch (e) {
      if (e.name === 'AbortError') {
        console.log('Stream aborted')
        return
      }
      throw e
    }
  }

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      streamController.current?.abort()
    }
  }, [])

  return <button onClick={() => handleSubmit("test")}>Start Stream</button>
}
```
</CodeBlocks>

### Error Handling

<CodeBlocks>
```tsx Error Boundary
class BamlErrorBoundary extends React.Component<{
  onError?: (error: Error) => void
  fallback: React.ReactNode
}> {
  state = { error: null }

  static getDerivedStateFromError(error: Error) {
    return { error }
  }

  componentDidCatch(error: Error) {
    this.props.onError?.(error)
  }

  render() {
    if (this.state.error) {
      return this.props.fallback
    }
    return this.props.children
  }
}

// Usage
function App() {
  return (
    <BamlErrorBoundary
      onError={(error) => {
        console.error('BAML Error:', error)
      }}
      fallback={<ErrorDisplay />}
    >
      <TestAwsComponent />
    </BamlErrorBoundary>
  )
}
```
</CodeBlocks>

## Best Practices

1. **Resource Management**
   ```tsx
   // Good - Proper cleanup
   useEffect(() => {
     const controller = new AbortController()
     return () => controller.abort()
   }, [])

   // Bad - No cleanup
   useEffect(() => {
     // Stream might continue after unmount
   }, [])
   ```

2. **Type Safety**
   ```tsx
   // Good - Type-safe props
   function BamlComponent<T extends ActionKey>({
     hookResult
   }: {
     hookResult: HookResult<T>
   }) {
     return <div>{hookResult.data}</div>
   }

   // Bad - Generic props
   function BamlComponent({ result }: any) {
     return <div>{result.data}</div>
   }
   ```

3. **Error Handling**
   ```tsx
   // Good - Specific error handling
   try {
     await mutate(input)
   } catch (error) {
     if (error instanceof BamlValidationError) {
       // Handle validation error
     } else if (error instanceof BamlClientError) {
       // Handle client error
     }
   }

   // Bad - Generic error handling
   try {
     await mutate(input)
   } catch (error: any) {
     console.error(error)
   }
   ```

4. **Performance**
   ```tsx
   // Good - Controlled updates
   const [state, setState] = useState()
   const updateRef = useRef(0)

   useTestAws({
     stream: true,
     onPartial: (data) => {
       const current = ++updateRef.current
       requestAnimationFrame(() => {
         if (current === updateRef.current) {
           setState(data)
         }
       })
     }
   })

   // Bad - Too many updates
   useTestAws({
     stream: true,
     onPartial: (data) => setState(data)
   })
   ```

## Type Definitions

### Hook Types (from `baml_client/react/types.ts`)

<ParamField
  path="BamlStreamResponse<PartialType, FinalType>"
  type="type"
>
  Type representing a BAML stream response.
  ```typescript
  // Type definition
  {
    partial?: PartialType
    final?: FinalType
    error?: Error | BamlValidationError | BamlClientFinishReasonError
  }

  // Example
  const response: BamlStreamResponse<string, string> = {
    partial: "Hello ",
    final: "Hello World!"
  }
  ```
</ParamField>

<ParamField
  path="ServerAction<Input, Output>"
  type="type"
>
  A server action that returns either a ReadableStream or final output.
  ```typescript
  // Type definition
  (...args: Input extends any[] ? Input : [Input]) => Promise<Output> | ReadableStream<Uint8Array>

  // Example
  const action: ServerAction<string, string> = async (input) => {
    return "Response for: " + input;
  }
  ```
</ParamField>

<ParamField
  path="FinalReturnType<TActionKey>"
  type="type"
>
  Helper type to derive the final return type for an action.
  ```typescript
  // Type definition
  (typeof Actions)[TActionKey] extends (...args: any) => any
    ? Awaited<ReturnType<(typeof Actions)[TActionKey]>>
    : never

  // Example
  type TestAwsReturn = FinalReturnType<'TestAws'> // string
  ```
</ParamField>

<ParamField
  path="PartialReturnType<TActionKey>"
  type="type"
>
  Helper type to derive the partial return type for an action.
  ```typescript
  StreamingServerTypes[TActionKey]
  ```
</ParamField>

### Hook Props (from `baml_client/react/types.ts`)

<ParamField
  path="StreamingProps<TActionKey>"
  type="type"
>
  Props for streaming mode.
  ```typescript
  // Type definition
  {
    stream: true
    onPartial?: (response?: PartialReturnType<TActionKey>) => void
    onFinal?: (response?: FinalReturnType<TActionKey>) => void
    onError?: (error: Error) => void
  }

  // Example
  const props: StreamingProps<'TestAws'> = {
    stream: true,
    onPartial: (text) => console.log("Partial:", text),
    onFinal: (text) => console.log("Final:", text)
  }
  ```
</ParamField>

<ParamField
  path="NonStreamingProps<TActionKey>"
  type="type"
>
  Props for non-streaming mode.
  ```typescript
  // Type definition
  {
    stream?: false
    onFinal?: (response?: FinalReturnType<TActionKey>) => void
    onError?: (error: Error) => void
  }

  // Example
  const props: NonStreamingProps<'TestAws'> = {
    onFinal: (text) => console.log("Result:", text)
  }
  ```
</ParamField>

### Hook Results (from `baml_client/react/types.ts` and `baml_client/react/client.tsx`)

<ParamField
  path="BaseHookResult<TActionKey>"
  type="type"
>
  Base return type for all BAML hooks.
  ```typescript
  // Type definition
  {
    data?: FinalReturnType<TActionKey>
    error?: Error | BamlValidationError | BamlClientFinishReasonError
    isError: boolean
    isPending: boolean
    isSuccess: boolean
    status: 'idle' | 'pending' | 'success' | 'error'
  }

  // Example
  const result: BaseHookResult<'TestAws'> = {
    data: "Hello World",
    isError: false,
    isPending: false,
    isSuccess: true,
    status: 'success'
  }
  ```
</ParamField>

<ParamField
  path="StreamingHookResult<TActionKey>"
  type="type"
>
  Return type for streaming mode BAML hooks.
  ```typescript
  // Type definition
  BaseHookResult<TActionKey> & {
    partialData?: PartialReturnType<TActionKey>
    mutate: (...input: Parameters<(typeof Actions)[TActionKey]>) => Promise<ReadableStream<Uint8Array>>
  }

  // Example
  const result: StreamingHookResult<'TestAws'> = {
    data: "Hello World",
    partialData: "Hello ",
    isError: false,
    isPending: true,
    isSuccess: false,
    status: 'pending',
    mutate: async (input) => new ReadableStream()
  }
  ```
</ParamField>

### Server Types (from `baml_client/react/server.ts` and `baml_client/react/server_streaming.ts`)

<ParamField
  path="ServerAction"
  type="type"
>
  Server-side BAML function implementation.
  ```typescript
  // Type definition
  export const TestAws = async (input: string): Promise<string> => {
    return b.TestAws(input)
  }

  // Example
  export const greet: ServerAction = async (name: string) => {
    return `Hello ${name}!`
  }
  ```
</ParamField>

<ParamField
  path="StreamingServerAction"
  type="type"
>
  Streaming server-side BAML function implementation.
  ```typescript
  // Type definition
  export const TestAws = async (input: string): Promise<ReadableStream<Uint8Array>> => {
    return b.stream.TestAws(input)
  }

  // Example
  export const streamGreet: StreamingServerAction = async (name: string) => {
    const stream = new ReadableStream({
      start(controller) {
        controller.enqueue("Hello ");
        controller.enqueue(name);
        controller.enqueue("!");
        controller.close();
      }
    });
    return stream;
  }
  ```
</ParamField>

### Error Types (from `@boundaryml/baml/errors`)

<ParamField
  path="BamlValidationError"
  type="class"
>
  Error thrown when BAML fails to parse LLM output.
  ```typescript
  // Type definition
  {
    message: string
    prompt: string
    raw_output: string
    type: 'BamlValidationError'
  }

  // Example
  const error = new BamlValidationError({
    message: "Failed to parse response",
    prompt: "What is 2+2?",
    raw_output: "five",
    type: 'BamlValidationError'
  })
  ```
</ParamField>

<ParamField
  path="BamlClientError"
  type="class"
>
  Error thrown when there's a client-side error.
  ```typescript
  // Type definition
  {
    message: string
    type: 'BamlClientError'
  }

  // Example
  const error = new BamlClientError({
    message: "Request timeout",
    type: 'BamlClientError'
  })
  ```
</ParamField>

<ParamField
  path="BamlClientFinishReasonError"
  type="class"
>
  Error thrown when LLM terminates with a disallowed finish reason.
  ```typescript
  // Type definition
  {
    message: string
    prompt: string
    raw_output: string
    type: 'BamlClientFinishReasonError'
  }

  // Example
  const error = new BamlClientFinishReasonError({
    message: "LLM stopped early",
    prompt: "Write a story",
    raw_output: "Once upon",
    type: 'BamlClientFinishReasonError'
  })
  ```
</ParamField>

## Troubleshooting

### Memory Management

When using streaming responses, be careful with state updates to avoid memory leaks:

<CodeBlocks>
```tsx Memory Leaks
// ❌ Potential memory leak - too many updates
function Component() {
  const [state, setState] = useState()

  useTestAws({
    stream: true,
    onPartial: (data) => {
      setState(data) // Updates on every chunk
    }
  })
}

// ✅ Controlled updates
function Component() {
  const [state, setState] = useState()
  const updateRef = useRef(0)

  useTestAws({
    stream: true,
    onPartial: (data) => {
      const current = ++updateRef.current
      requestAnimationFrame(() => {
        if (current === updateRef.current) {
          setState(data)
        }
      })
    }
  })
}
```
</CodeBlocks>

### Race Conditions

When making multiple calls in quick succession:

<CodeBlocks>
```tsx Race Conditions
// ❌ Race condition prone
function Component() {
  const { mutate } = useTestAws()
  const [results, setResults] = useState([])

  const handleMultipleCalls = async () => {
    const calls = [1, 2, 3].map(i => mutate(`input ${i}`))
    const responses = await Promise.all(calls)
    setResults(responses) // May not match call order
  }
}

// ✅ Race condition safe
function Component() {
  const { mutate } = useTestAws()
  const [results, setResults] = useState([])
  const latestCallId = useRef(0)

  const handleMultipleCalls = async () => {
    const callId = ++latestCallId.current

    const calls = [1, 2, 3].map(async (i) => {
      const response = await mutate(`input ${i}`)
      if (callId === latestCallId.current) {
        return response
      }
      return null
    })

    const responses = await Promise.all(calls)
    if (callId === latestCallId.current) {
      setResults(responses.filter(Boolean))
    }
  }
}
```
</CodeBlocks>

### Server Component Data Flow

When passing data from Server Components to Client Components:

<CodeBlocks>
```tsx Serialization
// ❌ Potential serialization issues
async function ServerComponent() {
  const result = await TestAws("input")
  return <ClientComponent data={result} /> // May fail for complex types
}

// ✅ Safe serialization
async function ServerComponent() {
  const result = await TestAws("input")

  // Serialize dates and complex objects
  const serializedResult = JSON.parse(JSON.stringify(result,
    (key, value) => {
      if (value instanceof Date) {
        return value.toISOString()
      }
      return value
    }
  ))

  return <ClientComponent data={serializedResult} />
}

// Type-safe client component
function ClientComponent({
  data
}: {
  data: SerializableType<HookResultData<'TestAws'>>
}) {
  return <div>{JSON.stringify(data)}</div>
}

// Utility type for serializable data
type SerializableType<T> = {
  [P in keyof T]: T[P] extends Date
    ? string
    : T[P] extends object
      ? SerializableType<T[P]>
      : T[P]
}
```
</CodeBlocks>

### Error Recovery

When handling errors in streaming responses:

<CodeBlocks>
```tsx Error Recovery
function StreamingComponent() {
  const { mutate } = useTestAws({
    stream: true,
    onError: (error) => {
      if (error instanceof BamlValidationError) {
        // Log validation errors for debugging
        console.error('Validation Error:', {
          message: error.message,
          prompt: error.prompt,
          rawOutput: error.raw_output
        })
      }
    }
  })

  const retry = useCallback(async (input: string) => {
    const maxRetries = 3
    let attempts = 0

    while (attempts < maxRetries) {
      try {
        return await mutate(input)
      } catch (error) {
        attempts++
        if (attempts === maxRetries) throw error
        await new Promise(resolve => setTimeout(resolve, 1000 * attempts))
      }
    }
  }, [mutate])

  return <button onClick={() => retry("test input")}>Try Request</button>
}
```
</CodeBlocks>

### Resource Cleanup

Ensure proper cleanup of resources, especially for streaming responses:

<CodeBlocks>
```tsx Resource Cleanup
function StreamingComponent() {
  const controller = useRef<AbortController>()
  const cleanup = useRef<(() => void) | null>(null)

  const { mutate } = useTestAws({
    stream: true,
    onPartial: (data) => {
      // Handle streaming data
    }
  })

  const handleStream = async (input: string) => {
    try {
      // Cleanup previous stream
      cleanup.current?.()

      // Setup new stream
      controller.current = new AbortController()
      const stream = await mutate(input, {
        signal: controller.current.signal
      })

      // Setup cleanup for this stream
      const reader = stream.getReader()
      cleanup.current = () => {
        controller.current?.abort()
        reader.cancel()
      }

      while (true) {
        const { done, value } = await reader.read()
        if (done) break
        // Process value
      }
    } catch (e) {
      if (e.name === 'AbortError') {
        console.log('Stream aborted')
        return
      }
      throw e
    }
  }

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      cleanup.current?.()
    }
  }, [])

  return <button onClick={() => handleStream("test")}>Start Stream</button>
}
```
</CodeBlocks>

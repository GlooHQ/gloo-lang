---
title: Error Types
description: Error types for handling BAML-specific errors
---

BAML provides specific error types to handle different error scenarios when working with LLMs. These errors can occur in both [Generated Hooks](./generated-hooks) and [useBamlAction](./use-baml-action).

<Warning>
  Always check for specific error types to handle errors appropriately. For hook error handling configuration, see [Hook Props](./hook-props).
</Warning>

<CodeBlocks>
```typescript Type Definitions
class BamlValidationError extends Error {
  type: 'BamlValidationError'
  message: string
  prompt: string
  raw_output: string
}

class BamlClientError extends Error {
  type: 'BamlClientError'
  message: string
}

class BamlClientFinishReasonError extends Error {
  type: 'BamlClientFinishReasonError'
  message: string
  prompt: string
  raw_output: string
}
```

```typescript Example Usage
try {
  const result = await testAws("input")
} catch (error) {
  if (error instanceof BamlValidationError) {
    console.error('Validation failed:', {
      message: error.message,
      prompt: error.prompt,
      output: error.raw_output
    })
  } else if (error instanceof BamlClientError) {
    console.error('Client error:', error.message)
  } else if (error instanceof BamlClientFinishReasonError) {
    console.error('LLM stopped early:', {
      message: error.message,
      prompt: error.prompt,
      output: error.raw_output
    })
  }
}
```
</CodeBlocks>

## BamlValidationError

Thrown when BAML fails to parse or validate LLM output.

<ParamField
  path="type"
  type="'BamlValidationError'"
>
  Literal type identifier for the error.
</ParamField>

<ParamField
  path="message"
  type="string"
>
  Human-readable error message explaining the validation failure.
</ParamField>

<ParamField
  path="prompt"
  type="string"
>
  The prompt that was sent to the LLM.
</ParamField>

<ParamField
  path="raw_output"
  type="string"
>
  The raw output from the LLM that failed validation.
</ParamField>

## BamlClientError

Thrown when there's a client-side error (e.g., network issues, timeouts).

<ParamField
  path="type"
  type="'BamlClientError'"
>
  Literal type identifier for the error.
</ParamField>

<ParamField
  path="message"
  type="string"
>
  Human-readable error message explaining the client error.
</ParamField>

## BamlClientFinishReasonError

Thrown when the LLM terminates with a disallowed finish reason.

<ParamField
  path="type"
  type="'BamlClientFinishReasonError'"
>
  Literal type identifier for the error.
</ParamField>

<ParamField
  path="message"
  type="string"
>
  Human-readable error message explaining why the LLM stopped.
</ParamField>

<ParamField
  path="prompt"
  type="string"
>
  The prompt that was sent to the LLM.
</ParamField>

<ParamField
  path="raw_output"
  type="string"
>
  The partial output from the LLM before it stopped.
</ParamField>

## Usage with React Hooks

Error handling in React components. For complete hook usage, see [Hook Result](./hook-result).

<CodeBlocks>
```typescript Hook Error Handling
function ErrorBoundaryExample() {
  return (
    <ErrorBoundary
      fallback={({ error }) => {
        if (error instanceof BamlValidationError) {
          return (
            <div>
              <h3>Validation Error</h3>
              <pre>{error.raw_output}</pre>
            </div>
          )
        }
        return <div>Error: {error.message}</div>
      }}
    >
      <MyComponent />
    </ErrorBoundary>
  )
}

function HookExample() {
  const { error } = useTestAws({
    onError: (error) => {
      if (error instanceof BamlValidationError) {
        // Log validation errors for debugging
        console.error('Validation Error:', {
          message: error.message,
          prompt: error.prompt,
          output: error.raw_output
        })
      }
    }
  })

  if (error) {
    return <ErrorDisplay error={error} />
  }

  return <div>No errors</div>
}
```
</CodeBlocks>

## Usage with Server Actions

When using server actions, errors should be handled appropriately on both server and client sides. For server-side usage, see [Server Action](./server-action).

## Best Practices

1. **Error Type Checking**
   ```typescript
   // ✅ Good - Check specific error types
   try {
     await testAws("input")
   } catch (error) {
     if (error instanceof BamlValidationError) {
       handleValidationError(error)
     } else if (error instanceof BamlClientError) {
       handleClientError(error)
     }
   }

   // ❌ Bad - Generic error handling
   try {
     await testAws("input")
   } catch (error: any) {
     console.error(error.message)
   }
   ```

2. **Error Recovery**
   ```typescript
   // ✅ Good - Different strategies per error type
   async function withRecovery() {
     try {
       return await testAws("input")
     } catch (error) {
       if (error instanceof BamlValidationError) {
         // Try with different prompt
         return await testAws("alternative input")
       }
       if (error instanceof BamlClientError) {
         // Retry with backoff
         return await retry(() => testAws("input"))
       }
       throw error
     }
   }

   // ❌ Bad - Same recovery for all errors
   async function withRecovery() {
     try {
       return await testAws("input")
     } catch {
       return await testAws("input") // Simple retry
     }
   }
   ```

3. **Error Logging**
   ```typescript
   // ✅ Good - Log relevant error details
   function logError(error: Error) {
     if (error instanceof BamlValidationError) {
       console.error('Validation Error:', {
         message: error.message,
         prompt: error.prompt,
         output: error.raw_output
       })
     } else {
       console.error('Error:', error.message)
     }
   }

   // ❌ Bad - Missing error details
   function logError(error: Error) {
     console.error(error.message)
   }

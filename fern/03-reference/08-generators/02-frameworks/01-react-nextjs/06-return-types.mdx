---
title: Return Types
description: Utility types for inferring BAML action return types
---

Return type utilities help infer the correct types for both partial and final responses from BAML actions. These types are used by [Generated Hooks](./generated-hooks) and [useBamlAction](./use-baml-action).

<Warning>
  These types are used internally by hooks and server actions but can also be used directly for type inference. For server-side usage, see [Server Action](./server-action).
</Warning>

<CodeBlocks>
```typescript Type Definitions
// Final return type
type FinalReturnType<TActionKey> = (typeof Actions)[TActionKey] extends (...args: any) => any
  ? Awaited<ReturnType<(typeof Actions)[TActionKey]>>
  : never

// Partial return type for streaming
type PartialReturnType<TActionKey> = StreamingServerTypes[TActionKey]
```

```typescript Example Usage
// Type inference for final results
type TestAwsResult = FinalReturnType<'TestAws'> // string

// Type inference for partial results
type TestAwsPartial = PartialReturnType<'TestAws'> // string

// Complex type example
interface ChatMessage {
  role: 'user' | 'assistant'
  content: string
}

type ChatResult = FinalReturnType<'ChatCompletion'> // ChatMessage[]
type ChatPartial = PartialReturnType<'ChatCompletion'> // ChatMessage
```
</CodeBlocks>

## Type Parameters

<ParamField
  path="TActionKey"
  type="generic"
>
  The key of the BAML action to get return types for. Must be a valid action name.
</ParamField>

## Usage with Hooks

Return types are commonly used with BAML's React hooks. For complete hook usage, see [Hook Props](./hook-props) and [Hook Result](./hook-result).

## Usage with Custom Types

Return types can be used to create type-safe wrappers and utilities:

<CodeBlocks>
```typescript Custom Utilities
// Type-safe response wrapper
type ResponseWrapper<TActionKey> = {
  timestamp: Date
  data: FinalReturnType<TActionKey>
}

// Type-safe streaming handler
type StreamHandler<TActionKey> = {
  onPartial: (data: PartialReturnType<TActionKey>) => void
  onFinal: (data: FinalReturnType<TActionKey>) => void
}

// Usage
const wrapper: ResponseWrapper<'TestAws'> = {
  timestamp: new Date(),
  data: "Hello World" // Must match TestAws return type
}

const handler: StreamHandler<'TestAws'> = {
  onPartial: (partial) => console.log(partial),
  onFinal: (final) => console.log(final)
}
```
</CodeBlocks>

## Best Practices

1. **Type Safety**
   ```typescript
   // ✅ Good - Use type inference
   type Result = FinalReturnType<'TestAws'>
   const data: Result = await testAws()

   // ❌ Bad - Manual type definition
   type Result = string // Might get out of sync
   const data: Result = await testAws()
   ```

2. **Type Constraints**
   ```typescript
   // ✅ Good - Ensure action exists
   function process<T extends keyof typeof Actions>(
     action: T,
     data: FinalReturnType<T>
   ) {
     // Process data
   }

   // ❌ Bad - No type constraint
   function process<T>(
     action: T,
     data: any
   ) {
     // Process data
   }
   ```

3. **Streaming Types**
   ```typescript
   // ✅ Good - Handle both types
   function handle<T extends keyof typeof Actions>(
     partial: PartialReturnType<T>,
     final: FinalReturnType<T>
   ) {
     // Handle both types appropriately
   }

   // ❌ Bad - Assume types are the same
   function handle<T extends keyof typeof Actions>(
     partial: FinalReturnType<T>,
     final: FinalReturnType<T>
   ) {
     // Might not work with different partial types
   }

---
title: TypeScript Generator
---

The TypeScript generator creates a fully typed client library for your BAML functions, with support for modern TypeScript features and ESM/CommonJS modules.

## Configuration

<CodeBlocks>
```baml BAML
generator lang_typescript {
  output_type typescript
  output_dir "../typescript"
  version "0.74.0"
}
```

```txt Generated Files
baml_client/
├── async_client.ts    # Asynchronous client methods
├── sync_client.ts     # Synchronous client methods
├── globals.ts         # Global configuration
├── index.ts          # Main entry point and exports
├── inlinedbaml.ts    # Inlined BAML definitions
├── partial_types.ts   # Types for streaming responses
├── tracing.ts        # Tracing utilities
├── type_builder.ts   # Type construction utilities
└── types.ts          # Generated TypeScript types
```
</CodeBlocks>

## Dependencies

Required packages in your package.json:

```json
{
  "dependencies": {
    "@boundaryml/baml": "latest"
  }
}
```

## Type System

### BAML to TypeScript Type Mapping

<CodeBlocks>
```baml BAML
class UniverseQuestion {
  question string
  confidence float
}

enum Tag {
  Security
  AI
  Blockchain
}

function AnalyzeQuestion(input: UniverseQuestion) -> Tag {
  client GPT35
  prompt #"
    Analyze the question and return the most relevant tag.
  "#
}
```

```typescript Generated Types
export interface UniverseQuestion {
  question: string;
  confidence: number;
}

export enum Tag {
  Security = "Security",
  AI = "AI",
  Blockchain = "Blockchain"
}

export function AnalyzeQuestion(input: UniverseQuestion): Promise<Tag>;
export function AnalyzeQuestion(
  input: UniverseQuestion,
  options?: BamlOptions
): Promise<Tag>;
```
</CodeBlocks>

### Function Implementation

<CodeBlocks>
```baml BAML
function TestUniverseQuestion(input: string) -> string {
  client GPT35
  prompt #"
    Answer this question about the universe: {{ input }}
  "#
}
```

```typescript Usage
import { b } from './baml_client';

// Basic function call
const response = await b.TestUniverseQuestion("What is dark matter?");
console.log(response);

// With options
const response = await b.TestUniverseQuestion(
  "What is dark matter?",
  { timeout_ms: 30000 }
);
```
</CodeBlocks>

### Streaming Support

The TypeScript generator provides streaming support with async iterators:

<CodeBlocks>
```typescript Basic Streaming
// Using async iterator
const stream = b.stream.TestUniverseQuestion("What is dark matter?");
for await (const partial of stream) {
  console.log("Partial response:", partial);
}

// Get final response
const final = await stream.getFinalResponse();
```

```typescript Complex Types
// Streaming with semantic types
const stream = b.stream.MakeSemanticContainer();

for await (const msg of stream) {
  if (msg.class_needed?.s_20_words?.value) {
    // Handle partial updates
    console.log("Current state:", msg.class_needed.s_20_words.state);
  }

  // Access stable fields
  if (msg.sixteen_digit_number != null) {
    console.log("Number:", msg.sixteen_digit_number);
  }
}

const final = await stream.getFinalResponse();
```
</CodeBlocks>

### Error Handling

The generator provides specialized error types for handling BAML-specific errors:

<CodeBlocks>
```typescript Error Handling
import { BamlValidationError, BamlClientError } from './baml_client';

try {
  const response = await b.TestUniverseQuestion("What is dark matter?");
} catch (error) {
  if (error instanceof BamlValidationError) {
    console.error("Validation failed:", error.message);
    console.error("Original prompt:", error.prompt);
    console.error("Raw output:", error.raw_output);
  } else if (error instanceof BamlClientError) {
    console.error("Client error:", error.message);
  } else {
    console.error("Other error:", error);
  }
}
```

```typescript Streaming Errors
try {
  const stream = b.stream.TestUniverseQuestion("What is dark matter?");
  for await (const partial of stream) {
    console.log(partial);
  }
  const final = await stream.getFinalResponse();
} catch (error) {
  if (error instanceof BamlValidationError) {
    console.error("Validation error:", error.message);
  } else if (error instanceof BamlClientError) {
    console.error("Client error:", error.message);
  }
}
```
</CodeBlocks>

### Type Safety

The generator provides full type safety through TypeScript:

<CodeBlocks>
```typescript Type Safety
import { b } from './baml_client';
import type { SemanticContainer } from './baml_client/partial_types';

async function processStream(stream: AsyncIterable<SemanticContainer>) {
  for await (const msg of stream) {
    // Type-safe access to fields
    if (msg.class_needed?.s_20_words?.state === "Complete") {
      console.log("Completed:", msg.class_needed.s_20_words.value);
    }

    // Array handling with type safety
    for (const item of msg.three_small_things) {
      console.log("Item:", item.i_16_digits);
    }
  }
}

// Usage
const stream = b.stream.MakeSemanticContainer();
await processStream(stream);
```
</CodeBlocks>

## Best Practices

1. **Type Safety**
   ```typescript
   // Good - Type-safe function calls
   const response = await b.TestUniverseQuestion("What is dark matter?");

   // Bad - Unsafe type assertions
   const response = await b.TestUniverseQuestion(123 as unknown as string);
   ```

2. **Error Handling**
   ```typescript
   // Good - Specific error handling
   try {
     const response = await b.TestUniverseQuestion(input);
   } catch (error) {
     if (error instanceof BamlValidationError) {
       console.error("Validation error:", error.message);
     } else if (error instanceof BamlClientError) {
       console.error("Client error:", error.message);
     }
   }

   // Bad - Generic error handling
   try {
     const response = await b.TestUniverseQuestion(input);
   } catch (error: any) {
     console.error(error);
   }
   ```

3. **Streaming**
   ```typescript
   // Good - Resource cleanup
   const stream = b.stream.TestUniverseQuestion(input);
   try {
     for await (const partial of stream) {
       process(partial);
     }
   } finally {
     await stream.close();
   }

   // Bad - No cleanup
   const stream = b.stream.TestUniverseQuestion(input);
   for await (const partial of stream) {
     process(partial);
   }
   ```

4. **Development**
   ```json
   // Good - Explicit dependencies
   {
     "dependencies": {
       "@boundaryml/baml": "latest"
     },
     "devDependencies": {
       "typescript": "latest",
       "@types/node": "latest"
     }
   }
   ```

## Type Definitions

### Core Types (from `baml_client/types.ts`)

<ParamField
  path="BamlStreamResponse<PartialType, FinalType>"
  type="type"
>
  Type representing a BAML stream response.
  ```typescript
  // Type definition
  {
    partial?: PartialType
    final?: FinalType
    error?: Error | BamlValidationError | BamlClientFinishReasonError
  }

  // Example - Simple text streaming
  const response: BamlStreamResponse<string, string> = {
    partial: "The capital of France is",
    final: "The capital of France is Paris"
  }
  ```
</ParamField>

<ParamField
  path="BamlOptions"
  type="type"
>
  Options for BAML function calls.
  ```typescript
  // Type definition
  {
    timeout_ms?: number
    signal?: AbortSignal
  }

  // Example - Setting timeout and abort signal
  const controller = new AbortController()
  const options: BamlOptions = {
    timeout_ms: 30000,
    signal: controller.signal
  }
  ```
</ParamField>

### Client Types (from `baml_client/async_client.ts` and `baml_client/sync_client.ts`)

<ParamField
  path="BamlClient"
  type="class"
>
  Main BAML client interface.
  ```typescript
  // Type definition
  class BamlClient {
    TestAws(input: string): Promise<string>
    TestAws(input: string, options?: BamlOptions): Promise<string>
    stream: {
      TestAws(input: string): AsyncIterable<string>
    }
  }

  // Example - Using the client
  const client = new BamlClient()
  const result = await client.TestAws("What is BAML?")
  for await (const chunk of client.stream.TestAws("Tell me a story")) {
    console.log(chunk)
  }
  ```
</ParamField>

### Error Types (from `@boundaryml/baml/errors`)

<ParamField
  path="BamlValidationError"
  type="class"
>
  Error thrown when BAML fails to parse LLM output.
  ```typescript
  // Type definition
  {
    message: string
    prompt: string
    raw_output: string
    type: 'BamlValidationError'
  }

  // Example - Handling validation error
  try {
    await client.TestAws("input")
  } catch (error) {
    if (error instanceof BamlValidationError) {
      console.error(`Failed to parse: ${error.raw_output}`)
    }
  }
  ```
</ParamField>

<ParamField
  path="BamlClientError"
  type="class"
>
  Error thrown when there's a client-side error.
  ```typescript
  // Type definition
  {
    message: string
    type: 'BamlClientError'
  }

  // Example - Network timeout error
  const error = new BamlClientError({
    message: "Request timed out after 30s",
    type: 'BamlClientError'
  })
  ```
</ParamField>

<ParamField
  path="BamlClientFinishReasonError"
  type="class"
>
  Error thrown when LLM terminates with a disallowed finish reason.
  ```typescript
  // Type definition
  {
    message: string
    prompt: string
    raw_output: string
    type: 'BamlClientFinishReasonError'
  }

  // Example - Early termination
  const error = new BamlClientFinishReasonError({
    message: "Model stopped early: max tokens reached",
    prompt: "Write a long story",
    raw_output: "Once upon a time...",
    type: 'BamlClientFinishReasonError'
  })
  ```
</ParamField>

### Type Utilities (from `baml_client/type_builder.ts`)

<ParamField
  path="BamlFunctionInput<T>"
  type="type"
>
  Extract the input type of a BAML function.
  ```typescript
  // Type definition
  type BamlFunctionInput<T> = T extends (...args: infer P) => any ? P[0] : never

  // Example - Getting input type
  type TestAwsInput = BamlFunctionInput<typeof client.TestAws> // string
  const input: TestAwsInput = "What is BAML?"
  ```
</ParamField>

<ParamField
  path="BamlFunctionOutput<T>"
  type="type"
>
  Extract the output type of a BAML function.
  ```typescript
  // Type definition
  type BamlFunctionOutput<T> = T extends (...args: any) => Promise<infer R> ? R : never

  // Example - Getting output type
  type TestAwsOutput = BamlFunctionOutput<typeof client.TestAws> // string
  const output: TestAwsOutput = await client.TestAws("input")
  ```
</ParamField>

<ParamField
  path="BamlStreamResponse<T>"
  type="type"
>
  Extract the streaming response type of a BAML function.
  ```typescript
  // Type definition
  type BamlStreamResponse<T> = T extends AsyncIterable<infer R> ? R : never

  // Example - Getting stream type
  type TestAwsStream = BamlStreamResponse<ReturnType<typeof client.stream.TestAws>> // string
  const stream: AsyncIterable<TestAwsStream> = client.stream.TestAws("input")
  ```
</ParamField>


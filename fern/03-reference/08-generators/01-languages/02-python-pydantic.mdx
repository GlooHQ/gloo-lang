---
title: Python (Pydantic) Generator
---

The Python generator creates a type-safe client library using Pydantic models for validation and serialization. It supports both synchronous and asynchronous APIs.

## Generator Configuration

<CodeBlocks>
```baml BAML
generator lang_python {
  output_type python/pydantic
  output_dir "../python"
  version "0.74.0"
}
```

```txt Generated Files
baml_client/
├── __init__.py        # Package initialization and exports
├── async_client.py    # Asynchronous client methods
├── sync_client.py     # Synchronous client methods
├── globals.py         # Global configuration
├── inlinedbaml.py     # Inlined BAML definitions
├── partial_types.py   # Types for streaming responses
├── tracing.py         # Tracing utilities
├── type_builder.py    # Type construction utilities
└── types.py          # Generated Python types
```
</CodeBlocks>

## Dependencies

Required Python packages:

```txt
baml-py=="latest"      # Works with 0.74.x and later
pydantic=="latest"     # Works with 2.x
typing-extensions=="latest"  # Works with 4.x and later
```

## Type System

### BAML to Python Type Mapping

<CodeBlocks>
```baml BAML Types
class UniverseQuestion {
  question string
  answer string
}

class UniverseQuestionInput {
  question string
}

enum Role {
  ADMIN
  USER
  GUEST
}
```

```python Generated Types
from typing import List, Dict, Literal, Any
from pydantic import BaseModel
from enum import Enum

class UniverseQuestion(BaseModel):
    question: str
    answer: str

class UniverseQuestionInput(BaseModel):
    question: str

class Role(str, Enum):
    ADMIN = "ADMIN"
    USER = "USER"
    GUEST = "GUEST"
```
</CodeBlocks>

### Function Implementation

<CodeBlocks>
```baml BAML Function
function TestUniverseQuestion(question: UniverseQuestionInput) -> UniverseQuestion {
  client AwsBedrock
  prompt #"
    You are a helpful assistant that answers questions about the universe.

    {{ ctx.output_format }}

    {{ _.role("user")}}

    Question: {{ question }}

    Answer:
  "#
}
```

```python Generated Client
# Sync client
from baml_client import UniverseQuestion, UniverseQuestionInput

def test_universe_question(
    question: UniverseQuestionInput,
    *,
    timeout: Optional[float] = None
) -> UniverseQuestion:
    return client.test_universe_question(question)

# Async client
async def test_universe_question_async(
    question: UniverseQuestionInput,
    *,
    timeout: Optional[float] = None
) -> UniverseQuestion:
    return await client.test_universe_question(question)

# Usage
input = UniverseQuestionInput(question="What is dark matter?")
result = test_universe_question(input)
print(f"Q: {result.question}")
print(f"A: {result.answer}")
```
</CodeBlocks>

### Streaming Support

The generator provides both async and sync streaming APIs with partial type support:

<CodeBlocks>
```baml BAML Function
function TestAws(input: string) -> string {
  client AwsBedrock
  prompt #"
    Write a nice short story about {{ input }}
  "#
}
```

```python Streaming Example
from baml_client.partial_types import StreamState
from baml_client.types import UniverseQuestion

# Partial type example (generated automatically)
class UniverseQuestionPartial(BaseModel):
    question: Optional[str] = None
    answer: Optional[str] = None

async def handle_stream():
    stream = client.stream.test_aws("space exploration")
    async for partial in stream:
        print(f"Partial response: {partial}")

        # Check stream state
        state = StreamState(value=partial)
        if state.state == "Complete":
            break

    # Get final complete response
    result = await stream.get_final_response()
```

```python Complex Streaming
# Handle multiple concurrent streams
async def handle_multiple_questions(questions: List[str]):
    streams = [
        client.stream.test_aws(q) for q in questions
    ]

    # Process streams as they complete
    for response in asyncio.as_completed(streams):
        result = await response
        print(f"Got response: {result}")
```
</CodeBlocks>

### Error Handling

The generator provides specialized error types for handling BAML-specific errors:

<CodeBlocks>
```python Error Example
from baml_client.errors import BamlValidationError, BamlClientFinishReasonError

async def safe_stream_handler(input: str) -> Optional[str]:
    try:
        stream = client.stream.test_aws(
            input,
            baml_options={"timeout": 30.0}
        )
        async for partial in stream:
            process_partial(partial)
        return await stream.get_final_response()

    except BamlValidationError as e:
        # Handle validation errors (schema mismatch)
        logger.error(f"Validation failed: {e.message}")
        logger.debug(f"Raw output: {e.raw_output}")
        return None

    except BamlClientFinishReasonError as e:
        # Handle LLM termination
        logger.error(f"LLM terminated: {e.finish_reason}")
        logger.debug(f"Partial output: {e.raw_output}")
        return None

    finally:
        await stream.aclose()
```
</CodeBlocks>

## Best Practices

1. **Type Safety**
   ```python
   # Good - Type annotations and validation
   async def get_answer(question: UniverseQuestionInput) -> UniverseQuestion:
       return await client.test_universe_question(question)

   # Bad - Missing types
   async def get_answer(question):
       return await client.test_universe_question(question)
   ```

2. **Performance**
   ```python
   # Good - Concurrent streams
   questions = [UniverseQuestionInput(question=q) for q in questions]
   answers = await asyncio.gather(*[
       client.test_universe_question(q)
       for q in questions
   ])

   # Bad - Sequential streams
   answers = []
   for q in questions:
       answers.append(
           await client.test_universe_question(q)
       )
   ```

3. **Development**
   ```python
   # requirements.txt - Pin versions
   baml-py==0.74.0
   pydantic==2.0.0
   typing-extensions==4.5.0
   ```

See the [Generators Overview](/ref/generators/overview) for more general generator concepts and configuration options.

## Type Definitions

### Core Types (from `baml_client/types.py`)

<ParamField
  path="BamlStreamResponse[PartialType, FinalType]"
  type="type"
>
  Type representing a BAML stream response.
  ```python
  # Type definition
  class BamlStreamResponse(Generic[PartialType, FinalType]):
      partial: Optional[PartialType]
      final: Optional[FinalType]
      error: Optional[Union[Exception, BamlValidationError, BamlClientFinishReasonError]]

  # Example - Simple text streaming
  response = BamlStreamResponse[str, str](
      partial="The capital of France is",
      final="The capital of France is Paris"
  )
  ```
</ParamField>

<ParamField
  path="BamlOptions"
  type="type"
>
  Options for BAML function calls.
  ```python
  # Type definition
  class BamlOptions(BaseModel):
      timeout: Optional[float] = None
      signal: Optional[Any] = None  # asyncio.CancelToken

  # Example - Setting timeout
  options = BamlOptions(timeout=30.0)
  result = await client.test_aws("input", **options.dict())
  ```
</ParamField>

### Client Types (from `baml_client/async_client.py` and `baml_client/sync_client.py`)

<ParamField
  path="BamlClient"
  type="class"
>
  Main BAML client interface.
  ```python
  # Type definition
  class BamlClient:
      def test_aws(self, input: str, *, timeout: Optional[float] = None) -> str: ...
      async def test_aws_async(self, input: str, *, timeout: Optional[float] = None) -> str: ...

      class stream:
          def test_aws(self, input: str) -> Iterator[str]: ...
          async def test_aws_async(self, input: str) -> AsyncIterator[str]: ...

  # Example - Using the client
  # Sync usage
  client = BamlClient()
  result = client.test_aws("What is BAML?")

  # Async usage
  async with BamlClient() as client:
      result = await client.test_aws_async("What is BAML?")
  ```
</ParamField>

### Error Types (from `baml_client/errors.py`)

<ParamField
  path="BamlValidationError"
  type="class"
>
  Error thrown when BAML fails to parse LLM output.
  ```python
  # Type definition
  class BamlValidationError(Exception):
      message: str
      prompt: str
      raw_output: str

  # Example - Handling validation error
  try:
      result = client.test_aws("input")
  except BamlValidationError as e:
      print(f"Failed to parse: {e.raw_output}")
      print(f"Original prompt: {e.prompt}")
  ```
</ParamField>

<ParamField
  path="BamlClientError"
  type="class"
>
  Error thrown when there's a client-side error.
  ```python
  # Type definition
  class BamlClientError(Exception):
      message: str

  # Example - Network timeout error
  try:
      result = await client.test_aws_async("input", timeout=1.0)
  except BamlClientError as e:
      print(f"Client error: {e.message}")
  ```
</ParamField>

<ParamField
  path="BamlClientFinishReasonError"
  type="class"
>
  Error thrown when LLM terminates with a disallowed finish reason.
  ```python
  # Type definition
  class BamlClientFinishReasonError(Exception):
      message: str
      prompt: str
      raw_output: str

  # Example - Early termination
  try:
      async for chunk in client.stream.test_aws_async("Write a long story"):
          print(chunk)
  except BamlClientFinishReasonError as e:
      print(f"LLM stopped early: {e.message}")
      print(f"Partial output: {e.raw_output}")
  ```
</ParamField>

### Type Utilities (from `baml_client/type_builder.py`)

<ParamField
  path="StreamState[T]"
  type="type"
>
  Helper class for tracking stream state.
  ```python
  # Type definition
  class StreamState(Generic[T]):
      value: Optional[T]
      state: Literal["Pending", "Complete", "Error"]

  # Example - Using stream state
  async def handle_stream():
      stream = client.stream.test_aws_async("input")
      async for chunk in stream:
          state = StreamState[str](value=chunk)
          if state.state == "Complete":
              break
          print(f"Current state: {state.state}, Value: {state.value}")
  ```
</ParamField>

<ParamField
  path="PartialType[T]"
  type="type"
>
  Helper type for partial responses.
  ```python
  # Type definition
  class PartialType(Generic[T]):
      value: Optional[T]
      is_complete: bool

  # Example - Handling partial responses
  class PartialResponse(PartialType[str]):
      pass

  partial = PartialResponse(value="Hello", is_complete=False)
  print(f"Got partial: {partial.value}, Complete: {partial.is_complete}")
  ```
</ParamField>

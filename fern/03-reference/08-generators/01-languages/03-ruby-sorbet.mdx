---
title: Ruby (Sorbet) Generator
---

The Ruby generator creates a type-safe client library using Sorbet for static type checking. It provides both synchronous and asynchronous APIs with full type safety.

## Configuration

<CodeBlocks>
```baml BAML
generator lang_ruby {
  output_type ruby/sorbet
  output_dir "../ruby"
  version "0.74.0"
}
```

```txt Generated Files
baml_client/
├── client.rb          # Main client implementation
├── errors.rb          # Error type definitions
├── globals.rb         # Global configuration
├── inlined.rb         # Inlined BAML definitions
├── partial_types.rb   # Types for streaming responses
├── stream_client.rb   # Streaming client implementation
├── type_registry.rb   # Type registration system
└── types.rb          # Generated Ruby types
```
</CodeBlocks>

## Dependencies

Required gems in your Gemfile:

```ruby
source 'https://rubygems.org'

gem 'sorbet-runtime', '~> latest'  # Works with 0.5.x
gem 'baml-client', '~> latest'     # Works with 0.74.x and later

group :development do
  gem 'sorbet'                     # Latest version recommended
end
```

## Type System

### BAML to Ruby Type Mapping

<CodeBlocks>
```baml BAML
class UniverseQuestion {
  question string
  confidence float
}

enum Tag {
  Security
  AI
  Blockchain
}

function AnalyzeQuestion(input: UniverseQuestion) -> Tag {
  client GPT35
  prompt #"
    Analyze the question and return the most relevant tag.
  "#
}
```

```ruby Generated Types
# typed: strict
require 'sorbet-runtime'

module Baml
  module Types
    class UniverseQuestion < T::Struct
      extend T::Sig

      const :question, String
      const :confidence, Float
    end

    class Tag < T::Enum
      enums do
        Security = new
        AI = new
        Blockchain = new
      end
    end
  end

  class Client
    extend T::Sig

    sig { params(input: Types::UniverseQuestion).returns(Types::Tag) }
    def analyze_question(input)
      # Implementation
    end
  end
end
```
</CodeBlocks>

### Function Implementation

<CodeBlocks>
```baml BAML
function TestUniverseQuestion(input: string) -> string {
  client GPT35
  prompt #"
    Answer this question about the universe: {{ input }}
  "#
}
```

```ruby Usage
require 'baml_client'

# Initialize client
client = Baml.Client

# Basic function call
response = client.test_universe_question("What is dark matter?")
puts response

# With options
response = client.test_universe_question(
  "What is dark matter?",
  baml_options: { timeout_ms: 30000 }
)
```
</CodeBlocks>

### Streaming Support

The Ruby generator provides streaming support with both block and enumerator interfaces:

<CodeBlocks>
```ruby Block Interface
# Block interface
client.stream.test_universe_question(input: "example") do |partial|
  puts "Partial response: #{partial}"
end

# Enumerator interface
stream = client.stream.test_universe_question(input: "example")
stream.each do |partial|
  puts "Partial response: #{partial}"
end

# Get final response
final = stream.get_final_response
```

```ruby Complex Types
# Streaming with complex types
stream = client.stream.extract_receipt_info(receipt)

stream.each do |partial|
  # Handle partial updates
  if partial.items
    puts "Found #{partial.items.length} items so far"
  end
end

# Get complete response
final = stream.get_final_response
puts "Total items: #{final.items.length}"
```
</CodeBlocks>

### Error Handling

The generator provides specialized error types for handling BAML-specific errors:

<CodeBlocks>
```ruby Error Handling
begin
  stream = client.stream.test_universe_question(input: "example")

  stream.each do |partial|
    puts "Partial: #{partial}"
  end

  final = stream.get_final_response
rescue Baml::ValidationError => e
  puts "Validation failed: #{e.message}"
  puts "Raw output: #{e.raw_output}"
rescue Baml::ClientFinishReasonError => e
  puts "LLM terminated early: #{e.message}"
rescue StandardError => e
  puts "Other error: #{e.message}"
end
```
</CodeBlocks>

### Type Safety with Sorbet

The generator provides full type safety through Sorbet:

<CodeBlocks>
```ruby Type Safety
# typed: strict
require 'sorbet-runtime'
require 'baml_client'

class ReceiptProcessor
  extend T::Sig

  sig { params(receipt: String).returns(T::Array[Item]) }
  def process_receipt(receipt)
    response = Baml.Client.extract_receipt_info(receipt)
    T.cast(response.items, T::Array[Item])
  end

  sig { params(stream: Baml::Stream[Receipt]).void }
  def handle_stream(stream)
    stream.each do |partial|
      T.cast(partial, Receipt)
      process_partial(partial)
    end
  end
end
```
</CodeBlocks>

## Best Practices

1. **Type Safety**
   ```ruby
   # Good - Type annotations and validation
   extend T::Sig
   sig { params(input: String).returns(Response) }
   def process_input(input)
     client.test_universe_question(input)
   end

   # Bad - Missing type annotations
   def process_input(input)
     client.test_universe_question(input)
   end
   ```

2. **Error Handling**
   ```ruby
   # Good - Proper error handling
   begin
     response = client.test_universe_question(input)
   rescue Baml::ValidationError => e
     logger.error("Validation error: #{e.message}")
   rescue Baml::ClientFinishReasonError => e
     logger.error("LLM terminated: #{e.finish_reason}")
   end

   # Bad - Generic error handling
   begin
     response = client.test_universe_question(input)
   rescue => e
     logger.error(e)
   end
   ```

3. **Streaming**
   ```ruby
   # Good - Resource cleanup
   stream = client.stream.test_universe_question(input)
   begin
     stream.each { |partial| process(partial) }
   ensure
     stream.close
   end

   # Bad - No cleanup
   stream = client.stream.test_universe_question(input)
   stream.each { |partial| process(partial) }
   ```

4. **Development**
   ```ruby
   # Good - Explicit dependencies
   source 'https://rubygems.org'

   gem 'sorbet-runtime', '~> 0.5.10932'
   gem 'baml-client', '~> 0.74.0'

   group :development do
     gem 'sorbet'
   end
   ```

## Type Definitions

### Core Types (from `baml_client/types.rb`)

<ParamField
  path="BamlStreamResponse[PartialType, FinalType]"
  type="type"
>
  Type representing a BAML stream response.
  ```ruby
  # Type definition
  class BamlStreamResponse < T::Struct
    extend T::Sig
    extend T::Generic

    PartialType = type_member
    FinalType = type_member

    const :partial, T.nilable(PartialType)
    const :final, T.nilable(FinalType)
    const :error, T.nilable(T.any(Exception, BamlValidationError))
  end

  # Example - Simple text streaming
  response = BamlStreamResponse[String, String].new(
    partial: "The weather in San",
    final: "The weather in San Francisco is sunny"
  )
  ```
</ParamField>

<ParamField
  path="BamlOptions"
  type="type"
>
  Options for BAML function calls.
  ```ruby
  # Type definition
  class BamlOptions < T::Struct
    extend T::Sig

    const :timeout_ms, T.nilable(Integer)
    const :retry_count, T.nilable(Integer)
  end

  # Example - Setting timeout and retries
  options = BamlOptions.new(
    timeout_ms: 30_000,
    retry_count: 3
  )
  result = client.test_aws("input", baml_options: options)
  ```
</ParamField>

### Client Types (from `baml_client/client.rb`)

<ParamField
  path="BamlClient"
  type="class"
>
  Main BAML client interface.
  ```ruby
  # Type definition
  class BamlClient
    extend T::Sig

    sig { params(input: String, baml_options: T.nilable(BamlOptions)).returns(String) }
    def test_aws(input, baml_options: nil); end

    sig { returns(StreamClient) }
    def stream; end
  end

  # Example - Using the client
  client = Baml.Client

  # Basic usage
  result = client.test_aws("What is BAML?")

  # Streaming with block
  client.stream.test_aws("Tell me a story") do |chunk|
    puts chunk
  end
  ```
</ParamField>

### Error Types (from `baml_client/errors.rb`)

<ParamField
  path="BamlValidationError"
  type="class"
>
  Error thrown when BAML fails to parse LLM output.
  ```ruby
  # Type definition
  class BamlValidationError < StandardError
    extend T::Sig

    sig { returns(String) }
    attr_reader :message, :prompt, :raw_output
  end

  # Example - Handling validation error
  begin
    result = client.test_aws("input")
  rescue BamlValidationError => e
    puts "Failed to parse: #{e.raw_output}"
    puts "Original prompt: #{e.prompt}"
  end
  ```
</ParamField>

<ParamField
  path="BamlClientError"
  type="class"
>
  Error thrown when there's a client-side error.
  ```ruby
  # Type definition
  class BamlClientError < StandardError
    extend T::Sig

    sig { returns(String) }
    attr_reader :message
  end

  # Example - Network timeout error
  begin
    result = client.test_aws("input", baml_options: BamlOptions.new(timeout_ms: 1000))
  rescue BamlClientError => e
    puts "Client error: #{e.message}"
  end
  ```
</ParamField>

### Type Utilities (from `baml_client/type_registry.rb`)

<ParamField
  path="StreamState[T]"
  type="type"
>
  Helper class for tracking stream state.
  ```ruby
  # Type definition
  class StreamState < T::Struct
    extend T::Sig
    extend T::Generic

    Value = type_member
    const :value, T.nilable(Value)
    const :state, T.enum(%w[pending complete error])
  end

  # Example - Using stream state
  def handle_stream
    client.stream.test_aws("input") do |chunk|
      state = StreamState[String].new(
        value: chunk,
        state: "pending"
      )
      break if state.state == "complete"
      puts "Current state: #{state.state}, Value: #{state.value}"
    end
  end
  ```
</ParamField>

<ParamField
  path="PartialType[T]"
  type="type"
>
  Helper type for partial responses.
  ```ruby
  # Type definition
  class PartialType < T::Struct
    extend T::Sig
    extend T::Generic

    Value = type_member
    const :value, T.nilable(Value)
    const :is_complete, T::Boolean
  end

  # Example - Handling partial responses
  class PartialResponse < PartialType
    Value = type_member { { fixed: String } }
  end

  partial = PartialResponse.new(
    value: "Hello",
    is_complete: false
  )
  puts "Got partial: #{partial.value}, Complete: #{partial.is_complete}"
  ```
</ParamField>
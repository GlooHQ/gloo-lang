In BAML, attributes are used to provide additional metadata or behavior to fields and types. They can be applied at different levels, such as field-level or block-level, depending on their intended use.

## Field-Level Attributes

Field-level attributes are applied directly to individual fields within a class or enum. They modify the behavior or metadata of that specific field.

### Examples of Field-Level Attributes

- **`@alias`**: Renames a field for better understanding by the LLM.
- **`@description`**: Provides additional context to a field.
- **`@skip`**: Excludes a field from prompts or parsing.
- **`@assert`**: Applies strict validation to a field.
- **`@check`**: Adds non-exception-raising validation to a field.

```baml BAML
class MyClass {
  property1 string @alias("name") @description("The name of the object")
  age int? @check(positive, {{ this > 0 }})
}
```

## Block-Level Attributes

Block-level attributes are applied to an entire class or enum, affecting all fields or values within that block. They are used to modify the behavior or metadata of the entire block.

### Examples of Block-Level Attributes

- **`@@dynamic`**: Allows dynamic modification of fields or values at runtime.

```baml BAML
class MyClass {
  property1 string
  property2 int?

  @@dynamic // allows adding fields dynamically at runtime
}
```

## Key Differences

- **Scope**: Field-level attributes affect individual fields, while block-level attributes affect the entire class or enum.
- **Usage**: Field-level attributes are used for specific field modifications, whereas block-level attributes are used for broader modifications affecting the whole block.

Understanding the distinction between these types of attributes is crucial for effectively using BAML to define and manipulate data structures.

For more detailed information on each attribute, refer to the specific attribute pages in this section. 